// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: interface.go

package tradier

import (
	"bytes"
	"encoding/json"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *MarketCalendar) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MarketCalendar) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Date":`)

	{

		obj, err = j.Date.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteString(`,"Description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	/* Inline struct. type=struct { Start string; End string } kind=struct */
	buf.WriteString(`,"Open":{ "Start":`)
	fflib.WriteJsonString(buf, string(j.Open.Start))
	buf.WriteString(`,"End":`)
	fflib.WriteJsonString(buf, string(j.Open.End))
	buf.WriteByte('}')
	/* Inline struct. type=struct { Start string; End string } kind=struct */
	buf.WriteString(`,"Premarket":{ "Start":`)
	fflib.WriteJsonString(buf, string(j.Premarket.Start))
	buf.WriteString(`,"End":`)
	fflib.WriteJsonString(buf, string(j.Premarket.End))
	buf.WriteByte('}')
	/* Inline struct. type=struct { Start string; End string } kind=struct */
	buf.WriteString(`,"Postmarket":{ "Start":`)
	fflib.WriteJsonString(buf, string(j.Postmarket.Start))
	buf.WriteString(`,"End":`)
	fflib.WriteJsonString(buf, string(j.Postmarket.End))
	buf.WriteByte('}')
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMarketCalendarbase = iota
	ffjtMarketCalendarnosuchkey

	ffjtMarketCalendarDate

	ffjtMarketCalendarStatus

	ffjtMarketCalendarDescription

	ffjtMarketCalendarOpen

	ffjtMarketCalendarPremarket

	ffjtMarketCalendarPostmarket
)

var ffjKeyMarketCalendarDate = []byte("Date")

var ffjKeyMarketCalendarStatus = []byte("Status")

var ffjKeyMarketCalendarDescription = []byte("Description")

var ffjKeyMarketCalendarOpen = []byte("Open")

var ffjKeyMarketCalendarPremarket = []byte("Premarket")

var ffjKeyMarketCalendarPostmarket = []byte("Postmarket")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MarketCalendar) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MarketCalendar) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMarketCalendarbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMarketCalendarnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffjKeyMarketCalendarDate, kn) {
						currentKey = ffjtMarketCalendarDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMarketCalendarDescription, kn) {
						currentKey = ffjtMarketCalendarDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffjKeyMarketCalendarOpen, kn) {
						currentKey = ffjtMarketCalendarOpen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyMarketCalendarPremarket, kn) {
						currentKey = ffjtMarketCalendarPremarket
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMarketCalendarPostmarket, kn) {
						currentKey = ffjtMarketCalendarPostmarket
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyMarketCalendarStatus, kn) {
						currentKey = ffjtMarketCalendarStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMarketCalendarPostmarket, kn) {
					currentKey = ffjtMarketCalendarPostmarket
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarketCalendarPremarket, kn) {
					currentKey = ffjtMarketCalendarPremarket
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMarketCalendarOpen, kn) {
					currentKey = ffjtMarketCalendarOpen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarketCalendarDescription, kn) {
					currentKey = ffjtMarketCalendarDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarketCalendarStatus, kn) {
					currentKey = ffjtMarketCalendarStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMarketCalendarDate, kn) {
					currentKey = ffjtMarketCalendarDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMarketCalendarnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMarketCalendarDate:
					goto handle_Date

				case ffjtMarketCalendarStatus:
					goto handle_Status

				case ffjtMarketCalendarDescription:
					goto handle_Description

				case ffjtMarketCalendarOpen:
					goto handle_Open

				case ffjtMarketCalendarPremarket:
					goto handle_Premarket

				case ffjtMarketCalendarPostmarket:
					goto handle_Postmarket

				case ffjtMarketCalendarnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Date:

	/* handler: j.Date type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Date.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Open:

	/* handler: j.Open type=struct { Start string; End string } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Start string; End string } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Open)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Premarket:

	/* handler: j.Premarket type=struct { Start string; End string } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Start string; End string } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Premarket)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Postmarket:

	/* handler: j.Postmarket type=struct { Start string; End string } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { Start string; End string } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Postmarket)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MarketStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MarketStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"date":`)

	{

		obj, err = j.Time.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"State":`)
	fflib.WriteJsonString(buf, string(j.State))
	buf.WriteString(`,"Description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"next_change":`)

	{

		obj, err = j.NextChange.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"next_state":`)
	fflib.WriteJsonString(buf, string(j.NextState))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMarketStatusbase = iota
	ffjtMarketStatusnosuchkey

	ffjtMarketStatusTime

	ffjtMarketStatusState

	ffjtMarketStatusDescription

	ffjtMarketStatusNextChange

	ffjtMarketStatusNextState
)

var ffjKeyMarketStatusTime = []byte("date")

var ffjKeyMarketStatusState = []byte("State")

var ffjKeyMarketStatusDescription = []byte("Description")

var ffjKeyMarketStatusNextChange = []byte("next_change")

var ffjKeyMarketStatusNextState = []byte("next_state")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MarketStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MarketStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMarketStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMarketStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffjKeyMarketStatusDescription, kn) {
						currentKey = ffjtMarketStatusDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyMarketStatusState, kn) {
						currentKey = ffjtMarketStatusState
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyMarketStatusTime, kn) {
						currentKey = ffjtMarketStatusTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMarketStatusNextChange, kn) {
						currentKey = ffjtMarketStatusNextChange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMarketStatusNextState, kn) {
						currentKey = ffjtMarketStatusNextState
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMarketStatusNextState, kn) {
					currentKey = ffjtMarketStatusNextState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMarketStatusNextChange, kn) {
					currentKey = ffjtMarketStatusNextChange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarketStatusDescription, kn) {
					currentKey = ffjtMarketStatusDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarketStatusState, kn) {
					currentKey = ffjtMarketStatusState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMarketStatusTime, kn) {
					currentKey = ffjtMarketStatusTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMarketStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMarketStatusTime:
					goto handle_Time

				case ffjtMarketStatusState:
					goto handle_State

				case ffjtMarketStatusDescription:
					goto handle_Description

				case ffjtMarketStatusNextChange:
					goto handle_NextChange

				case ffjtMarketStatusNextState:
					goto handle_NextState

				case ffjtMarketStatusnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Time:

	/* handler: j.Time type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Time.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: j.State type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.State = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NextChange:

	/* handler: j.NextChange type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.NextChange.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NextState:

	/* handler: j.NextState type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NextState = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Quote) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Quote) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"Description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"exch":`)
	fflib.WriteJsonString(buf, string(j.Exchange))
	buf.WriteString(`,"Type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"Change":`)
	fflib.AppendFloat(buf, float64(j.Change), 'g', -1, 64)
	buf.WriteString(`,"change_percentage":`)
	fflib.AppendFloat(buf, float64(j.ChangePercentage), 'g', -1, 64)
	buf.WriteString(`,"Volume":`)
	fflib.FormatBits2(buf, uint64(j.Volume), 10, j.Volume < 0)
	buf.WriteString(`,"AverageVolume":`)
	fflib.FormatBits2(buf, uint64(j.AverageVolume), 10, j.AverageVolume < 0)
	buf.WriteString(`,"Last":`)
	fflib.AppendFloat(buf, float64(j.Last), 'g', -1, 64)
	buf.WriteString(`,"LastVolume":`)
	fflib.FormatBits2(buf, uint64(j.LastVolume), 10, j.LastVolume < 0)
	buf.WriteString(`,"trade_date":`)

	{

		obj, err = j.TradeDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Open":`)
	fflib.AppendFloat(buf, float64(j.Open), 'g', -1, 64)
	buf.WriteString(`,"High":`)
	fflib.AppendFloat(buf, float64(j.High), 'g', -1, 64)
	buf.WriteString(`,"Low":`)
	fflib.AppendFloat(buf, float64(j.Low), 'g', -1, 64)
	buf.WriteString(`,"Close":`)
	fflib.AppendFloat(buf, float64(j.Close), 'g', -1, 64)
	buf.WriteString(`,"prevclose":`)
	fflib.AppendFloat(buf, float64(j.PreviousClose), 'g', -1, 64)
	buf.WriteString(`,"week_52_high":`)
	fflib.AppendFloat(buf, float64(j.Week52High), 'g', -1, 64)
	buf.WriteString(`,"week_52_low":`)
	fflib.AppendFloat(buf, float64(j.Week52Low), 'g', -1, 64)
	buf.WriteString(`,"Bid":`)
	fflib.AppendFloat(buf, float64(j.Bid), 'g', -1, 64)
	buf.WriteString(`,"BidSize":`)
	fflib.FormatBits2(buf, uint64(j.BidSize), 10, j.BidSize < 0)
	buf.WriteString(`,"bidexch":`)
	fflib.WriteJsonString(buf, string(j.BidExchange))
	buf.WriteString(`,"bid_date":`)

	{

		obj, err = j.BidDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Ask":`)
	fflib.AppendFloat(buf, float64(j.Ask), 'g', -1, 64)
	buf.WriteString(`,"AskSize":`)
	fflib.FormatBits2(buf, uint64(j.AskSize), 10, j.AskSize < 0)
	buf.WriteString(`,"askexch":`)
	fflib.WriteJsonString(buf, string(j.AskExchange))
	buf.WriteString(`,"ask_date":`)

	{

		obj, err = j.AskDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"open_interest":`)
	fflib.AppendFloat(buf, float64(j.OpenInterest), 'g', -1, 64)
	buf.WriteString(`,"Underlying":`)
	fflib.WriteJsonString(buf, string(j.Underlying))
	buf.WriteString(`,"Strike":`)
	fflib.AppendFloat(buf, float64(j.Strike), 'g', -1, 64)
	buf.WriteString(`,"ContractSize":`)
	fflib.FormatBits2(buf, uint64(j.ContractSize), 10, j.ContractSize < 0)
	buf.WriteString(`,"expiration_date":`)

	{

		obj, err = j.ExpirationDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"expiration_type":`)
	fflib.WriteJsonString(buf, string(j.ExpirationType))
	buf.WriteString(`,"option_type":`)
	fflib.WriteJsonString(buf, string(j.OptionType))
	buf.WriteString(`,"root_symbol":`)
	fflib.WriteJsonString(buf, string(j.RootSymbol))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtQuotebase = iota
	ffjtQuotenosuchkey

	ffjtQuoteSymbol

	ffjtQuoteDescription

	ffjtQuoteExchange

	ffjtQuoteType

	ffjtQuoteChange

	ffjtQuoteChangePercentage

	ffjtQuoteVolume

	ffjtQuoteAverageVolume

	ffjtQuoteLast

	ffjtQuoteLastVolume

	ffjtQuoteTradeDate

	ffjtQuoteOpen

	ffjtQuoteHigh

	ffjtQuoteLow

	ffjtQuoteClose

	ffjtQuotePreviousClose

	ffjtQuoteWeek52High

	ffjtQuoteWeek52Low

	ffjtQuoteBid

	ffjtQuoteBidSize

	ffjtQuoteBidExchange

	ffjtQuoteBidDate

	ffjtQuoteAsk

	ffjtQuoteAskSize

	ffjtQuoteAskExchange

	ffjtQuoteAskDate

	ffjtQuoteOpenInterest

	ffjtQuoteUnderlying

	ffjtQuoteStrike

	ffjtQuoteContractSize

	ffjtQuoteExpirationDate

	ffjtQuoteExpirationType

	ffjtQuoteOptionType

	ffjtQuoteRootSymbol
)

var ffjKeyQuoteSymbol = []byte("Symbol")

var ffjKeyQuoteDescription = []byte("Description")

var ffjKeyQuoteExchange = []byte("exch")

var ffjKeyQuoteType = []byte("Type")

var ffjKeyQuoteChange = []byte("Change")

var ffjKeyQuoteChangePercentage = []byte("change_percentage")

var ffjKeyQuoteVolume = []byte("Volume")

var ffjKeyQuoteAverageVolume = []byte("AverageVolume")

var ffjKeyQuoteLast = []byte("Last")

var ffjKeyQuoteLastVolume = []byte("LastVolume")

var ffjKeyQuoteTradeDate = []byte("trade_date")

var ffjKeyQuoteOpen = []byte("Open")

var ffjKeyQuoteHigh = []byte("High")

var ffjKeyQuoteLow = []byte("Low")

var ffjKeyQuoteClose = []byte("Close")

var ffjKeyQuotePreviousClose = []byte("prevclose")

var ffjKeyQuoteWeek52High = []byte("week_52_high")

var ffjKeyQuoteWeek52Low = []byte("week_52_low")

var ffjKeyQuoteBid = []byte("Bid")

var ffjKeyQuoteBidSize = []byte("BidSize")

var ffjKeyQuoteBidExchange = []byte("bidexch")

var ffjKeyQuoteBidDate = []byte("bid_date")

var ffjKeyQuoteAsk = []byte("Ask")

var ffjKeyQuoteAskSize = []byte("AskSize")

var ffjKeyQuoteAskExchange = []byte("askexch")

var ffjKeyQuoteAskDate = []byte("ask_date")

var ffjKeyQuoteOpenInterest = []byte("open_interest")

var ffjKeyQuoteUnderlying = []byte("Underlying")

var ffjKeyQuoteStrike = []byte("Strike")

var ffjKeyQuoteContractSize = []byte("ContractSize")

var ffjKeyQuoteExpirationDate = []byte("expiration_date")

var ffjKeyQuoteExpirationType = []byte("expiration_type")

var ffjKeyQuoteOptionType = []byte("option_type")

var ffjKeyQuoteRootSymbol = []byte("root_symbol")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Quote) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Quote) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtQuotebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtQuotenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeyQuoteAverageVolume, kn) {
						currentKey = ffjtQuoteAverageVolume
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteAsk, kn) {
						currentKey = ffjtQuoteAsk
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteAskSize, kn) {
						currentKey = ffjtQuoteAskSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'B':

					if bytes.Equal(ffjKeyQuoteBid, kn) {
						currentKey = ffjtQuoteBid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteBidSize, kn) {
						currentKey = ffjtQuoteBidSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffjKeyQuoteChange, kn) {
						currentKey = ffjtQuoteChange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteClose, kn) {
						currentKey = ffjtQuoteClose
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteContractSize, kn) {
						currentKey = ffjtQuoteContractSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyQuoteDescription, kn) {
						currentKey = ffjtQuoteDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'H':

					if bytes.Equal(ffjKeyQuoteHigh, kn) {
						currentKey = ffjtQuoteHigh
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeyQuoteLast, kn) {
						currentKey = ffjtQuoteLast
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteLastVolume, kn) {
						currentKey = ffjtQuoteLastVolume
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteLow, kn) {
						currentKey = ffjtQuoteLow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffjKeyQuoteOpen, kn) {
						currentKey = ffjtQuoteOpen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyQuoteSymbol, kn) {
						currentKey = ffjtQuoteSymbol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteStrike, kn) {
						currentKey = ffjtQuoteStrike
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyQuoteType, kn) {
						currentKey = ffjtQuoteType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffjKeyQuoteUnderlying, kn) {
						currentKey = ffjtQuoteUnderlying
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'V':

					if bytes.Equal(ffjKeyQuoteVolume, kn) {
						currentKey = ffjtQuoteVolume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffjKeyQuoteAskExchange, kn) {
						currentKey = ffjtQuoteAskExchange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteAskDate, kn) {
						currentKey = ffjtQuoteAskDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyQuoteBidExchange, kn) {
						currentKey = ffjtQuoteBidExchange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteBidDate, kn) {
						currentKey = ffjtQuoteBidDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyQuoteChangePercentage, kn) {
						currentKey = ffjtQuoteChangePercentage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyQuoteExchange, kn) {
						currentKey = ffjtQuoteExchange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteExpirationDate, kn) {
						currentKey = ffjtQuoteExpirationDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteExpirationType, kn) {
						currentKey = ffjtQuoteExpirationType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyQuoteOpenInterest, kn) {
						currentKey = ffjtQuoteOpenInterest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteOptionType, kn) {
						currentKey = ffjtQuoteOptionType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyQuotePreviousClose, kn) {
						currentKey = ffjtQuotePreviousClose
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyQuoteRootSymbol, kn) {
						currentKey = ffjtQuoteRootSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyQuoteTradeDate, kn) {
						currentKey = ffjtQuoteTradeDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyQuoteWeek52High, kn) {
						currentKey = ffjtQuoteWeek52High
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteWeek52Low, kn) {
						currentKey = ffjtQuoteWeek52Low
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyQuoteRootSymbol, kn) {
					currentKey = ffjtQuoteRootSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyQuoteOptionType, kn) {
					currentKey = ffjtQuoteOptionType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyQuoteExpirationType, kn) {
					currentKey = ffjtQuoteExpirationType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyQuoteExpirationDate, kn) {
					currentKey = ffjtQuoteExpirationDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteContractSize, kn) {
					currentKey = ffjtQuoteContractSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteStrike, kn) {
					currentKey = ffjtQuoteStrike
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteUnderlying, kn) {
					currentKey = ffjtQuoteUnderlying
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteOpenInterest, kn) {
					currentKey = ffjtQuoteOpenInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteAskDate, kn) {
					currentKey = ffjtQuoteAskDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteAskExchange, kn) {
					currentKey = ffjtQuoteAskExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteAskSize, kn) {
					currentKey = ffjtQuoteAskSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteAsk, kn) {
					currentKey = ffjtQuoteAsk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyQuoteBidDate, kn) {
					currentKey = ffjtQuoteBidDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteBidExchange, kn) {
					currentKey = ffjtQuoteBidExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteBidSize, kn) {
					currentKey = ffjtQuoteBidSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteBid, kn) {
					currentKey = ffjtQuoteBid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteWeek52Low, kn) {
					currentKey = ffjtQuoteWeek52Low
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteWeek52High, kn) {
					currentKey = ffjtQuoteWeek52High
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuotePreviousClose, kn) {
					currentKey = ffjtQuotePreviousClose
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteClose, kn) {
					currentKey = ffjtQuoteClose
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteLow, kn) {
					currentKey = ffjtQuoteLow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteHigh, kn) {
					currentKey = ffjtQuoteHigh
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteOpen, kn) {
					currentKey = ffjtQuoteOpen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyQuoteTradeDate, kn) {
					currentKey = ffjtQuoteTradeDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteLastVolume, kn) {
					currentKey = ffjtQuoteLastVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteLast, kn) {
					currentKey = ffjtQuoteLast
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteAverageVolume, kn) {
					currentKey = ffjtQuoteAverageVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteVolume, kn) {
					currentKey = ffjtQuoteVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyQuoteChangePercentage, kn) {
					currentKey = ffjtQuoteChangePercentage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteChange, kn) {
					currentKey = ffjtQuoteChange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteType, kn) {
					currentKey = ffjtQuoteType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteExchange, kn) {
					currentKey = ffjtQuoteExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteDescription, kn) {
					currentKey = ffjtQuoteDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteSymbol, kn) {
					currentKey = ffjtQuoteSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtQuotenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtQuoteSymbol:
					goto handle_Symbol

				case ffjtQuoteDescription:
					goto handle_Description

				case ffjtQuoteExchange:
					goto handle_Exchange

				case ffjtQuoteType:
					goto handle_Type

				case ffjtQuoteChange:
					goto handle_Change

				case ffjtQuoteChangePercentage:
					goto handle_ChangePercentage

				case ffjtQuoteVolume:
					goto handle_Volume

				case ffjtQuoteAverageVolume:
					goto handle_AverageVolume

				case ffjtQuoteLast:
					goto handle_Last

				case ffjtQuoteLastVolume:
					goto handle_LastVolume

				case ffjtQuoteTradeDate:
					goto handle_TradeDate

				case ffjtQuoteOpen:
					goto handle_Open

				case ffjtQuoteHigh:
					goto handle_High

				case ffjtQuoteLow:
					goto handle_Low

				case ffjtQuoteClose:
					goto handle_Close

				case ffjtQuotePreviousClose:
					goto handle_PreviousClose

				case ffjtQuoteWeek52High:
					goto handle_Week52High

				case ffjtQuoteWeek52Low:
					goto handle_Week52Low

				case ffjtQuoteBid:
					goto handle_Bid

				case ffjtQuoteBidSize:
					goto handle_BidSize

				case ffjtQuoteBidExchange:
					goto handle_BidExchange

				case ffjtQuoteBidDate:
					goto handle_BidDate

				case ffjtQuoteAsk:
					goto handle_Ask

				case ffjtQuoteAskSize:
					goto handle_AskSize

				case ffjtQuoteAskExchange:
					goto handle_AskExchange

				case ffjtQuoteAskDate:
					goto handle_AskDate

				case ffjtQuoteOpenInterest:
					goto handle_OpenInterest

				case ffjtQuoteUnderlying:
					goto handle_Underlying

				case ffjtQuoteStrike:
					goto handle_Strike

				case ffjtQuoteContractSize:
					goto handle_ContractSize

				case ffjtQuoteExpirationDate:
					goto handle_ExpirationDate

				case ffjtQuoteExpirationType:
					goto handle_ExpirationType

				case ffjtQuoteOptionType:
					goto handle_OptionType

				case ffjtQuoteRootSymbol:
					goto handle_RootSymbol

				case ffjtQuotenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exchange:

	/* handler: j.Exchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Exchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Change:

	/* handler: j.Change type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Change = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangePercentage:

	/* handler: j.ChangePercentage type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChangePercentage = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Volume:

	/* handler: j.Volume type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Volume = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AverageVolume:

	/* handler: j.AverageVolume type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AverageVolume = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Last:

	/* handler: j.Last type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Last = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastVolume:

	/* handler: j.LastVolume type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LastVolume = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TradeDate:

	/* handler: j.TradeDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.TradeDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Open:

	/* handler: j.Open type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Open = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_High:

	/* handler: j.High type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.High = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Low:

	/* handler: j.Low type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Low = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Close:

	/* handler: j.Close type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Close = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreviousClose:

	/* handler: j.PreviousClose type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PreviousClose = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Week52High:

	/* handler: j.Week52High type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Week52High = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Week52Low:

	/* handler: j.Week52Low type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Week52Low = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bid:

	/* handler: j.Bid type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Bid = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidSize:

	/* handler: j.BidSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.BidSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidExchange:

	/* handler: j.BidExchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BidExchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidDate:

	/* handler: j.BidDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BidDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ask:

	/* handler: j.Ask type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Ask = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AskSize:

	/* handler: j.AskSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AskSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AskExchange:

	/* handler: j.AskExchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AskExchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AskDate:

	/* handler: j.AskDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AskDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OpenInterest:

	/* handler: j.OpenInterest type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OpenInterest = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Underlying:

	/* handler: j.Underlying type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Underlying = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Strike:

	/* handler: j.Strike type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Strike = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContractSize:

	/* handler: j.ContractSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ContractSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpirationDate:

	/* handler: j.ExpirationDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ExpirationDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpirationType:

	/* handler: j.ExpirationType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ExpirationType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionType:

	/* handler: j.OptionType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.OptionType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RootSymbol:

	/* handler: j.RootSymbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RootSymbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *QuoteEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *QuoteEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"Bid":`)
	fflib.AppendFloat(buf, float64(j.Bid), 'g', -1, 64)
	buf.WriteString(`,"bidsz":`)
	fflib.FormatBits2(buf, uint64(j.BidSize), 10, j.BidSize < 0)
	buf.WriteString(`,"bidexch":`)
	fflib.WriteJsonString(buf, string(j.BidExchange))
	buf.WriteString(`,"biddate":"`)
	fflib.FormatBits2(buf, uint64(j.BidDateMs), 10, j.BidDateMs < 0)
	buf.WriteString(`","Ask":`)
	fflib.AppendFloat(buf, float64(j.Ask), 'g', -1, 64)
	buf.WriteString(`,"asksz":`)
	fflib.FormatBits2(buf, uint64(j.AskSize), 10, j.AskSize < 0)
	buf.WriteString(`,"askexch":`)
	fflib.WriteJsonString(buf, string(j.AskExchange))
	buf.WriteString(`,"askdate":"`)
	fflib.FormatBits2(buf, uint64(j.AskDateMs), 10, j.AskDateMs < 0)
	buf.WriteString(`"}`)
	return nil
}

const (
	ffjtQuoteEventbase = iota
	ffjtQuoteEventnosuchkey

	ffjtQuoteEventSymbol

	ffjtQuoteEventBid

	ffjtQuoteEventBidSize

	ffjtQuoteEventBidExchange

	ffjtQuoteEventBidDateMs

	ffjtQuoteEventAsk

	ffjtQuoteEventAskSize

	ffjtQuoteEventAskExchange

	ffjtQuoteEventAskDateMs
)

var ffjKeyQuoteEventSymbol = []byte("Symbol")

var ffjKeyQuoteEventBid = []byte("Bid")

var ffjKeyQuoteEventBidSize = []byte("bidsz")

var ffjKeyQuoteEventBidExchange = []byte("bidexch")

var ffjKeyQuoteEventBidDateMs = []byte("biddate")

var ffjKeyQuoteEventAsk = []byte("Ask")

var ffjKeyQuoteEventAskSize = []byte("asksz")

var ffjKeyQuoteEventAskExchange = []byte("askexch")

var ffjKeyQuoteEventAskDateMs = []byte("askdate")

// UnmarshalJSON umarshall json - template of ffjson
func (j *QuoteEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *QuoteEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtQuoteEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtQuoteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeyQuoteEventAsk, kn) {
						currentKey = ffjtQuoteEventAsk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'B':

					if bytes.Equal(ffjKeyQuoteEventBid, kn) {
						currentKey = ffjtQuoteEventBid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyQuoteEventSymbol, kn) {
						currentKey = ffjtQuoteEventSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffjKeyQuoteEventAskSize, kn) {
						currentKey = ffjtQuoteEventAskSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteEventAskExchange, kn) {
						currentKey = ffjtQuoteEventAskExchange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteEventAskDateMs, kn) {
						currentKey = ffjtQuoteEventAskDateMs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyQuoteEventBidSize, kn) {
						currentKey = ffjtQuoteEventBidSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteEventBidExchange, kn) {
						currentKey = ffjtQuoteEventBidExchange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyQuoteEventBidDateMs, kn) {
						currentKey = ffjtQuoteEventBidDateMs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyQuoteEventAskDateMs, kn) {
					currentKey = ffjtQuoteEventAskDateMs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteEventAskExchange, kn) {
					currentKey = ffjtQuoteEventAskExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteEventAskSize, kn) {
					currentKey = ffjtQuoteEventAskSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteEventAsk, kn) {
					currentKey = ffjtQuoteEventAsk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteEventBidDateMs, kn) {
					currentKey = ffjtQuoteEventBidDateMs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteEventBidExchange, kn) {
					currentKey = ffjtQuoteEventBidExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteEventBidSize, kn) {
					currentKey = ffjtQuoteEventBidSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyQuoteEventBid, kn) {
					currentKey = ffjtQuoteEventBid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyQuoteEventSymbol, kn) {
					currentKey = ffjtQuoteEventSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtQuoteEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtQuoteEventSymbol:
					goto handle_Symbol

				case ffjtQuoteEventBid:
					goto handle_Bid

				case ffjtQuoteEventBidSize:
					goto handle_BidSize

				case ffjtQuoteEventBidExchange:
					goto handle_BidExchange

				case ffjtQuoteEventBidDateMs:
					goto handle_BidDateMs

				case ffjtQuoteEventAsk:
					goto handle_Ask

				case ffjtQuoteEventAskSize:
					goto handle_AskSize

				case ffjtQuoteEventAskExchange:
					goto handle_AskExchange

				case ffjtQuoteEventAskDateMs:
					goto handle_AskDateMs

				case ffjtQuoteEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bid:

	/* handler: j.Bid type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Bid = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidSize:

	/* handler: j.BidSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.BidSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidExchange:

	/* handler: j.BidExchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BidExchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidDateMs:

	/* handler: j.BidDateMs type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.BidDateMs = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ask:

	/* handler: j.Ask type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Ask = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AskSize:

	/* handler: j.AskSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AskSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AskExchange:

	/* handler: j.AskExchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AskExchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AskDateMs:

	/* handler: j.AskDateMs type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AskDateMs = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Security) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Security) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"Exchange":`)
	fflib.WriteJsonString(buf, string(j.Exchange))
	buf.WriteString(`,"Type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"Description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSecuritybase = iota
	ffjtSecuritynosuchkey

	ffjtSecuritySymbol

	ffjtSecurityExchange

	ffjtSecurityType

	ffjtSecurityDescription
)

var ffjKeySecuritySymbol = []byte("Symbol")

var ffjKeySecurityExchange = []byte("Exchange")

var ffjKeySecurityType = []byte("Type")

var ffjKeySecurityDescription = []byte("Description")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Security) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Security) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSecuritybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSecuritynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffjKeySecurityDescription, kn) {
						currentKey = ffjtSecurityDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffjKeySecurityExchange, kn) {
						currentKey = ffjtSecurityExchange
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeySecuritySymbol, kn) {
						currentKey = ffjtSecuritySymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeySecurityType, kn) {
						currentKey = ffjtSecurityType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySecurityDescription, kn) {
					currentKey = ffjtSecurityDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySecurityType, kn) {
					currentKey = ffjtSecurityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySecurityExchange, kn) {
					currentKey = ffjtSecurityExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySecuritySymbol, kn) {
					currentKey = ffjtSecuritySymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSecuritynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSecuritySymbol:
					goto handle_Symbol

				case ffjtSecurityExchange:
					goto handle_Exchange

				case ffjtSecurityType:
					goto handle_Type

				case ffjtSecurityDescription:
					goto handle_Description

				case ffjtSecuritynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exchange:

	/* handler: j.Exchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Exchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *StreamEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *StreamEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"Message":`)

	{

		obj, err = j.Message.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtStreamEventbase = iota
	ffjtStreamEventnosuchkey

	ffjtStreamEventType

	ffjtStreamEventSymbol

	ffjtStreamEventMessage
)

var ffjKeyStreamEventType = []byte("Type")

var ffjKeyStreamEventSymbol = []byte("Symbol")

var ffjKeyStreamEventMessage = []byte("Message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *StreamEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *StreamEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtStreamEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtStreamEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffjKeyStreamEventMessage, kn) {
						currentKey = ffjtStreamEventMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyStreamEventSymbol, kn) {
						currentKey = ffjtStreamEventSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyStreamEventType, kn) {
						currentKey = ffjtStreamEventType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyStreamEventMessage, kn) {
					currentKey = ffjtStreamEventMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStreamEventSymbol, kn) {
					currentKey = ffjtStreamEventSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStreamEventType, kn) {
					currentKey = ffjtStreamEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtStreamEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtStreamEventType:
					goto handle_Type

				case ffjtStreamEventSymbol:
					goto handle_Symbol

				case ffjtStreamEventMessage:
					goto handle_Message

				case ffjtStreamEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=json.RawMessage kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Message.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SummaryEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SummaryEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"Open":"`)
	fflib.AppendFloat(buf, float64(j.Open), 'g', -1, 64)
	buf.WriteString(`","High":"`)
	fflib.AppendFloat(buf, float64(j.High), 'g', -1, 64)
	buf.WriteString(`","Low":"`)
	fflib.AppendFloat(buf, float64(j.Low), 'g', -1, 64)
	buf.WriteString(`","PreviousClose":`)
	fflib.AppendFloat(buf, float64(j.PreviousClose), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSummaryEventbase = iota
	ffjtSummaryEventnosuchkey

	ffjtSummaryEventSymbol

	ffjtSummaryEventOpen

	ffjtSummaryEventHigh

	ffjtSummaryEventLow

	ffjtSummaryEventPreviousClose
)

var ffjKeySummaryEventSymbol = []byte("Symbol")

var ffjKeySummaryEventOpen = []byte("Open")

var ffjKeySummaryEventHigh = []byte("High")

var ffjKeySummaryEventLow = []byte("Low")

var ffjKeySummaryEventPreviousClose = []byte("PreviousClose")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SummaryEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SummaryEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSummaryEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSummaryEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'H':

					if bytes.Equal(ffjKeySummaryEventHigh, kn) {
						currentKey = ffjtSummaryEventHigh
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeySummaryEventLow, kn) {
						currentKey = ffjtSummaryEventLow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffjKeySummaryEventOpen, kn) {
						currentKey = ffjtSummaryEventOpen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeySummaryEventPreviousClose, kn) {
						currentKey = ffjtSummaryEventPreviousClose
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeySummaryEventSymbol, kn) {
						currentKey = ffjtSummaryEventSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySummaryEventPreviousClose, kn) {
					currentKey = ffjtSummaryEventPreviousClose
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySummaryEventLow, kn) {
					currentKey = ffjtSummaryEventLow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySummaryEventHigh, kn) {
					currentKey = ffjtSummaryEventHigh
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySummaryEventOpen, kn) {
					currentKey = ffjtSummaryEventOpen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySummaryEventSymbol, kn) {
					currentKey = ffjtSummaryEventSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSummaryEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSummaryEventSymbol:
					goto handle_Symbol

				case ffjtSummaryEventOpen:
					goto handle_Open

				case ffjtSummaryEventHigh:
					goto handle_High

				case ffjtSummaryEventLow:
					goto handle_Low

				case ffjtSummaryEventPreviousClose:
					goto handle_PreviousClose

				case ffjtSummaryEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Open:

	/* handler: j.Open type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Open = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_High:

	/* handler: j.High type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.High = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Low:

	/* handler: j.Low type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Low = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreviousClose:

	/* handler: j.PreviousClose type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PreviousClose = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *TimeSale) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *TimeSale) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Date":`)

	{

		obj, err = j.Date.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Time":`)

	{

		obj, err = j.Time.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Timestamp":`)
	fflib.FormatBits2(buf, uint64(j.Timestamp), 10, j.Timestamp < 0)
	buf.WriteString(`,"Open":`)
	fflib.AppendFloat(buf, float64(j.Open), 'g', -1, 64)
	buf.WriteString(`,"Close":`)
	fflib.AppendFloat(buf, float64(j.Close), 'g', -1, 64)
	buf.WriteString(`,"High":`)
	fflib.AppendFloat(buf, float64(j.High), 'g', -1, 64)
	buf.WriteString(`,"Low":`)
	fflib.AppendFloat(buf, float64(j.Low), 'g', -1, 64)
	buf.WriteString(`,"Price":`)
	fflib.AppendFloat(buf, float64(j.Price), 'g', -1, 64)
	buf.WriteString(`,"Vwap":`)
	fflib.AppendFloat(buf, float64(j.Vwap), 'g', -1, 64)
	buf.WriteString(`,"Volume":`)
	fflib.FormatBits2(buf, uint64(j.Volume), 10, j.Volume < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtTimeSalebase = iota
	ffjtTimeSalenosuchkey

	ffjtTimeSaleDate

	ffjtTimeSaleTime

	ffjtTimeSaleTimestamp

	ffjtTimeSaleOpen

	ffjtTimeSaleClose

	ffjtTimeSaleHigh

	ffjtTimeSaleLow

	ffjtTimeSalePrice

	ffjtTimeSaleVwap

	ffjtTimeSaleVolume
)

var ffjKeyTimeSaleDate = []byte("Date")

var ffjKeyTimeSaleTime = []byte("Time")

var ffjKeyTimeSaleTimestamp = []byte("Timestamp")

var ffjKeyTimeSaleOpen = []byte("Open")

var ffjKeyTimeSaleClose = []byte("Close")

var ffjKeyTimeSaleHigh = []byte("High")

var ffjKeyTimeSaleLow = []byte("Low")

var ffjKeyTimeSalePrice = []byte("Price")

var ffjKeyTimeSaleVwap = []byte("Vwap")

var ffjKeyTimeSaleVolume = []byte("Volume")

// UnmarshalJSON umarshall json - template of ffjson
func (j *TimeSale) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *TimeSale) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTimeSalebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTimeSalenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyTimeSaleClose, kn) {
						currentKey = ffjtTimeSaleClose
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyTimeSaleDate, kn) {
						currentKey = ffjtTimeSaleDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'H':

					if bytes.Equal(ffjKeyTimeSaleHigh, kn) {
						currentKey = ffjtTimeSaleHigh
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeyTimeSaleLow, kn) {
						currentKey = ffjtTimeSaleLow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffjKeyTimeSaleOpen, kn) {
						currentKey = ffjtTimeSaleOpen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyTimeSalePrice, kn) {
						currentKey = ffjtTimeSalePrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyTimeSaleTime, kn) {
						currentKey = ffjtTimeSaleTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyTimeSaleTimestamp, kn) {
						currentKey = ffjtTimeSaleTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'V':

					if bytes.Equal(ffjKeyTimeSaleVwap, kn) {
						currentKey = ffjtTimeSaleVwap
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyTimeSaleVolume, kn) {
						currentKey = ffjtTimeSaleVolume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleVolume, kn) {
					currentKey = ffjtTimeSaleVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleVwap, kn) {
					currentKey = ffjtTimeSaleVwap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSalePrice, kn) {
					currentKey = ffjtTimeSalePrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleLow, kn) {
					currentKey = ffjtTimeSaleLow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleHigh, kn) {
					currentKey = ffjtTimeSaleHigh
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTimeSaleClose, kn) {
					currentKey = ffjtTimeSaleClose
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleOpen, kn) {
					currentKey = ffjtTimeSaleOpen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTimeSaleTimestamp, kn) {
					currentKey = ffjtTimeSaleTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleTime, kn) {
					currentKey = ffjtTimeSaleTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleDate, kn) {
					currentKey = ffjtTimeSaleDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTimeSalenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTimeSaleDate:
					goto handle_Date

				case ffjtTimeSaleTime:
					goto handle_Time

				case ffjtTimeSaleTimestamp:
					goto handle_Timestamp

				case ffjtTimeSaleOpen:
					goto handle_Open

				case ffjtTimeSaleClose:
					goto handle_Close

				case ffjtTimeSaleHigh:
					goto handle_High

				case ffjtTimeSaleLow:
					goto handle_Low

				case ffjtTimeSalePrice:
					goto handle_Price

				case ffjtTimeSaleVwap:
					goto handle_Vwap

				case ffjtTimeSaleVolume:
					goto handle_Volume

				case ffjtTimeSalenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Date:

	/* handler: j.Date type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Date.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Time:

	/* handler: j.Time type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Time.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Timestamp = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Open:

	/* handler: j.Open type=tradier.FloatOrNaN kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Open.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Close:

	/* handler: j.Close type=tradier.FloatOrNaN kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Close.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_High:

	/* handler: j.High type=tradier.FloatOrNaN kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.High.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Low:

	/* handler: j.Low type=tradier.FloatOrNaN kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Low.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Price:

	/* handler: j.Price type=tradier.FloatOrNaN kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Price.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Vwap:

	/* handler: j.Vwap type=tradier.FloatOrNaN kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Vwap.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Volume:

	/* handler: j.Volume type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Volume = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *TimeSaleEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *TimeSaleEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"exch":`)
	fflib.WriteJsonString(buf, string(j.Exchange))
	buf.WriteString(`,"Bid":"`)
	fflib.AppendFloat(buf, float64(j.Bid), 'g', -1, 64)
	buf.WriteString(`","Ask":"`)
	fflib.AppendFloat(buf, float64(j.Ask), 'g', -1, 64)
	buf.WriteString(`","Last":"`)
	fflib.AppendFloat(buf, float64(j.Last), 'g', -1, 64)
	buf.WriteString(`","Size":"`)
	fflib.FormatBits2(buf, uint64(j.Size), 10, j.Size < 0)
	buf.WriteString(`","date":"`)
	fflib.FormatBits2(buf, uint64(j.DateMs), 10, j.DateMs < 0)
	buf.WriteString(`"}`)
	return nil
}

const (
	ffjtTimeSaleEventbase = iota
	ffjtTimeSaleEventnosuchkey

	ffjtTimeSaleEventSymbol

	ffjtTimeSaleEventExchange

	ffjtTimeSaleEventBid

	ffjtTimeSaleEventAsk

	ffjtTimeSaleEventLast

	ffjtTimeSaleEventSize

	ffjtTimeSaleEventDateMs
)

var ffjKeyTimeSaleEventSymbol = []byte("Symbol")

var ffjKeyTimeSaleEventExchange = []byte("exch")

var ffjKeyTimeSaleEventBid = []byte("Bid")

var ffjKeyTimeSaleEventAsk = []byte("Ask")

var ffjKeyTimeSaleEventLast = []byte("Last")

var ffjKeyTimeSaleEventSize = []byte("Size")

var ffjKeyTimeSaleEventDateMs = []byte("date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *TimeSaleEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *TimeSaleEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTimeSaleEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTimeSaleEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeyTimeSaleEventAsk, kn) {
						currentKey = ffjtTimeSaleEventAsk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'B':

					if bytes.Equal(ffjKeyTimeSaleEventBid, kn) {
						currentKey = ffjtTimeSaleEventBid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeyTimeSaleEventLast, kn) {
						currentKey = ffjtTimeSaleEventLast
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyTimeSaleEventSymbol, kn) {
						currentKey = ffjtTimeSaleEventSymbol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyTimeSaleEventSize, kn) {
						currentKey = ffjtTimeSaleEventSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyTimeSaleEventDateMs, kn) {
						currentKey = ffjtTimeSaleEventDateMs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyTimeSaleEventExchange, kn) {
						currentKey = ffjtTimeSaleEventExchange
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleEventDateMs, kn) {
					currentKey = ffjtTimeSaleEventDateMs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTimeSaleEventSize, kn) {
					currentKey = ffjtTimeSaleEventSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTimeSaleEventLast, kn) {
					currentKey = ffjtTimeSaleEventLast
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTimeSaleEventAsk, kn) {
					currentKey = ffjtTimeSaleEventAsk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleEventBid, kn) {
					currentKey = ffjtTimeSaleEventBid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTimeSaleEventExchange, kn) {
					currentKey = ffjtTimeSaleEventExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTimeSaleEventSymbol, kn) {
					currentKey = ffjtTimeSaleEventSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTimeSaleEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTimeSaleEventSymbol:
					goto handle_Symbol

				case ffjtTimeSaleEventExchange:
					goto handle_Exchange

				case ffjtTimeSaleEventBid:
					goto handle_Bid

				case ffjtTimeSaleEventAsk:
					goto handle_Ask

				case ffjtTimeSaleEventLast:
					goto handle_Last

				case ffjtTimeSaleEventSize:
					goto handle_Size

				case ffjtTimeSaleEventDateMs:
					goto handle_DateMs

				case ffjtTimeSaleEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exchange:

	/* handler: j.Exchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Exchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bid:

	/* handler: j.Bid type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Bid = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ask:

	/* handler: j.Ask type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Ask = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Last:

	/* handler: j.Last type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Last = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Size:

	/* handler: j.Size type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Size = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DateMs:

	/* handler: j.DateMs type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.DateMs = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *TradeEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *TradeEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"exch":`)
	fflib.WriteJsonString(buf, string(j.Exchange))
	buf.WriteString(`,"Price":"`)
	fflib.AppendFloat(buf, float64(j.Price), 'g', -1, 64)
	buf.WriteString(`","Last":"`)
	fflib.AppendFloat(buf, float64(j.Last), 'g', -1, 64)
	buf.WriteString(`","Size":"`)
	fflib.FormatBits2(buf, uint64(j.Size), 10, j.Size < 0)
	buf.WriteString(`","cvol":"`)
	fflib.FormatBits2(buf, uint64(j.CumulativeVolume), 10, j.CumulativeVolume < 0)
	buf.WriteString(`","date":"`)
	fflib.FormatBits2(buf, uint64(j.DateMs), 10, j.DateMs < 0)
	buf.WriteString(`"}`)
	return nil
}

const (
	ffjtTradeEventbase = iota
	ffjtTradeEventnosuchkey

	ffjtTradeEventSymbol

	ffjtTradeEventExchange

	ffjtTradeEventPrice

	ffjtTradeEventLast

	ffjtTradeEventSize

	ffjtTradeEventCumulativeVolume

	ffjtTradeEventDateMs
)

var ffjKeyTradeEventSymbol = []byte("Symbol")

var ffjKeyTradeEventExchange = []byte("exch")

var ffjKeyTradeEventPrice = []byte("Price")

var ffjKeyTradeEventLast = []byte("Last")

var ffjKeyTradeEventSize = []byte("Size")

var ffjKeyTradeEventCumulativeVolume = []byte("cvol")

var ffjKeyTradeEventDateMs = []byte("date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *TradeEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *TradeEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTradeEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTradeEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'L':

					if bytes.Equal(ffjKeyTradeEventLast, kn) {
						currentKey = ffjtTradeEventLast
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyTradeEventPrice, kn) {
						currentKey = ffjtTradeEventPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyTradeEventSymbol, kn) {
						currentKey = ffjtTradeEventSymbol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyTradeEventSize, kn) {
						currentKey = ffjtTradeEventSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyTradeEventCumulativeVolume, kn) {
						currentKey = ffjtTradeEventCumulativeVolume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyTradeEventDateMs, kn) {
						currentKey = ffjtTradeEventDateMs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyTradeEventExchange, kn) {
						currentKey = ffjtTradeEventExchange
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyTradeEventDateMs, kn) {
					currentKey = ffjtTradeEventDateMs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTradeEventCumulativeVolume, kn) {
					currentKey = ffjtTradeEventCumulativeVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTradeEventSize, kn) {
					currentKey = ffjtTradeEventSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTradeEventLast, kn) {
					currentKey = ffjtTradeEventLast
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTradeEventPrice, kn) {
					currentKey = ffjtTradeEventPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTradeEventExchange, kn) {
					currentKey = ffjtTradeEventExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTradeEventSymbol, kn) {
					currentKey = ffjtTradeEventSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTradeEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTradeEventSymbol:
					goto handle_Symbol

				case ffjtTradeEventExchange:
					goto handle_Exchange

				case ffjtTradeEventPrice:
					goto handle_Price

				case ffjtTradeEventLast:
					goto handle_Last

				case ffjtTradeEventSize:
					goto handle_Size

				case ffjtTradeEventCumulativeVolume:
					goto handle_CumulativeVolume

				case ffjtTradeEventDateMs:
					goto handle_DateMs

				case ffjtTradeEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exchange:

	/* handler: j.Exchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Exchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Price:

	/* handler: j.Price type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Price = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Last:

	/* handler: j.Last type=float64 kind=float64 quoted=true*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Last = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Size:

	/* handler: j.Size type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Size = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CumulativeVolume:

	/* handler: j.CumulativeVolume type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CumulativeVolume = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DateMs:

	/* handler: j.DateMs type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.DateMs = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
