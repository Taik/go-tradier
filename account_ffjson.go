// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: ./account.go

package tradier

import (
	"bytes"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *AccountBalances) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccountBalances) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"account_number":`)
	fflib.WriteJsonString(buf, string(j.AccountNumber))
	buf.WriteString(`,"account_type":`)
	fflib.WriteJsonString(buf, string(j.AccountType))
	buf.WriteString(`,"close_pl":`)
	fflib.AppendFloat(buf, float64(j.ClosePL), 'g', -1, 64)
	buf.WriteString(`,"current_requirement":`)
	fflib.AppendFloat(buf, float64(j.CurrentRequirement), 'g', -1, 64)
	buf.WriteString(`,"Equity":`)
	fflib.AppendFloat(buf, float64(j.Equity), 'g', -1, 64)
	buf.WriteString(`,"long_market_value":`)
	fflib.AppendFloat(buf, float64(j.LongMarketValue), 'g', -1, 64)
	buf.WriteString(`,"market_value":`)
	fflib.AppendFloat(buf, float64(j.MarketValue), 'g', -1, 64)
	buf.WriteString(`,"open_pl":`)
	fflib.AppendFloat(buf, float64(j.OpenPL), 'g', -1, 64)
	buf.WriteString(`,"option_long_value":`)
	fflib.AppendFloat(buf, float64(j.OptionLongValue), 'g', -1, 64)
	buf.WriteString(`,"option_requirement":`)
	fflib.AppendFloat(buf, float64(j.OptionRequirement), 'g', -1, 64)
	buf.WriteString(`,"option_short_value":`)
	fflib.AppendFloat(buf, float64(j.OptionShortValue), 'g', -1, 64)
	buf.WriteString(`,"pending_orders_count":`)
	fflib.FormatBits2(buf, uint64(j.PendingOrdersCount), 10, j.PendingOrdersCount < 0)
	buf.WriteString(`,"short_market_value":`)
	fflib.AppendFloat(buf, float64(j.ShortMarketValue), 'g', -1, 64)
	buf.WriteString(`,"stock_long_value":`)
	fflib.AppendFloat(buf, float64(j.StockLongValue), 'g', -1, 64)
	buf.WriteString(`,"total_cash":`)
	fflib.AppendFloat(buf, float64(j.TotalCash), 'g', -1, 64)
	buf.WriteString(`,"total_equity":`)
	fflib.AppendFloat(buf, float64(j.TotalEquity), 'g', -1, 64)
	buf.WriteString(`,"uncleared_funds":`)
	fflib.AppendFloat(buf, float64(j.UnclearedFunds), 'g', -1, 64)
	buf.WriteString(`,"Margin":`)

	{

		err = j.Margin.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"Cash":`)

	{

		err = j.Cash.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"PDT":`)

	{

		err = j.PDT.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccountBalancesbase = iota
	ffjtAccountBalancesnosuchkey

	ffjtAccountBalancesAccountNumber

	ffjtAccountBalancesAccountType

	ffjtAccountBalancesClosePL

	ffjtAccountBalancesCurrentRequirement

	ffjtAccountBalancesEquity

	ffjtAccountBalancesLongMarketValue

	ffjtAccountBalancesMarketValue

	ffjtAccountBalancesOpenPL

	ffjtAccountBalancesOptionLongValue

	ffjtAccountBalancesOptionRequirement

	ffjtAccountBalancesOptionShortValue

	ffjtAccountBalancesPendingOrdersCount

	ffjtAccountBalancesShortMarketValue

	ffjtAccountBalancesStockLongValue

	ffjtAccountBalancesTotalCash

	ffjtAccountBalancesTotalEquity

	ffjtAccountBalancesUnclearedFunds

	ffjtAccountBalancesMargin

	ffjtAccountBalancesCash

	ffjtAccountBalancesPDT
)

var ffjKeyAccountBalancesAccountNumber = []byte("account_number")

var ffjKeyAccountBalancesAccountType = []byte("account_type")

var ffjKeyAccountBalancesClosePL = []byte("close_pl")

var ffjKeyAccountBalancesCurrentRequirement = []byte("current_requirement")

var ffjKeyAccountBalancesEquity = []byte("Equity")

var ffjKeyAccountBalancesLongMarketValue = []byte("long_market_value")

var ffjKeyAccountBalancesMarketValue = []byte("market_value")

var ffjKeyAccountBalancesOpenPL = []byte("open_pl")

var ffjKeyAccountBalancesOptionLongValue = []byte("option_long_value")

var ffjKeyAccountBalancesOptionRequirement = []byte("option_requirement")

var ffjKeyAccountBalancesOptionShortValue = []byte("option_short_value")

var ffjKeyAccountBalancesPendingOrdersCount = []byte("pending_orders_count")

var ffjKeyAccountBalancesShortMarketValue = []byte("short_market_value")

var ffjKeyAccountBalancesStockLongValue = []byte("stock_long_value")

var ffjKeyAccountBalancesTotalCash = []byte("total_cash")

var ffjKeyAccountBalancesTotalEquity = []byte("total_equity")

var ffjKeyAccountBalancesUnclearedFunds = []byte("uncleared_funds")

var ffjKeyAccountBalancesMargin = []byte("Margin")

var ffjKeyAccountBalancesCash = []byte("Cash")

var ffjKeyAccountBalancesPDT = []byte("PDT")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccountBalances) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccountBalances) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccountBalancesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccountBalancesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyAccountBalancesCash, kn) {
						currentKey = ffjtAccountBalancesCash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffjKeyAccountBalancesEquity, kn) {
						currentKey = ffjtAccountBalancesEquity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffjKeyAccountBalancesMargin, kn) {
						currentKey = ffjtAccountBalancesMargin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyAccountBalancesPDT, kn) {
						currentKey = ffjtAccountBalancesPDT
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffjKeyAccountBalancesAccountNumber, kn) {
						currentKey = ffjtAccountBalancesAccountNumber
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesAccountType, kn) {
						currentKey = ffjtAccountBalancesAccountType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyAccountBalancesClosePL, kn) {
						currentKey = ffjtAccountBalancesClosePL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesCurrentRequirement, kn) {
						currentKey = ffjtAccountBalancesCurrentRequirement
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyAccountBalancesLongMarketValue, kn) {
						currentKey = ffjtAccountBalancesLongMarketValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccountBalancesMarketValue, kn) {
						currentKey = ffjtAccountBalancesMarketValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyAccountBalancesOpenPL, kn) {
						currentKey = ffjtAccountBalancesOpenPL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesOptionLongValue, kn) {
						currentKey = ffjtAccountBalancesOptionLongValue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesOptionRequirement, kn) {
						currentKey = ffjtAccountBalancesOptionRequirement
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesOptionShortValue, kn) {
						currentKey = ffjtAccountBalancesOptionShortValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAccountBalancesPendingOrdersCount, kn) {
						currentKey = ffjtAccountBalancesPendingOrdersCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyAccountBalancesShortMarketValue, kn) {
						currentKey = ffjtAccountBalancesShortMarketValue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesStockLongValue, kn) {
						currentKey = ffjtAccountBalancesStockLongValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAccountBalancesTotalCash, kn) {
						currentKey = ffjtAccountBalancesTotalCash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccountBalancesTotalEquity, kn) {
						currentKey = ffjtAccountBalancesTotalEquity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyAccountBalancesUnclearedFunds, kn) {
						currentKey = ffjtAccountBalancesUnclearedFunds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccountBalancesPDT, kn) {
					currentKey = ffjtAccountBalancesPDT
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesCash, kn) {
					currentKey = ffjtAccountBalancesCash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccountBalancesMargin, kn) {
					currentKey = ffjtAccountBalancesMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesUnclearedFunds, kn) {
					currentKey = ffjtAccountBalancesUnclearedFunds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesTotalEquity, kn) {
					currentKey = ffjtAccountBalancesTotalEquity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesTotalCash, kn) {
					currentKey = ffjtAccountBalancesTotalCash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesStockLongValue, kn) {
					currentKey = ffjtAccountBalancesStockLongValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesShortMarketValue, kn) {
					currentKey = ffjtAccountBalancesShortMarketValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesPendingOrdersCount, kn) {
					currentKey = ffjtAccountBalancesPendingOrdersCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesOptionShortValue, kn) {
					currentKey = ffjtAccountBalancesOptionShortValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesOptionRequirement, kn) {
					currentKey = ffjtAccountBalancesOptionRequirement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesOptionLongValue, kn) {
					currentKey = ffjtAccountBalancesOptionLongValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesOpenPL, kn) {
					currentKey = ffjtAccountBalancesOpenPL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesMarketValue, kn) {
					currentKey = ffjtAccountBalancesMarketValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesLongMarketValue, kn) {
					currentKey = ffjtAccountBalancesLongMarketValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccountBalancesEquity, kn) {
					currentKey = ffjtAccountBalancesEquity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesCurrentRequirement, kn) {
					currentKey = ffjtAccountBalancesCurrentRequirement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccountBalancesClosePL, kn) {
					currentKey = ffjtAccountBalancesClosePL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesAccountType, kn) {
					currentKey = ffjtAccountBalancesAccountType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAccountBalancesAccountNumber, kn) {
					currentKey = ffjtAccountBalancesAccountNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccountBalancesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccountBalancesAccountNumber:
					goto handle_AccountNumber

				case ffjtAccountBalancesAccountType:
					goto handle_AccountType

				case ffjtAccountBalancesClosePL:
					goto handle_ClosePL

				case ffjtAccountBalancesCurrentRequirement:
					goto handle_CurrentRequirement

				case ffjtAccountBalancesEquity:
					goto handle_Equity

				case ffjtAccountBalancesLongMarketValue:
					goto handle_LongMarketValue

				case ffjtAccountBalancesMarketValue:
					goto handle_MarketValue

				case ffjtAccountBalancesOpenPL:
					goto handle_OpenPL

				case ffjtAccountBalancesOptionLongValue:
					goto handle_OptionLongValue

				case ffjtAccountBalancesOptionRequirement:
					goto handle_OptionRequirement

				case ffjtAccountBalancesOptionShortValue:
					goto handle_OptionShortValue

				case ffjtAccountBalancesPendingOrdersCount:
					goto handle_PendingOrdersCount

				case ffjtAccountBalancesShortMarketValue:
					goto handle_ShortMarketValue

				case ffjtAccountBalancesStockLongValue:
					goto handle_StockLongValue

				case ffjtAccountBalancesTotalCash:
					goto handle_TotalCash

				case ffjtAccountBalancesTotalEquity:
					goto handle_TotalEquity

				case ffjtAccountBalancesUnclearedFunds:
					goto handle_UnclearedFunds

				case ffjtAccountBalancesMargin:
					goto handle_Margin

				case ffjtAccountBalancesCash:
					goto handle_Cash

				case ffjtAccountBalancesPDT:
					goto handle_PDT

				case ffjtAccountBalancesnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccountNumber:

	/* handler: j.AccountNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AccountNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccountType:

	/* handler: j.AccountType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AccountType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClosePL:

	/* handler: j.ClosePL type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ClosePL = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentRequirement:

	/* handler: j.CurrentRequirement type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CurrentRequirement = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Equity:

	/* handler: j.Equity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Equity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LongMarketValue:

	/* handler: j.LongMarketValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LongMarketValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketValue:

	/* handler: j.MarketValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MarketValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OpenPL:

	/* handler: j.OpenPL type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OpenPL = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionLongValue:

	/* handler: j.OptionLongValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OptionLongValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionRequirement:

	/* handler: j.OptionRequirement type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OptionRequirement = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionShortValue:

	/* handler: j.OptionShortValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OptionShortValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PendingOrdersCount:

	/* handler: j.PendingOrdersCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PendingOrdersCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortMarketValue:

	/* handler: j.ShortMarketValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ShortMarketValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockLongValue:

	/* handler: j.StockLongValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StockLongValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalCash:

	/* handler: j.TotalCash type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalCash = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalEquity:

	/* handler: j.TotalEquity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalEquity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnclearedFunds:

	/* handler: j.UnclearedFunds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UnclearedFunds = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Margin:

	/* handler: j.Margin type=tradier.Margin kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Margin.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cash:

	/* handler: j.Cash type=tradier.Cash kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Cash.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PDT:

	/* handler: j.PDT type=tradier.PDT kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.PDT.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Adjustment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Adjustment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"Quantity":`)
	fflib.AppendFloat(buf, float64(j.Quantity), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAdjustmentbase = iota
	ffjtAdjustmentnosuchkey

	ffjtAdjustmentDescription

	ffjtAdjustmentQuantity
)

var ffjKeyAdjustmentDescription = []byte("Description")

var ffjKeyAdjustmentQuantity = []byte("Quantity")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Adjustment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Adjustment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAdjustmentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAdjustmentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffjKeyAdjustmentDescription, kn) {
						currentKey = ffjtAdjustmentDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyAdjustmentQuantity, kn) {
						currentKey = ffjtAdjustmentQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAdjustmentQuantity, kn) {
					currentKey = ffjtAdjustmentQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAdjustmentDescription, kn) {
					currentKey = ffjtAdjustmentDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAdjustmentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAdjustmentDescription:
					goto handle_Description

				case ffjtAdjustmentQuantity:
					goto handle_Quantity

				case ffjtAdjustmentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: j.Quantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Quantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Cash) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Cash) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cash_available":`)
	fflib.AppendFloat(buf, float64(j.CashAvailable), 'g', -1, 64)
	buf.WriteString(`,"Sweep":`)
	fflib.FormatBits2(buf, uint64(j.Sweep), 10, j.Sweep < 0)
	buf.WriteString(`,"unsettled_funds":`)
	fflib.AppendFloat(buf, float64(j.UnsettledFunds), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCashbase = iota
	ffjtCashnosuchkey

	ffjtCashCashAvailable

	ffjtCashSweep

	ffjtCashUnsettledFunds
)

var ffjKeyCashCashAvailable = []byte("cash_available")

var ffjKeyCashSweep = []byte("Sweep")

var ffjKeyCashUnsettledFunds = []byte("unsettled_funds")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Cash) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Cash) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCashbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCashnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'S':

					if bytes.Equal(ffjKeyCashSweep, kn) {
						currentKey = ffjtCashSweep
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyCashCashAvailable, kn) {
						currentKey = ffjtCashCashAvailable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyCashUnsettledFunds, kn) {
						currentKey = ffjtCashUnsettledFunds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyCashUnsettledFunds, kn) {
					currentKey = ffjtCashUnsettledFunds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashSweep, kn) {
					currentKey = ffjtCashSweep
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashCashAvailable, kn) {
					currentKey = ffjtCashCashAvailable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCashnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCashCashAvailable:
					goto handle_CashAvailable

				case ffjtCashSweep:
					goto handle_Sweep

				case ffjtCashUnsettledFunds:
					goto handle_UnsettledFunds

				case ffjtCashnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CashAvailable:

	/* handler: j.CashAvailable type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CashAvailable = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sweep:

	/* handler: j.Sweep type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Sweep = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnsettledFunds:

	/* handler: j.UnsettledFunds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UnsettledFunds = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ClosedPosition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ClosedPosition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"close_date":`)

	{

		obj, err = j.CloseDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Cost":`)
	fflib.AppendFloat(buf, float64(j.Cost), 'g', -1, 64)
	buf.WriteString(`,"gain_loss":`)
	fflib.AppendFloat(buf, float64(j.GainLoss), 'g', -1, 64)
	buf.WriteString(`,"gain_loss_percent":`)
	fflib.AppendFloat(buf, float64(j.GainLossPercent), 'g', -1, 64)
	buf.WriteString(`,"open_date":`)

	{

		obj, err = j.OpenDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Proceeds":`)
	fflib.AppendFloat(buf, float64(j.Proceeds), 'g', -1, 64)
	buf.WriteString(`,"Quantity":`)
	fflib.AppendFloat(buf, float64(j.Quantity), 'g', -1, 64)
	buf.WriteString(`,"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"Term":`)
	fflib.FormatBits2(buf, uint64(j.Term), 10, j.Term < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtClosedPositionbase = iota
	ffjtClosedPositionnosuchkey

	ffjtClosedPositionCloseDate

	ffjtClosedPositionCost

	ffjtClosedPositionGainLoss

	ffjtClosedPositionGainLossPercent

	ffjtClosedPositionOpenDate

	ffjtClosedPositionProceeds

	ffjtClosedPositionQuantity

	ffjtClosedPositionSymbol

	ffjtClosedPositionTerm
)

var ffjKeyClosedPositionCloseDate = []byte("close_date")

var ffjKeyClosedPositionCost = []byte("Cost")

var ffjKeyClosedPositionGainLoss = []byte("gain_loss")

var ffjKeyClosedPositionGainLossPercent = []byte("gain_loss_percent")

var ffjKeyClosedPositionOpenDate = []byte("open_date")

var ffjKeyClosedPositionProceeds = []byte("Proceeds")

var ffjKeyClosedPositionQuantity = []byte("Quantity")

var ffjKeyClosedPositionSymbol = []byte("Symbol")

var ffjKeyClosedPositionTerm = []byte("Term")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ClosedPosition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ClosedPosition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtClosedPositionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtClosedPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyClosedPositionCost, kn) {
						currentKey = ffjtClosedPositionCost
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyClosedPositionProceeds, kn) {
						currentKey = ffjtClosedPositionProceeds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyClosedPositionQuantity, kn) {
						currentKey = ffjtClosedPositionQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyClosedPositionSymbol, kn) {
						currentKey = ffjtClosedPositionSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyClosedPositionTerm, kn) {
						currentKey = ffjtClosedPositionTerm
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyClosedPositionCloseDate, kn) {
						currentKey = ffjtClosedPositionCloseDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyClosedPositionGainLoss, kn) {
						currentKey = ffjtClosedPositionGainLoss
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyClosedPositionGainLossPercent, kn) {
						currentKey = ffjtClosedPositionGainLossPercent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyClosedPositionOpenDate, kn) {
						currentKey = ffjtClosedPositionOpenDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyClosedPositionTerm, kn) {
					currentKey = ffjtClosedPositionTerm
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClosedPositionSymbol, kn) {
					currentKey = ffjtClosedPositionSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyClosedPositionQuantity, kn) {
					currentKey = ffjtClosedPositionQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClosedPositionProceeds, kn) {
					currentKey = ffjtClosedPositionProceeds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyClosedPositionOpenDate, kn) {
					currentKey = ffjtClosedPositionOpenDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClosedPositionGainLossPercent, kn) {
					currentKey = ffjtClosedPositionGainLossPercent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClosedPositionGainLoss, kn) {
					currentKey = ffjtClosedPositionGainLoss
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClosedPositionCost, kn) {
					currentKey = ffjtClosedPositionCost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyClosedPositionCloseDate, kn) {
					currentKey = ffjtClosedPositionCloseDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtClosedPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtClosedPositionCloseDate:
					goto handle_CloseDate

				case ffjtClosedPositionCost:
					goto handle_Cost

				case ffjtClosedPositionGainLoss:
					goto handle_GainLoss

				case ffjtClosedPositionGainLossPercent:
					goto handle_GainLossPercent

				case ffjtClosedPositionOpenDate:
					goto handle_OpenDate

				case ffjtClosedPositionProceeds:
					goto handle_Proceeds

				case ffjtClosedPositionQuantity:
					goto handle_Quantity

				case ffjtClosedPositionSymbol:
					goto handle_Symbol

				case ffjtClosedPositionTerm:
					goto handle_Term

				case ffjtClosedPositionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CloseDate:

	/* handler: j.CloseDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CloseDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cost:

	/* handler: j.Cost type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Cost = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GainLoss:

	/* handler: j.GainLoss type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.GainLoss = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GainLossPercent:

	/* handler: j.GainLossPercent type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.GainLossPercent = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OpenDate:

	/* handler: j.OpenDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.OpenDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Proceeds:

	/* handler: j.Proceeds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Proceeds = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: j.Quantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Quantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Term:

	/* handler: j.Term type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Term = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Event) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Event) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Amount":`)
	fflib.AppendFloat(buf, float64(j.Amount), 'g', -1, 64)
	buf.WriteString(`,"Date":`)

	{

		obj, err = j.Date.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"Trade":`)

	{

		err = j.Trade.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"Adjustment":`)

	{

		err = j.Adjustment.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEventbase = iota
	ffjtEventnosuchkey

	ffjtEventAmount

	ffjtEventDate

	ffjtEventType

	ffjtEventTrade

	ffjtEventAdjustment
)

var ffjKeyEventAmount = []byte("Amount")

var ffjKeyEventDate = []byte("Date")

var ffjKeyEventType = []byte("Type")

var ffjKeyEventTrade = []byte("Trade")

var ffjKeyEventAdjustment = []byte("Adjustment")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Event) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Event) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeyEventAmount, kn) {
						currentKey = ffjtEventAmount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventAdjustment, kn) {
						currentKey = ffjtEventAdjustment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyEventDate, kn) {
						currentKey = ffjtEventDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyEventType, kn) {
						currentKey = ffjtEventType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventTrade, kn) {
						currentKey = ffjtEventTrade
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEventAdjustment, kn) {
					currentKey = ffjtEventAdjustment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventTrade, kn) {
					currentKey = ffjtEventTrade
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventType, kn) {
					currentKey = ffjtEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventDate, kn) {
					currentKey = ffjtEventDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventAmount, kn) {
					currentKey = ffjtEventAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEventAmount:
					goto handle_Amount

				case ffjtEventDate:
					goto handle_Date

				case ffjtEventType:
					goto handle_Type

				case ffjtEventTrade:
					goto handle_Trade

				case ffjtEventAdjustment:
					goto handle_Adjustment

				case ffjtEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Amount:

	/* handler: j.Amount type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Amount = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: j.Date type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Date.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Trade:

	/* handler: j.Trade type=tradier.Trade kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Trade.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Adjustment:

	/* handler: j.Adjustment type=tradier.Adjustment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Adjustment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Margin) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Margin) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"fed_call":`)
	fflib.FormatBits2(buf, uint64(j.FedCall), 10, j.FedCall < 0)
	buf.WriteString(`,"maintenance_call":`)
	fflib.FormatBits2(buf, uint64(j.MaintenanceCall), 10, j.MaintenanceCall < 0)
	buf.WriteString(`,"option_buying_power":`)
	fflib.AppendFloat(buf, float64(j.OptionBuyingPower), 'g', -1, 64)
	buf.WriteString(`,"stock_buying_power":`)
	fflib.AppendFloat(buf, float64(j.StockBuyingPower), 'g', -1, 64)
	buf.WriteString(`,"stock_short_value":`)
	fflib.AppendFloat(buf, float64(j.StockShortValue), 'g', -1, 64)
	buf.WriteString(`,"Sweep":`)
	fflib.FormatBits2(buf, uint64(j.Sweep), 10, j.Sweep < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMarginbase = iota
	ffjtMarginnosuchkey

	ffjtMarginFedCall

	ffjtMarginMaintenanceCall

	ffjtMarginOptionBuyingPower

	ffjtMarginStockBuyingPower

	ffjtMarginStockShortValue

	ffjtMarginSweep
)

var ffjKeyMarginFedCall = []byte("fed_call")

var ffjKeyMarginMaintenanceCall = []byte("maintenance_call")

var ffjKeyMarginOptionBuyingPower = []byte("option_buying_power")

var ffjKeyMarginStockBuyingPower = []byte("stock_buying_power")

var ffjKeyMarginStockShortValue = []byte("stock_short_value")

var ffjKeyMarginSweep = []byte("Sweep")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Margin) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Margin) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMarginbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMarginnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'S':

					if bytes.Equal(ffjKeyMarginSweep, kn) {
						currentKey = ffjtMarginSweep
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMarginFedCall, kn) {
						currentKey = ffjtMarginFedCall
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMarginMaintenanceCall, kn) {
						currentKey = ffjtMarginMaintenanceCall
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyMarginOptionBuyingPower, kn) {
						currentKey = ffjtMarginOptionBuyingPower
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMarginStockBuyingPower, kn) {
						currentKey = ffjtMarginStockBuyingPower
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMarginStockShortValue, kn) {
						currentKey = ffjtMarginStockShortValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMarginSweep, kn) {
					currentKey = ffjtMarginSweep
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarginStockShortValue, kn) {
					currentKey = ffjtMarginStockShortValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMarginStockBuyingPower, kn) {
					currentKey = ffjtMarginStockBuyingPower
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMarginOptionBuyingPower, kn) {
					currentKey = ffjtMarginOptionBuyingPower
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMarginMaintenanceCall, kn) {
					currentKey = ffjtMarginMaintenanceCall
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMarginFedCall, kn) {
					currentKey = ffjtMarginFedCall
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMarginnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMarginFedCall:
					goto handle_FedCall

				case ffjtMarginMaintenanceCall:
					goto handle_MaintenanceCall

				case ffjtMarginOptionBuyingPower:
					goto handle_OptionBuyingPower

				case ffjtMarginStockBuyingPower:
					goto handle_StockBuyingPower

				case ffjtMarginStockShortValue:
					goto handle_StockShortValue

				case ffjtMarginSweep:
					goto handle_Sweep

				case ffjtMarginnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FedCall:

	/* handler: j.FedCall type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FedCall = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaintenanceCall:

	/* handler: j.MaintenanceCall type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaintenanceCall = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionBuyingPower:

	/* handler: j.OptionBuyingPower type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OptionBuyingPower = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockBuyingPower:

	/* handler: j.StockBuyingPower type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StockBuyingPower = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockShortValue:

	/* handler: j.StockShortValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StockShortValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sweep:

	/* handler: j.Sweep type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Sweep = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Order) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Order) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Id":`)
	fflib.FormatBits2(buf, uint64(j.Id), 10, j.Id < 0)
	buf.WriteString(`,"Type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"option_symbol":`)
	fflib.WriteJsonString(buf, string(j.OptionSymbol))
	buf.WriteString(`,"Side":`)
	fflib.WriteJsonString(buf, string(j.Side))
	buf.WriteString(`,"Quantity":`)
	fflib.AppendFloat(buf, float64(j.Quantity), 'g', -1, 64)
	buf.WriteString(`,"Status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteString(`,"Duration":`)
	fflib.WriteJsonString(buf, string(j.Duration))
	buf.WriteString(`,"Price":`)
	fflib.AppendFloat(buf, float64(j.Price), 'g', -1, 64)
	buf.WriteString(`,"stop_price":`)
	fflib.AppendFloat(buf, float64(j.StopPrice), 'g', -1, 64)
	buf.WriteString(`,"option_type":`)
	fflib.WriteJsonString(buf, string(j.OptionType))
	buf.WriteString(`,"expiration_date":`)

	{

		obj, err = j.ExpirationDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"exch":`)
	fflib.WriteJsonString(buf, string(j.Exchange))
	buf.WriteString(`,"avg_fill_price":`)
	fflib.AppendFloat(buf, float64(j.AverageFillPrice), 'g', -1, 64)
	buf.WriteString(`,"exec_quantity":`)
	fflib.AppendFloat(buf, float64(j.ExecutedQuantity), 'g', -1, 64)
	buf.WriteString(`,"exec_exch":`)
	fflib.WriteJsonString(buf, string(j.ExecutionExchange))
	buf.WriteString(`,"last_fill_price":`)
	fflib.AppendFloat(buf, float64(j.LastFillPrice), 'g', -1, 64)
	buf.WriteString(`,"last_fill_quantity":`)
	fflib.AppendFloat(buf, float64(j.LastFillQuantity), 'g', -1, 64)
	buf.WriteString(`,"remaining_quantity":`)
	fflib.AppendFloat(buf, float64(j.RemainingQuantity), 'g', -1, 64)
	buf.WriteString(`,"create_date":`)

	{

		obj, err = j.CreateDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"transaction_date":`)

	{

		obj, err = j.TransactionDate.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Class":`)
	fflib.WriteJsonString(buf, string(j.Class))
	buf.WriteString(`,"num_legs":`)
	fflib.FormatBits2(buf, uint64(j.NumLegs), 10, j.NumLegs < 0)
	buf.WriteString(`,"Legs":`)
	if j.Legs != nil {
		buf.WriteString(`[`)
		for i, v := range j.Legs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Strategy":`)
	fflib.WriteJsonString(buf, string(j.Strategy))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOrderbase = iota
	ffjtOrdernosuchkey

	ffjtOrderId

	ffjtOrderType

	ffjtOrderSymbol

	ffjtOrderOptionSymbol

	ffjtOrderSide

	ffjtOrderQuantity

	ffjtOrderStatus

	ffjtOrderDuration

	ffjtOrderPrice

	ffjtOrderStopPrice

	ffjtOrderOptionType

	ffjtOrderExpirationDate

	ffjtOrderExchange

	ffjtOrderAverageFillPrice

	ffjtOrderExecutedQuantity

	ffjtOrderExecutionExchange

	ffjtOrderLastFillPrice

	ffjtOrderLastFillQuantity

	ffjtOrderRemainingQuantity

	ffjtOrderCreateDate

	ffjtOrderTransactionDate

	ffjtOrderClass

	ffjtOrderNumLegs

	ffjtOrderLegs

	ffjtOrderStrategy
)

var ffjKeyOrderId = []byte("Id")

var ffjKeyOrderType = []byte("Type")

var ffjKeyOrderSymbol = []byte("Symbol")

var ffjKeyOrderOptionSymbol = []byte("option_symbol")

var ffjKeyOrderSide = []byte("Side")

var ffjKeyOrderQuantity = []byte("Quantity")

var ffjKeyOrderStatus = []byte("Status")

var ffjKeyOrderDuration = []byte("Duration")

var ffjKeyOrderPrice = []byte("Price")

var ffjKeyOrderStopPrice = []byte("stop_price")

var ffjKeyOrderOptionType = []byte("option_type")

var ffjKeyOrderExpirationDate = []byte("expiration_date")

var ffjKeyOrderExchange = []byte("exch")

var ffjKeyOrderAverageFillPrice = []byte("avg_fill_price")

var ffjKeyOrderExecutedQuantity = []byte("exec_quantity")

var ffjKeyOrderExecutionExchange = []byte("exec_exch")

var ffjKeyOrderLastFillPrice = []byte("last_fill_price")

var ffjKeyOrderLastFillQuantity = []byte("last_fill_quantity")

var ffjKeyOrderRemainingQuantity = []byte("remaining_quantity")

var ffjKeyOrderCreateDate = []byte("create_date")

var ffjKeyOrderTransactionDate = []byte("transaction_date")

var ffjKeyOrderClass = []byte("Class")

var ffjKeyOrderNumLegs = []byte("num_legs")

var ffjKeyOrderLegs = []byte("Legs")

var ffjKeyOrderStrategy = []byte("Strategy")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Order) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Order) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOrderbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOrdernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyOrderClass, kn) {
						currentKey = ffjtOrderClass
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyOrderDuration, kn) {
						currentKey = ffjtOrderDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffjKeyOrderId, kn) {
						currentKey = ffjtOrderId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeyOrderLegs, kn) {
						currentKey = ffjtOrderLegs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyOrderPrice, kn) {
						currentKey = ffjtOrderPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyOrderQuantity, kn) {
						currentKey = ffjtOrderQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyOrderSymbol, kn) {
						currentKey = ffjtOrderSymbol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderSide, kn) {
						currentKey = ffjtOrderSide
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderStatus, kn) {
						currentKey = ffjtOrderStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderStrategy, kn) {
						currentKey = ffjtOrderStrategy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyOrderType, kn) {
						currentKey = ffjtOrderType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffjKeyOrderAverageFillPrice, kn) {
						currentKey = ffjtOrderAverageFillPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyOrderCreateDate, kn) {
						currentKey = ffjtOrderCreateDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyOrderExpirationDate, kn) {
						currentKey = ffjtOrderExpirationDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderExchange, kn) {
						currentKey = ffjtOrderExchange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderExecutedQuantity, kn) {
						currentKey = ffjtOrderExecutedQuantity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderExecutionExchange, kn) {
						currentKey = ffjtOrderExecutionExchange
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyOrderLastFillPrice, kn) {
						currentKey = ffjtOrderLastFillPrice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderLastFillQuantity, kn) {
						currentKey = ffjtOrderLastFillQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyOrderNumLegs, kn) {
						currentKey = ffjtOrderNumLegs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyOrderOptionSymbol, kn) {
						currentKey = ffjtOrderOptionSymbol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderOptionType, kn) {
						currentKey = ffjtOrderOptionType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyOrderRemainingQuantity, kn) {
						currentKey = ffjtOrderRemainingQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOrderStopPrice, kn) {
						currentKey = ffjtOrderStopPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyOrderTransactionDate, kn) {
						currentKey = ffjtOrderTransactionDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOrderStrategy, kn) {
					currentKey = ffjtOrderStrategy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderLegs, kn) {
					currentKey = ffjtOrderLegs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderNumLegs, kn) {
					currentKey = ffjtOrderNumLegs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderClass, kn) {
					currentKey = ffjtOrderClass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderTransactionDate, kn) {
					currentKey = ffjtOrderTransactionDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderCreateDate, kn) {
					currentKey = ffjtOrderCreateDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderRemainingQuantity, kn) {
					currentKey = ffjtOrderRemainingQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderLastFillQuantity, kn) {
					currentKey = ffjtOrderLastFillQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderLastFillPrice, kn) {
					currentKey = ffjtOrderLastFillPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderExecutionExchange, kn) {
					currentKey = ffjtOrderExecutionExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderExecutedQuantity, kn) {
					currentKey = ffjtOrderExecutedQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderAverageFillPrice, kn) {
					currentKey = ffjtOrderAverageFillPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderExchange, kn) {
					currentKey = ffjtOrderExchange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderExpirationDate, kn) {
					currentKey = ffjtOrderExpirationDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderOptionType, kn) {
					currentKey = ffjtOrderOptionType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderStopPrice, kn) {
					currentKey = ffjtOrderStopPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderPrice, kn) {
					currentKey = ffjtOrderPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderDuration, kn) {
					currentKey = ffjtOrderDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderStatus, kn) {
					currentKey = ffjtOrderStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderQuantity, kn) {
					currentKey = ffjtOrderQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderSide, kn) {
					currentKey = ffjtOrderSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderOptionSymbol, kn) {
					currentKey = ffjtOrderOptionSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderSymbol, kn) {
					currentKey = ffjtOrderSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderType, kn) {
					currentKey = ffjtOrderType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderId, kn) {
					currentKey = ffjtOrderId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOrdernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOrderId:
					goto handle_Id

				case ffjtOrderType:
					goto handle_Type

				case ffjtOrderSymbol:
					goto handle_Symbol

				case ffjtOrderOptionSymbol:
					goto handle_OptionSymbol

				case ffjtOrderSide:
					goto handle_Side

				case ffjtOrderQuantity:
					goto handle_Quantity

				case ffjtOrderStatus:
					goto handle_Status

				case ffjtOrderDuration:
					goto handle_Duration

				case ffjtOrderPrice:
					goto handle_Price

				case ffjtOrderStopPrice:
					goto handle_StopPrice

				case ffjtOrderOptionType:
					goto handle_OptionType

				case ffjtOrderExpirationDate:
					goto handle_ExpirationDate

				case ffjtOrderExchange:
					goto handle_Exchange

				case ffjtOrderAverageFillPrice:
					goto handle_AverageFillPrice

				case ffjtOrderExecutedQuantity:
					goto handle_ExecutedQuantity

				case ffjtOrderExecutionExchange:
					goto handle_ExecutionExchange

				case ffjtOrderLastFillPrice:
					goto handle_LastFillPrice

				case ffjtOrderLastFillQuantity:
					goto handle_LastFillQuantity

				case ffjtOrderRemainingQuantity:
					goto handle_RemainingQuantity

				case ffjtOrderCreateDate:
					goto handle_CreateDate

				case ffjtOrderTransactionDate:
					goto handle_TransactionDate

				case ffjtOrderClass:
					goto handle_Class

				case ffjtOrderNumLegs:
					goto handle_NumLegs

				case ffjtOrderLegs:
					goto handle_Legs

				case ffjtOrderStrategy:
					goto handle_Strategy

				case ffjtOrdernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: j.Id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionSymbol:

	/* handler: j.OptionSymbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.OptionSymbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Side:

	/* handler: j.Side type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Side = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: j.Quantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Quantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Duration = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Price:

	/* handler: j.Price type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Price = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StopPrice:

	/* handler: j.StopPrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StopPrice = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionType:

	/* handler: j.OptionType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.OptionType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpirationDate:

	/* handler: j.ExpirationDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ExpirationDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exchange:

	/* handler: j.Exchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Exchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AverageFillPrice:

	/* handler: j.AverageFillPrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AverageFillPrice = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutedQuantity:

	/* handler: j.ExecutedQuantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExecutedQuantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutionExchange:

	/* handler: j.ExecutionExchange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ExecutionExchange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastFillPrice:

	/* handler: j.LastFillPrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LastFillPrice = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastFillQuantity:

	/* handler: j.LastFillQuantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LastFillQuantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemainingQuantity:

	/* handler: j.RemainingQuantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RemainingQuantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreateDate:

	/* handler: j.CreateDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreateDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TransactionDate:

	/* handler: j.TransactionDate type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.TransactionDate.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Class:

	/* handler: j.Class type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Class = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumLegs:

	/* handler: j.NumLegs type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NumLegs = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Legs:

	/* handler: j.Legs type=[]tradier.Order kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Legs = nil
		} else {

			j.Legs = []Order{}

			wantVal := true

			for {

				var tmpJLegs Order

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJLegs type=tradier.Order kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJLegs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Legs = append(j.Legs, tmpJLegs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Strategy:

	/* handler: j.Strategy type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Strategy = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OrderPreview) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OrderPreview) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Commission":`)
	fflib.AppendFloat(buf, float64(j.Commission), 'g', -1, 64)
	buf.WriteString(`,"Cost":`)
	fflib.AppendFloat(buf, float64(j.Cost), 'g', -1, 64)
	if j.ExtendedHours {
		buf.WriteString(`,"extended_hours":true`)
	} else {
		buf.WriteString(`,"extended_hours":false`)
	}
	buf.WriteString(`,"Fees":`)
	fflib.AppendFloat(buf, float64(j.Fees), 'g', -1, 64)
	buf.WriteString(`,"margin_change":`)
	fflib.AppendFloat(buf, float64(j.MarginChange), 'g', -1, 64)
	buf.WriteString(`,"Quantity":`)
	fflib.AppendFloat(buf, float64(j.Quantity), 'g', -1, 64)
	buf.WriteString(`,"Status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOrderPreviewbase = iota
	ffjtOrderPreviewnosuchkey

	ffjtOrderPreviewCommission

	ffjtOrderPreviewCost

	ffjtOrderPreviewExtendedHours

	ffjtOrderPreviewFees

	ffjtOrderPreviewMarginChange

	ffjtOrderPreviewQuantity

	ffjtOrderPreviewStatus
)

var ffjKeyOrderPreviewCommission = []byte("Commission")

var ffjKeyOrderPreviewCost = []byte("Cost")

var ffjKeyOrderPreviewExtendedHours = []byte("extended_hours")

var ffjKeyOrderPreviewFees = []byte("Fees")

var ffjKeyOrderPreviewMarginChange = []byte("margin_change")

var ffjKeyOrderPreviewQuantity = []byte("Quantity")

var ffjKeyOrderPreviewStatus = []byte("Status")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OrderPreview) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OrderPreview) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOrderPreviewbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOrderPreviewnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyOrderPreviewCommission, kn) {
						currentKey = ffjtOrderPreviewCommission
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderPreviewCost, kn) {
						currentKey = ffjtOrderPreviewCost
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffjKeyOrderPreviewFees, kn) {
						currentKey = ffjtOrderPreviewFees
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyOrderPreviewQuantity, kn) {
						currentKey = ffjtOrderPreviewQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyOrderPreviewStatus, kn) {
						currentKey = ffjtOrderPreviewStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyOrderPreviewExtendedHours, kn) {
						currentKey = ffjtOrderPreviewExtendedHours
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyOrderPreviewMarginChange, kn) {
						currentKey = ffjtOrderPreviewMarginChange
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOrderPreviewStatus, kn) {
					currentKey = ffjtOrderPreviewStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderPreviewQuantity, kn) {
					currentKey = ffjtOrderPreviewQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderPreviewMarginChange, kn) {
					currentKey = ffjtOrderPreviewMarginChange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderPreviewFees, kn) {
					currentKey = ffjtOrderPreviewFees
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderPreviewExtendedHours, kn) {
					currentKey = ffjtOrderPreviewExtendedHours
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderPreviewCost, kn) {
					currentKey = ffjtOrderPreviewCost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderPreviewCommission, kn) {
					currentKey = ffjtOrderPreviewCommission
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOrderPreviewnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOrderPreviewCommission:
					goto handle_Commission

				case ffjtOrderPreviewCost:
					goto handle_Cost

				case ffjtOrderPreviewExtendedHours:
					goto handle_ExtendedHours

				case ffjtOrderPreviewFees:
					goto handle_Fees

				case ffjtOrderPreviewMarginChange:
					goto handle_MarginChange

				case ffjtOrderPreviewQuantity:
					goto handle_Quantity

				case ffjtOrderPreviewStatus:
					goto handle_Status

				case ffjtOrderPreviewnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Commission:

	/* handler: j.Commission type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Commission = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cost:

	/* handler: j.Cost type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Cost = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExtendedHours:

	/* handler: j.ExtendedHours type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ExtendedHours = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ExtendedHours = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fees:

	/* handler: j.Fees type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Fees = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarginChange:

	/* handler: j.MarginChange type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MarginChange = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: j.Quantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Quantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PDT) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PDT) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"day_trade_buying_power":`)
	fflib.AppendFloat(buf, float64(j.DayTradeBuyingPower), 'g', -1, 64)
	buf.WriteString(`,"fed_call":`)
	fflib.FormatBits2(buf, uint64(j.FedCall), 10, j.FedCall < 0)
	buf.WriteString(`,"maintenance_call":`)
	fflib.FormatBits2(buf, uint64(j.MaintenanceCall), 10, j.MaintenanceCall < 0)
	buf.WriteString(`,"option_buying_power":`)
	fflib.AppendFloat(buf, float64(j.OptionBuyingPower), 'g', -1, 64)
	buf.WriteString(`,"stock_buying_power":`)
	fflib.AppendFloat(buf, float64(j.StockBuyingPower), 'g', -1, 64)
	buf.WriteString(`,"stock_short_value":`)
	fflib.AppendFloat(buf, float64(j.StockShortValue), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPDTbase = iota
	ffjtPDTnosuchkey

	ffjtPDTDayTradeBuyingPower

	ffjtPDTFedCall

	ffjtPDTMaintenanceCall

	ffjtPDTOptionBuyingPower

	ffjtPDTStockBuyingPower

	ffjtPDTStockShortValue
)

var ffjKeyPDTDayTradeBuyingPower = []byte("day_trade_buying_power")

var ffjKeyPDTFedCall = []byte("fed_call")

var ffjKeyPDTMaintenanceCall = []byte("maintenance_call")

var ffjKeyPDTOptionBuyingPower = []byte("option_buying_power")

var ffjKeyPDTStockBuyingPower = []byte("stock_buying_power")

var ffjKeyPDTStockShortValue = []byte("stock_short_value")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PDT) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PDT) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPDTbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPDTnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyPDTDayTradeBuyingPower, kn) {
						currentKey = ffjtPDTDayTradeBuyingPower
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyPDTFedCall, kn) {
						currentKey = ffjtPDTFedCall
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPDTMaintenanceCall, kn) {
						currentKey = ffjtPDTMaintenanceCall
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyPDTOptionBuyingPower, kn) {
						currentKey = ffjtPDTOptionBuyingPower
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPDTStockBuyingPower, kn) {
						currentKey = ffjtPDTStockBuyingPower
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPDTStockShortValue, kn) {
						currentKey = ffjtPDTStockShortValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPDTStockShortValue, kn) {
					currentKey = ffjtPDTStockShortValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPDTStockBuyingPower, kn) {
					currentKey = ffjtPDTStockBuyingPower
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPDTOptionBuyingPower, kn) {
					currentKey = ffjtPDTOptionBuyingPower
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPDTMaintenanceCall, kn) {
					currentKey = ffjtPDTMaintenanceCall
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPDTFedCall, kn) {
					currentKey = ffjtPDTFedCall
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPDTDayTradeBuyingPower, kn) {
					currentKey = ffjtPDTDayTradeBuyingPower
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPDTnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPDTDayTradeBuyingPower:
					goto handle_DayTradeBuyingPower

				case ffjtPDTFedCall:
					goto handle_FedCall

				case ffjtPDTMaintenanceCall:
					goto handle_MaintenanceCall

				case ffjtPDTOptionBuyingPower:
					goto handle_OptionBuyingPower

				case ffjtPDTStockBuyingPower:
					goto handle_StockBuyingPower

				case ffjtPDTStockShortValue:
					goto handle_StockShortValue

				case ffjtPDTnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_DayTradeBuyingPower:

	/* handler: j.DayTradeBuyingPower type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.DayTradeBuyingPower = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FedCall:

	/* handler: j.FedCall type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FedCall = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaintenanceCall:

	/* handler: j.MaintenanceCall type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaintenanceCall = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionBuyingPower:

	/* handler: j.OptionBuyingPower type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OptionBuyingPower = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockBuyingPower:

	/* handler: j.StockBuyingPower type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StockBuyingPower = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockShortValue:

	/* handler: j.StockShortValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StockShortValue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Position) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Position) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cost_basis":`)
	fflib.AppendFloat(buf, float64(j.CostBasis), 'g', -1, 64)
	buf.WriteString(`,"date_acquired":`)

	{

		obj, err = j.DateAcquired.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"Id":`)
	fflib.FormatBits2(buf, uint64(j.Id), 10, j.Id < 0)
	buf.WriteString(`,"Quantity":`)
	fflib.AppendFloat(buf, float64(j.Quantity), 'g', -1, 64)
	buf.WriteString(`,"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPositionbase = iota
	ffjtPositionnosuchkey

	ffjtPositionCostBasis

	ffjtPositionDateAcquired

	ffjtPositionId

	ffjtPositionQuantity

	ffjtPositionSymbol
)

var ffjKeyPositionCostBasis = []byte("cost_basis")

var ffjKeyPositionDateAcquired = []byte("date_acquired")

var ffjKeyPositionId = []byte("Id")

var ffjKeyPositionQuantity = []byte("Quantity")

var ffjKeyPositionSymbol = []byte("Symbol")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Position) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Position) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPositionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'I':

					if bytes.Equal(ffjKeyPositionId, kn) {
						currentKey = ffjtPositionId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyPositionQuantity, kn) {
						currentKey = ffjtPositionQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyPositionSymbol, kn) {
						currentKey = ffjtPositionSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPositionCostBasis, kn) {
						currentKey = ffjtPositionCostBasis
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyPositionDateAcquired, kn) {
						currentKey = ffjtPositionDateAcquired
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPositionSymbol, kn) {
					currentKey = ffjtPositionSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPositionQuantity, kn) {
					currentKey = ffjtPositionQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPositionId, kn) {
					currentKey = ffjtPositionId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPositionDateAcquired, kn) {
					currentKey = ffjtPositionDateAcquired
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPositionCostBasis, kn) {
					currentKey = ffjtPositionCostBasis
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPositionCostBasis:
					goto handle_CostBasis

				case ffjtPositionDateAcquired:
					goto handle_DateAcquired

				case ffjtPositionId:
					goto handle_Id

				case ffjtPositionQuantity:
					goto handle_Quantity

				case ffjtPositionSymbol:
					goto handle_Symbol

				case ffjtPositionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CostBasis:

	/* handler: j.CostBasis type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CostBasis = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DateAcquired:

	/* handler: j.DateAcquired type=jsonutil.DateTime kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.DateAcquired.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Id:

	/* handler: j.Id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: j.Quantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Quantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Trade) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Trade) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Commission":`)
	fflib.AppendFloat(buf, float64(j.Commission), 'g', -1, 64)
	buf.WriteString(`,"Description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"Price":`)
	fflib.AppendFloat(buf, float64(j.Price), 'g', -1, 64)
	buf.WriteString(`,"Quantity":`)
	fflib.AppendFloat(buf, float64(j.Quantity), 'g', -1, 64)
	buf.WriteString(`,"Symbol":`)
	fflib.WriteJsonString(buf, string(j.Symbol))
	buf.WriteString(`,"trade_type":`)
	fflib.WriteJsonString(buf, string(j.TradeType))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtTradebase = iota
	ffjtTradenosuchkey

	ffjtTradeCommission

	ffjtTradeDescription

	ffjtTradePrice

	ffjtTradeQuantity

	ffjtTradeSymbol

	ffjtTradeTradeType
)

var ffjKeyTradeCommission = []byte("Commission")

var ffjKeyTradeDescription = []byte("Description")

var ffjKeyTradePrice = []byte("Price")

var ffjKeyTradeQuantity = []byte("Quantity")

var ffjKeyTradeSymbol = []byte("Symbol")

var ffjKeyTradeTradeType = []byte("trade_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Trade) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Trade) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTradebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTradenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyTradeCommission, kn) {
						currentKey = ffjtTradeCommission
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyTradeDescription, kn) {
						currentKey = ffjtTradeDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyTradePrice, kn) {
						currentKey = ffjtTradePrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyTradeQuantity, kn) {
						currentKey = ffjtTradeQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyTradeSymbol, kn) {
						currentKey = ffjtTradeSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyTradeTradeType, kn) {
						currentKey = ffjtTradeTradeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyTradeTradeType, kn) {
					currentKey = ffjtTradeTradeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTradeSymbol, kn) {
					currentKey = ffjtTradeSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTradeQuantity, kn) {
					currentKey = ffjtTradeQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTradePrice, kn) {
					currentKey = ffjtTradePrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTradeDescription, kn) {
					currentKey = ffjtTradeDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTradeCommission, kn) {
					currentKey = ffjtTradeCommission
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTradenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTradeCommission:
					goto handle_Commission

				case ffjtTradeDescription:
					goto handle_Description

				case ffjtTradePrice:
					goto handle_Price

				case ffjtTradeQuantity:
					goto handle_Quantity

				case ffjtTradeSymbol:
					goto handle_Symbol

				case ffjtTradeTradeType:
					goto handle_TradeType

				case ffjtTradenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Commission:

	/* handler: j.Commission type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Commission = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Price:

	/* handler: j.Price type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Price = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: j.Quantity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Quantity = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Symbol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TradeType:

	/* handler: j.TradeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TradeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
