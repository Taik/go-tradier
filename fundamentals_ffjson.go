// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: fundamentals.go

package tradier

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *AlphaBeta) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AlphaBeta) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Alpha != nil {
		buf.WriteString(`{"alpha":`)
		fflib.AppendFloat(buf, float64(*j.Alpha), 'g', -1, 64)
	} else {
		buf.WriteString(`{"alpha":null`)
	}
	if j.AsOfDate != nil {
		buf.WriteString(`,"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`,"as_of_date":null`)
	}
	if j.Beta != nil {
		buf.WriteString(`,"beta":`)
		fflib.AppendFloat(buf, float64(*j.Beta), 'g', -1, 64)
	} else {
		buf.WriteString(`,"beta":null`)
	}
	if j.NonDivAlpha != nil {
		buf.WriteString(`,"non_div_alpha":`)
		fflib.AppendFloat(buf, float64(*j.NonDivAlpha), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_div_alpha":null`)
	}
	if j.NonDivBeta != nil {
		buf.WriteString(`,"non_div_beta":`)
		fflib.AppendFloat(buf, float64(*j.NonDivBeta), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_div_beta":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAlphaBetabase = iota
	ffjtAlphaBetanosuchkey

	ffjtAlphaBetaAlpha

	ffjtAlphaBetaAsOfDate

	ffjtAlphaBetaBeta

	ffjtAlphaBetaNonDivAlpha

	ffjtAlphaBetaNonDivBeta

	ffjtAlphaBetaPeriod

	ffjtAlphaBetaShareClassID
)

var ffjKeyAlphaBetaAlpha = []byte("alpha")

var ffjKeyAlphaBetaAsOfDate = []byte("as_of_date")

var ffjKeyAlphaBetaBeta = []byte("beta")

var ffjKeyAlphaBetaNonDivAlpha = []byte("non_div_alpha")

var ffjKeyAlphaBetaNonDivBeta = []byte("non_div_beta")

var ffjKeyAlphaBetaPeriod = []byte("period")

var ffjKeyAlphaBetaShareClassID = []byte("share_class_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AlphaBeta) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AlphaBeta) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAlphaBetabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAlphaBetanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyAlphaBetaAlpha, kn) {
						currentKey = ffjtAlphaBetaAlpha
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAlphaBetaAsOfDate, kn) {
						currentKey = ffjtAlphaBetaAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyAlphaBetaBeta, kn) {
						currentKey = ffjtAlphaBetaBeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyAlphaBetaNonDivAlpha, kn) {
						currentKey = ffjtAlphaBetaNonDivAlpha
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAlphaBetaNonDivBeta, kn) {
						currentKey = ffjtAlphaBetaNonDivBeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAlphaBetaPeriod, kn) {
						currentKey = ffjtAlphaBetaPeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyAlphaBetaShareClassID, kn) {
						currentKey = ffjtAlphaBetaShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAlphaBetaShareClassID, kn) {
					currentKey = ffjtAlphaBetaShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAlphaBetaPeriod, kn) {
					currentKey = ffjtAlphaBetaPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAlphaBetaNonDivBeta, kn) {
					currentKey = ffjtAlphaBetaNonDivBeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAlphaBetaNonDivAlpha, kn) {
					currentKey = ffjtAlphaBetaNonDivAlpha
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAlphaBetaBeta, kn) {
					currentKey = ffjtAlphaBetaBeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAlphaBetaAsOfDate, kn) {
					currentKey = ffjtAlphaBetaAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAlphaBetaAlpha, kn) {
					currentKey = ffjtAlphaBetaAlpha
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAlphaBetanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAlphaBetaAlpha:
					goto handle_Alpha

				case ffjtAlphaBetaAsOfDate:
					goto handle_AsOfDate

				case ffjtAlphaBetaBeta:
					goto handle_Beta

				case ffjtAlphaBetaNonDivAlpha:
					goto handle_NonDivAlpha

				case ffjtAlphaBetaNonDivBeta:
					goto handle_NonDivBeta

				case ffjtAlphaBetaPeriod:
					goto handle_Period

				case ffjtAlphaBetaShareClassID:
					goto handle_ShareClassID

				case ffjtAlphaBetanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Alpha:

	/* handler: j.Alpha type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Alpha = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Alpha = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Beta:

	/* handler: j.Beta type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Beta = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Beta = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonDivAlpha:

	/* handler: j.NonDivAlpha type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonDivAlpha = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonDivAlpha = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonDivBeta:

	/* handler: j.NonDivBeta type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonDivBeta = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonDivBeta = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AssetClassification) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AssetClassification) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.FinancialHealthGradeAsOfDate != nil {
		buf.WriteString(`{"FinancialHealthGrade.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.FinancialHealthGradeAsOfDate))
	} else {
		buf.WriteString(`{"FinancialHealthGrade.asOfDate":null`)
	}
	if j.GrowthGradeAsOfDate != nil {
		buf.WriteString(`,"GrowthGrade.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.GrowthGradeAsOfDate))
	} else {
		buf.WriteString(`,"GrowthGrade.asOfDate":null`)
	}
	if j.ProfitabilityGradeAsOfDate != nil {
		buf.WriteString(`,"ProfitabilityGrade.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.ProfitabilityGradeAsOfDate))
	} else {
		buf.WriteString(`,"ProfitabilityGrade.asOfDate":null`)
	}
	if j.StockTypeAsOfDate != nil {
		buf.WriteString(`,"StockType.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.StockTypeAsOfDate))
	} else {
		buf.WriteString(`,"StockType.asOfDate":null`)
	}
	if j.StyleBoxAsOfDate != nil {
		buf.WriteString(`,"StyleBox.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.StyleBoxAsOfDate))
	} else {
		buf.WriteString(`,"StyleBox.asOfDate":null`)
	}
	if j.CANNAICS != nil {
		buf.WriteString(`,"c_a_n_n_a_i_c_s":`)
		fflib.FormatBits2(buf, uint64(*j.CANNAICS), 10, *j.CANNAICS < 0)
	} else {
		buf.WriteString(`,"c_a_n_n_a_i_c_s":null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	if j.FinancialHealthGrade != nil {
		buf.WriteString(`,"financial_health_grade":`)
		fflib.WriteJsonString(buf, string(*j.FinancialHealthGrade))
	} else {
		buf.WriteString(`,"financial_health_grade":null`)
	}
	if j.GrowthGrade != nil {
		buf.WriteString(`,"growth_grade":`)
		fflib.WriteJsonString(buf, string(*j.GrowthGrade))
	} else {
		buf.WriteString(`,"growth_grade":null`)
	}
	if j.GrowthScore != nil {
		buf.WriteString(`,"growth_score":`)
		fflib.AppendFloat(buf, float64(*j.GrowthScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"growth_score":null`)
	}
	if j.MorningstarEconomySphereCode != nil {
		buf.WriteString(`,"morningstar_economy_sphere_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarEconomySphereCode), 10, *j.MorningstarEconomySphereCode < 0)
	} else {
		buf.WriteString(`,"morningstar_economy_sphere_code":null`)
	}
	if j.MorningstarIndustryCode != nil {
		buf.WriteString(`,"morningstar_industry_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarIndustryCode), 10, *j.MorningstarIndustryCode < 0)
	} else {
		buf.WriteString(`,"morningstar_industry_code":null`)
	}
	if j.MorningstarIndustryGroupCode != nil {
		buf.WriteString(`,"morningstar_industry_group_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarIndustryGroupCode), 10, *j.MorningstarIndustryGroupCode < 0)
	} else {
		buf.WriteString(`,"morningstar_industry_group_code":null`)
	}
	if j.MorningstarSectorCode != nil {
		buf.WriteString(`,"morningstar_sector_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarSectorCode), 10, *j.MorningstarSectorCode < 0)
	} else {
		buf.WriteString(`,"morningstar_sector_code":null`)
	}
	if j.NACE != nil {
		buf.WriteString(`,"n_a_c_e":`)
		fflib.AppendFloat(buf, float64(*j.NACE), 'g', -1, 64)
	} else {
		buf.WriteString(`,"n_a_c_e":null`)
	}
	buf.WriteString(`,"n_a_i_c_s":`)
	if j.NAICS != nil {
		buf.WriteString(`[`)
		for i, v := range j.NAICS {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.ProfitabilityGrade != nil {
		buf.WriteString(`,"profitability_grade":`)
		fflib.WriteJsonString(buf, string(*j.ProfitabilityGrade))
	} else {
		buf.WriteString(`,"profitability_grade":null`)
	}
	buf.WriteString(`,"s_i_c":`)
	if j.SIC != nil {
		buf.WriteString(`[`)
		for i, v := range j.SIC {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.SizeScore != nil {
		buf.WriteString(`,"size_score":`)
		fflib.AppendFloat(buf, float64(*j.SizeScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"size_score":null`)
	}
	if j.StockType != nil {
		buf.WriteString(`,"stock_type":`)
		fflib.FormatBits2(buf, uint64(*j.StockType), 10, *j.StockType < 0)
	} else {
		buf.WriteString(`,"stock_type":null`)
	}
	if j.StyleBox != nil {
		buf.WriteString(`,"style_box":`)
		fflib.FormatBits2(buf, uint64(*j.StyleBox), 10, *j.StyleBox < 0)
	} else {
		buf.WriteString(`,"style_box":null`)
	}
	if j.StyleScore != nil {
		buf.WriteString(`,"style_score":`)
		fflib.AppendFloat(buf, float64(*j.StyleScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"style_score":null`)
	}
	if j.ValueScore != nil {
		buf.WriteString(`,"value_score":`)
		fflib.AppendFloat(buf, float64(*j.ValueScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"value_score":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAssetClassificationbase = iota
	ffjtAssetClassificationnosuchkey

	ffjtAssetClassificationFinancialHealthGradeAsOfDate

	ffjtAssetClassificationGrowthGradeAsOfDate

	ffjtAssetClassificationProfitabilityGradeAsOfDate

	ffjtAssetClassificationStockTypeAsOfDate

	ffjtAssetClassificationStyleBoxAsOfDate

	ffjtAssetClassificationCANNAICS

	ffjtAssetClassificationCompanyID

	ffjtAssetClassificationFinancialHealthGrade

	ffjtAssetClassificationGrowthGrade

	ffjtAssetClassificationGrowthScore

	ffjtAssetClassificationMorningstarEconomySphereCode

	ffjtAssetClassificationMorningstarIndustryCode

	ffjtAssetClassificationMorningstarIndustryGroupCode

	ffjtAssetClassificationMorningstarSectorCode

	ffjtAssetClassificationNACE

	ffjtAssetClassificationNAICS

	ffjtAssetClassificationProfitabilityGrade

	ffjtAssetClassificationSIC

	ffjtAssetClassificationSizeScore

	ffjtAssetClassificationStockType

	ffjtAssetClassificationStyleBox

	ffjtAssetClassificationStyleScore

	ffjtAssetClassificationValueScore
)

var ffjKeyAssetClassificationFinancialHealthGradeAsOfDate = []byte("FinancialHealthGrade.asOfDate")

var ffjKeyAssetClassificationGrowthGradeAsOfDate = []byte("GrowthGrade.asOfDate")

var ffjKeyAssetClassificationProfitabilityGradeAsOfDate = []byte("ProfitabilityGrade.asOfDate")

var ffjKeyAssetClassificationStockTypeAsOfDate = []byte("StockType.asOfDate")

var ffjKeyAssetClassificationStyleBoxAsOfDate = []byte("StyleBox.asOfDate")

var ffjKeyAssetClassificationCANNAICS = []byte("c_a_n_n_a_i_c_s")

var ffjKeyAssetClassificationCompanyID = []byte("company_id")

var ffjKeyAssetClassificationFinancialHealthGrade = []byte("financial_health_grade")

var ffjKeyAssetClassificationGrowthGrade = []byte("growth_grade")

var ffjKeyAssetClassificationGrowthScore = []byte("growth_score")

var ffjKeyAssetClassificationMorningstarEconomySphereCode = []byte("morningstar_economy_sphere_code")

var ffjKeyAssetClassificationMorningstarIndustryCode = []byte("morningstar_industry_code")

var ffjKeyAssetClassificationMorningstarIndustryGroupCode = []byte("morningstar_industry_group_code")

var ffjKeyAssetClassificationMorningstarSectorCode = []byte("morningstar_sector_code")

var ffjKeyAssetClassificationNACE = []byte("n_a_c_e")

var ffjKeyAssetClassificationNAICS = []byte("n_a_i_c_s")

var ffjKeyAssetClassificationProfitabilityGrade = []byte("profitability_grade")

var ffjKeyAssetClassificationSIC = []byte("s_i_c")

var ffjKeyAssetClassificationSizeScore = []byte("size_score")

var ffjKeyAssetClassificationStockType = []byte("stock_type")

var ffjKeyAssetClassificationStyleBox = []byte("style_box")

var ffjKeyAssetClassificationStyleScore = []byte("style_score")

var ffjKeyAssetClassificationValueScore = []byte("value_score")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AssetClassification) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AssetClassification) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAssetClassificationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAssetClassificationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'F':

					if bytes.Equal(ffjKeyAssetClassificationFinancialHealthGradeAsOfDate, kn) {
						currentKey = ffjtAssetClassificationFinancialHealthGradeAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'G':

					if bytes.Equal(ffjKeyAssetClassificationGrowthGradeAsOfDate, kn) {
						currentKey = ffjtAssetClassificationGrowthGradeAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyAssetClassificationProfitabilityGradeAsOfDate, kn) {
						currentKey = ffjtAssetClassificationProfitabilityGradeAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyAssetClassificationStockTypeAsOfDate, kn) {
						currentKey = ffjtAssetClassificationStockTypeAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationStyleBoxAsOfDate, kn) {
						currentKey = ffjtAssetClassificationStyleBoxAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyAssetClassificationCANNAICS, kn) {
						currentKey = ffjtAssetClassificationCANNAICS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationCompanyID, kn) {
						currentKey = ffjtAssetClassificationCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAssetClassificationFinancialHealthGrade, kn) {
						currentKey = ffjtAssetClassificationFinancialHealthGrade
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyAssetClassificationGrowthGrade, kn) {
						currentKey = ffjtAssetClassificationGrowthGrade
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationGrowthScore, kn) {
						currentKey = ffjtAssetClassificationGrowthScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAssetClassificationMorningstarEconomySphereCode, kn) {
						currentKey = ffjtAssetClassificationMorningstarEconomySphereCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationMorningstarIndustryCode, kn) {
						currentKey = ffjtAssetClassificationMorningstarIndustryCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationMorningstarIndustryGroupCode, kn) {
						currentKey = ffjtAssetClassificationMorningstarIndustryGroupCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationMorningstarSectorCode, kn) {
						currentKey = ffjtAssetClassificationMorningstarSectorCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyAssetClassificationNACE, kn) {
						currentKey = ffjtAssetClassificationNACE
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationNAICS, kn) {
						currentKey = ffjtAssetClassificationNAICS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAssetClassificationProfitabilityGrade, kn) {
						currentKey = ffjtAssetClassificationProfitabilityGrade
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyAssetClassificationSIC, kn) {
						currentKey = ffjtAssetClassificationSIC
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationSizeScore, kn) {
						currentKey = ffjtAssetClassificationSizeScore
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationStockType, kn) {
						currentKey = ffjtAssetClassificationStockType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationStyleBox, kn) {
						currentKey = ffjtAssetClassificationStyleBox
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAssetClassificationStyleScore, kn) {
						currentKey = ffjtAssetClassificationStyleScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyAssetClassificationValueScore, kn) {
						currentKey = ffjtAssetClassificationValueScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationValueScore, kn) {
					currentKey = ffjtAssetClassificationValueScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationStyleScore, kn) {
					currentKey = ffjtAssetClassificationStyleScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationStyleBox, kn) {
					currentKey = ffjtAssetClassificationStyleBox
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationStockType, kn) {
					currentKey = ffjtAssetClassificationStockType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationSizeScore, kn) {
					currentKey = ffjtAssetClassificationSizeScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationSIC, kn) {
					currentKey = ffjtAssetClassificationSIC
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAssetClassificationProfitabilityGrade, kn) {
					currentKey = ffjtAssetClassificationProfitabilityGrade
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationNAICS, kn) {
					currentKey = ffjtAssetClassificationNAICS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAssetClassificationNACE, kn) {
					currentKey = ffjtAssetClassificationNACE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationMorningstarSectorCode, kn) {
					currentKey = ffjtAssetClassificationMorningstarSectorCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationMorningstarIndustryGroupCode, kn) {
					currentKey = ffjtAssetClassificationMorningstarIndustryGroupCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationMorningstarIndustryCode, kn) {
					currentKey = ffjtAssetClassificationMorningstarIndustryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationMorningstarEconomySphereCode, kn) {
					currentKey = ffjtAssetClassificationMorningstarEconomySphereCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationGrowthScore, kn) {
					currentKey = ffjtAssetClassificationGrowthScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAssetClassificationGrowthGrade, kn) {
					currentKey = ffjtAssetClassificationGrowthGrade
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAssetClassificationFinancialHealthGrade, kn) {
					currentKey = ffjtAssetClassificationFinancialHealthGrade
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAssetClassificationCompanyID, kn) {
					currentKey = ffjtAssetClassificationCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationCANNAICS, kn) {
					currentKey = ffjtAssetClassificationCANNAICS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationStyleBoxAsOfDate, kn) {
					currentKey = ffjtAssetClassificationStyleBoxAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationStockTypeAsOfDate, kn) {
					currentKey = ffjtAssetClassificationStockTypeAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationProfitabilityGradeAsOfDate, kn) {
					currentKey = ffjtAssetClassificationProfitabilityGradeAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationGrowthGradeAsOfDate, kn) {
					currentKey = ffjtAssetClassificationGrowthGradeAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAssetClassificationFinancialHealthGradeAsOfDate, kn) {
					currentKey = ffjtAssetClassificationFinancialHealthGradeAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAssetClassificationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAssetClassificationFinancialHealthGradeAsOfDate:
					goto handle_FinancialHealthGradeAsOfDate

				case ffjtAssetClassificationGrowthGradeAsOfDate:
					goto handle_GrowthGradeAsOfDate

				case ffjtAssetClassificationProfitabilityGradeAsOfDate:
					goto handle_ProfitabilityGradeAsOfDate

				case ffjtAssetClassificationStockTypeAsOfDate:
					goto handle_StockTypeAsOfDate

				case ffjtAssetClassificationStyleBoxAsOfDate:
					goto handle_StyleBoxAsOfDate

				case ffjtAssetClassificationCANNAICS:
					goto handle_CANNAICS

				case ffjtAssetClassificationCompanyID:
					goto handle_CompanyID

				case ffjtAssetClassificationFinancialHealthGrade:
					goto handle_FinancialHealthGrade

				case ffjtAssetClassificationGrowthGrade:
					goto handle_GrowthGrade

				case ffjtAssetClassificationGrowthScore:
					goto handle_GrowthScore

				case ffjtAssetClassificationMorningstarEconomySphereCode:
					goto handle_MorningstarEconomySphereCode

				case ffjtAssetClassificationMorningstarIndustryCode:
					goto handle_MorningstarIndustryCode

				case ffjtAssetClassificationMorningstarIndustryGroupCode:
					goto handle_MorningstarIndustryGroupCode

				case ffjtAssetClassificationMorningstarSectorCode:
					goto handle_MorningstarSectorCode

				case ffjtAssetClassificationNACE:
					goto handle_NACE

				case ffjtAssetClassificationNAICS:
					goto handle_NAICS

				case ffjtAssetClassificationProfitabilityGrade:
					goto handle_ProfitabilityGrade

				case ffjtAssetClassificationSIC:
					goto handle_SIC

				case ffjtAssetClassificationSizeScore:
					goto handle_SizeScore

				case ffjtAssetClassificationStockType:
					goto handle_StockType

				case ffjtAssetClassificationStyleBox:
					goto handle_StyleBox

				case ffjtAssetClassificationStyleScore:
					goto handle_StyleScore

				case ffjtAssetClassificationValueScore:
					goto handle_ValueScore

				case ffjtAssetClassificationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FinancialHealthGradeAsOfDate:

	/* handler: j.FinancialHealthGradeAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FinancialHealthGradeAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FinancialHealthGradeAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrowthGradeAsOfDate:

	/* handler: j.GrowthGradeAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.GrowthGradeAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.GrowthGradeAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfitabilityGradeAsOfDate:

	/* handler: j.ProfitabilityGradeAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ProfitabilityGradeAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ProfitabilityGradeAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockTypeAsOfDate:

	/* handler: j.StockTypeAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.StockTypeAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.StockTypeAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StyleBoxAsOfDate:

	/* handler: j.StyleBoxAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.StyleBoxAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.StyleBoxAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CANNAICS:

	/* handler: j.CANNAICS type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CANNAICS = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.CANNAICS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinancialHealthGrade:

	/* handler: j.FinancialHealthGrade type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FinancialHealthGrade = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FinancialHealthGrade = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrowthGrade:

	/* handler: j.GrowthGrade type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.GrowthGrade = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.GrowthGrade = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrowthScore:

	/* handler: j.GrowthScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GrowthScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GrowthScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarEconomySphereCode:

	/* handler: j.MorningstarEconomySphereCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarEconomySphereCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarEconomySphereCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarIndustryCode:

	/* handler: j.MorningstarIndustryCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarIndustryCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarIndustryCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarIndustryGroupCode:

	/* handler: j.MorningstarIndustryGroupCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarIndustryGroupCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarIndustryGroupCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarSectorCode:

	/* handler: j.MorningstarSectorCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarSectorCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarSectorCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NACE:

	/* handler: j.NACE type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NACE = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NACE = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NAICS:

	/* handler: j.NAICS type=tradier.NAICS kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.NAICS.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfitabilityGrade:

	/* handler: j.ProfitabilityGrade type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ProfitabilityGrade = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ProfitabilityGrade = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SIC:

	/* handler: j.SIC type=tradier.SIC kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.SIC.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SizeScore:

	/* handler: j.SizeScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SizeScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SizeScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockType:

	/* handler: j.StockType type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StockType = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.StockType = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StyleBox:

	/* handler: j.StyleBox type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StyleBox = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.StyleBox = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StyleScore:

	/* handler: j.StyleScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StyleScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.StyleScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueScore:

	/* handler: j.ValueScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ValueScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ValueScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *BalanceSheet) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *BalanceSheet) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AccountsPayable != nil {
		buf.WriteString(`{"accounts_payable":`)
		fflib.AppendFloat(buf, float64(*j.AccountsPayable), 'g', -1, 64)
	} else {
		buf.WriteString(`{"accounts_payable":null`)
	}
	if j.AccountsReceivable != nil {
		buf.WriteString(`,"accounts_receivable":`)
		fflib.AppendFloat(buf, float64(*j.AccountsReceivable), 'g', -1, 64)
	} else {
		buf.WriteString(`,"accounts_receivable":null`)
	}
	if j.AccumulatedDepreciation != nil {
		buf.WriteString(`,"accumulated_depreciation":`)
		fflib.AppendFloat(buf, float64(*j.AccumulatedDepreciation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"accumulated_depreciation":null`)
	}
	if j.CapitalStock != nil {
		buf.WriteString(`,"capital_stock":`)
		fflib.AppendFloat(buf, float64(*j.CapitalStock), 'g', -1, 64)
	} else {
		buf.WriteString(`,"capital_stock":null`)
	}
	if j.CashAndCashEquivalents != nil {
		buf.WriteString(`,"cash_and_cash_equivalents":`)
		fflib.AppendFloat(buf, float64(*j.CashAndCashEquivalents), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cash_and_cash_equivalents":null`)
	}
	if j.CashCashEquivalentsAndMarketableSecurities != nil {
		buf.WriteString(`,"cash_cash_equivalents_and_marketable_securities":`)
		fflib.AppendFloat(buf, float64(*j.CashCashEquivalentsAndMarketableSecurities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cash_cash_equivalents_and_marketable_securities":null`)
	}
	if j.CommercialPaper != nil {
		buf.WriteString(`,"commercial_paper":`)
		fflib.AppendFloat(buf, float64(*j.CommercialPaper), 'g', -1, 64)
	} else {
		buf.WriteString(`,"commercial_paper":null`)
	}
	if j.CommonStock != nil {
		buf.WriteString(`,"common_stock":`)
		fflib.AppendFloat(buf, float64(*j.CommonStock), 'g', -1, 64)
	} else {
		buf.WriteString(`,"common_stock":null`)
	}
	if j.CommonStockEquity != nil {
		buf.WriteString(`,"common_stock_equity":`)
		fflib.AppendFloat(buf, float64(*j.CommonStockEquity), 'g', -1, 64)
	} else {
		buf.WriteString(`,"common_stock_equity":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_id":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_id":null`)
	}
	if j.CurrentAccruedExpenses != nil {
		buf.WriteString(`,"current_accrued_expenses":`)
		fflib.AppendFloat(buf, float64(*j.CurrentAccruedExpenses), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_accrued_expenses":null`)
	}
	if j.CurrentAssets != nil {
		buf.WriteString(`,"current_assets":`)
		fflib.AppendFloat(buf, float64(*j.CurrentAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_assets":null`)
	}
	if j.CurrentDebt != nil {
		buf.WriteString(`,"current_debt":`)
		fflib.AppendFloat(buf, float64(*j.CurrentDebt), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_debt":null`)
	}
	if j.CurrentDebtAndCapitalLeaseObligation != nil {
		buf.WriteString(`,"current_debt_and_capital_lease_obligation":`)
		fflib.AppendFloat(buf, float64(*j.CurrentDebtAndCapitalLeaseObligation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_debt_and_capital_lease_obligation":null`)
	}
	if j.CurrentDeferredLiabilities != nil {
		buf.WriteString(`,"current_deferred_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.CurrentDeferredLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_deferred_liabilities":null`)
	}
	if j.CurrentDeferredRevenue != nil {
		buf.WriteString(`,"current_deferred_revenue":`)
		fflib.AppendFloat(buf, float64(*j.CurrentDeferredRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_deferred_revenue":null`)
	}
	if j.CurrentLiabilities != nil {
		buf.WriteString(`,"current_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.CurrentLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_liabilities":null`)
	}
	if j.FileDate != nil {
		buf.WriteString(`,"file_date":`)
		fflib.WriteJsonString(buf, string(*j.FileDate))
	} else {
		buf.WriteString(`,"file_date":null`)
	}
	if j.FiscalYearEnd != nil {
		buf.WriteString(`,"fiscal_year_end":`)
		fflib.WriteJsonString(buf, string(*j.FiscalYearEnd))
	} else {
		buf.WriteString(`,"fiscal_year_end":null`)
	}
	if j.GainsLossesNotAffectingRetainedEarnings != nil {
		buf.WriteString(`,"gains_losses_not_affecting_retained_earnings":`)
		fflib.AppendFloat(buf, float64(*j.GainsLossesNotAffectingRetainedEarnings), 'g', -1, 64)
	} else {
		buf.WriteString(`,"gains_losses_not_affecting_retained_earnings":null`)
	}
	if j.Goodwill != nil {
		buf.WriteString(`,"goodwill":`)
		fflib.AppendFloat(buf, float64(*j.Goodwill), 'g', -1, 64)
	} else {
		buf.WriteString(`,"goodwill":null`)
	}
	if j.GoodwillAndOtherIntangibleAssets != nil {
		buf.WriteString(`,"goodwill_and_other_int64angible_assets":`)
		fflib.AppendFloat(buf, float64(*j.GoodwillAndOtherIntangibleAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"goodwill_and_other_int64angible_assets":null`)
	}
	if j.GrossPPE != nil {
		buf.WriteString(`,"gross_p_p_e":`)
		fflib.AppendFloat(buf, float64(*j.GrossPPE), 'g', -1, 64)
	} else {
		buf.WriteString(`,"gross_p_p_e":null`)
	}
	if j.Inventory != nil {
		buf.WriteString(`,"inventory":`)
		fflib.AppendFloat(buf, float64(*j.Inventory), 'g', -1, 64)
	} else {
		buf.WriteString(`,"inventory":null`)
	}
	if j.InvestedCapital != nil {
		buf.WriteString(`,"invested_capital":`)
		fflib.AppendFloat(buf, float64(*j.InvestedCapital), 'g', -1, 64)
	} else {
		buf.WriteString(`,"invested_capital":null`)
	}
	if j.InvestmentsAndAdvances != nil {
		buf.WriteString(`,"investments_and_advances":`)
		fflib.AppendFloat(buf, float64(*j.InvestmentsAndAdvances), 'g', -1, 64)
	} else {
		buf.WriteString(`,"investments_and_advances":null`)
	}
	if j.LandAndImprovements != nil {
		buf.WriteString(`,"land_and_improvements":`)
		fflib.AppendFloat(buf, float64(*j.LandAndImprovements), 'g', -1, 64)
	} else {
		buf.WriteString(`,"land_and_improvements":null`)
	}
	if j.Leases != nil {
		buf.WriteString(`,"leases":`)
		fflib.AppendFloat(buf, float64(*j.Leases), 'g', -1, 64)
	} else {
		buf.WriteString(`,"leases":null`)
	}
	if j.LongTermDebt != nil {
		buf.WriteString(`,"long_term_debt":`)
		fflib.AppendFloat(buf, float64(*j.LongTermDebt), 'g', -1, 64)
	} else {
		buf.WriteString(`,"long_term_debt":null`)
	}
	if j.LongTermDebtAndCapitalLeaseObligation != nil {
		buf.WriteString(`,"long_term_debt_and_capital_lease_obligation":`)
		fflib.AppendFloat(buf, float64(*j.LongTermDebtAndCapitalLeaseObligation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"long_term_debt_and_capital_lease_obligation":null`)
	}
	if j.MachineryFurnitureEquipment != nil {
		buf.WriteString(`,"machinery_furniture_equipment":`)
		fflib.AppendFloat(buf, float64(*j.MachineryFurnitureEquipment), 'g', -1, 64)
	} else {
		buf.WriteString(`,"machinery_furniture_equipment":null`)
	}
	if j.NetDebt != nil {
		buf.WriteString(`,"net_debt":`)
		fflib.AppendFloat(buf, float64(*j.NetDebt), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_debt":null`)
	}
	if j.NetPPE != nil {
		buf.WriteString(`,"net_p_p_e":`)
		fflib.AppendFloat(buf, float64(*j.NetPPE), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_p_p_e":null`)
	}
	if j.NetTangibleAssets != nil {
		buf.WriteString(`,"net_tangible_assets":`)
		fflib.AppendFloat(buf, float64(*j.NetTangibleAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_tangible_assets":null`)
	}
	if j.NonCurrentDeferredLiabilities != nil {
		buf.WriteString(`,"non_current_deferred_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.NonCurrentDeferredLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_current_deferred_liabilities":null`)
	}
	if j.NonCurrentDeferredRevenue != nil {
		buf.WriteString(`,"non_current_deferred_revenue":`)
		fflib.AppendFloat(buf, float64(*j.NonCurrentDeferredRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_current_deferred_revenue":null`)
	}
	if j.NonCurrentDeferredTaxesLiabilities != nil {
		buf.WriteString(`,"non_current_deferred_taxes_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.NonCurrentDeferredTaxesLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_current_deferred_taxes_liabilities":null`)
	}
	if j.NumberOfShareHolders != nil {
		buf.WriteString(`,"number_of_share_holders":`)
		fflib.FormatBits2(buf, uint64(*j.NumberOfShareHolders), 10, *j.NumberOfShareHolders < 0)
	} else {
		buf.WriteString(`,"number_of_share_holders":null`)
	}
	if j.OrdinarySharesNumber != nil {
		buf.WriteString(`,"ordinary_shares_number":`)
		fflib.AppendFloat(buf, float64(*j.OrdinarySharesNumber), 'g', -1, 64)
	} else {
		buf.WriteString(`,"ordinary_shares_number":null`)
	}
	if j.OtherCurrentAssets != nil {
		buf.WriteString(`,"other_current_assets":`)
		fflib.AppendFloat(buf, float64(*j.OtherCurrentAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_current_assets":null`)
	}
	if j.OtherCurrentBorrowings != nil {
		buf.WriteString(`,"other_current_borrowings":`)
		fflib.AppendFloat(buf, float64(*j.OtherCurrentBorrowings), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_current_borrowings":null`)
	}
	if j.OtherIntangibleAssets != nil {
		buf.WriteString(`,"other_int64angible_assets":`)
		fflib.AppendFloat(buf, float64(*j.OtherIntangibleAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_int64angible_assets":null`)
	}
	if j.OtherNonCurrentAssets != nil {
		buf.WriteString(`,"other_non_current_assets":`)
		fflib.AppendFloat(buf, float64(*j.OtherNonCurrentAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_non_current_assets":null`)
	}
	if j.OtherNonCurrentLiabilities != nil {
		buf.WriteString(`,"other_non_current_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.OtherNonCurrentLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_non_current_liabilities":null`)
	}
	if j.OtherReceivables != nil {
		buf.WriteString(`,"other_receivables":`)
		fflib.AppendFloat(buf, float64(*j.OtherReceivables), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_receivables":null`)
	}
	if j.OtherShortTermInvestments != nil {
		buf.WriteString(`,"other_short_term_investments":`)
		fflib.AppendFloat(buf, float64(*j.OtherShortTermInvestments), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_short_term_investments":null`)
	}
	if j.Payables != nil {
		buf.WriteString(`,"payables":`)
		fflib.AppendFloat(buf, float64(*j.Payables), 'g', -1, 64)
	} else {
		buf.WriteString(`,"payables":null`)
	}
	if j.PayablesAndAccruedExpenses != nil {
		buf.WriteString(`,"payables_and_accrued_expenses":`)
		fflib.AppendFloat(buf, float64(*j.PayablesAndAccruedExpenses), 'g', -1, 64)
	} else {
		buf.WriteString(`,"payables_and_accrued_expenses":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.PeriodEndingDate != nil {
		buf.WriteString(`,"period_ending_date":`)
		fflib.WriteJsonString(buf, string(*j.PeriodEndingDate))
	} else {
		buf.WriteString(`,"period_ending_date":null`)
	}
	if j.Receivables != nil {
		buf.WriteString(`,"receivables":`)
		fflib.AppendFloat(buf, float64(*j.Receivables), 'g', -1, 64)
	} else {
		buf.WriteString(`,"receivables":null`)
	}
	if j.ReportType != nil {
		buf.WriteString(`,"report_type":`)
		fflib.WriteJsonString(buf, string(*j.ReportType))
	} else {
		buf.WriteString(`,"report_type":null`)
	}
	if j.RetainedEarnings != nil {
		buf.WriteString(`,"retained_earnings":`)
		fflib.AppendFloat(buf, float64(*j.RetainedEarnings), 'g', -1, 64)
	} else {
		buf.WriteString(`,"retained_earnings":null`)
	}
	if j.ShareIssued != nil {
		buf.WriteString(`,"share_issued":`)
		fflib.AppendFloat(buf, float64(*j.ShareIssued), 'g', -1, 64)
	} else {
		buf.WriteString(`,"share_issued":null`)
	}
	if j.StockholdersEquity != nil {
		buf.WriteString(`,"stockholders_equity":`)
		fflib.AppendFloat(buf, float64(*j.StockholdersEquity), 'g', -1, 64)
	} else {
		buf.WriteString(`,"stockholders_equity":null`)
	}
	if j.TangibleBookValue != nil {
		buf.WriteString(`,"tangible_book_value":`)
		fflib.AppendFloat(buf, float64(*j.TangibleBookValue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tangible_book_value":null`)
	}
	if j.TotalAssets != nil {
		buf.WriteString(`,"total_assets":`)
		fflib.AppendFloat(buf, float64(*j.TotalAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_assets":null`)
	}
	if j.TotalCapitalization != nil {
		buf.WriteString(`,"total_capitalization":`)
		fflib.AppendFloat(buf, float64(*j.TotalCapitalization), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_capitalization":null`)
	}
	if j.TotalDebt != nil {
		buf.WriteString(`,"total_debt":`)
		fflib.AppendFloat(buf, float64(*j.TotalDebt), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_debt":null`)
	}
	if j.TotalEquity != nil {
		buf.WriteString(`,"total_equity":`)
		fflib.AppendFloat(buf, float64(*j.TotalEquity), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_equity":null`)
	}
	if j.TotalEquityGrossMinorityInterest != nil {
		buf.WriteString(`,"total_equity_gross_minority_int64erest":`)
		fflib.AppendFloat(buf, float64(*j.TotalEquityGrossMinorityInterest), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_equity_gross_minority_int64erest":null`)
	}
	if j.TotalLiabilities != nil {
		buf.WriteString(`,"total_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.TotalLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_liabilities":null`)
	}
	if j.TotalLiabilitiesNetMinorityInterest != nil {
		buf.WriteString(`,"total_liabilities_net_minority_int64erest":`)
		fflib.AppendFloat(buf, float64(*j.TotalLiabilitiesNetMinorityInterest), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_liabilities_net_minority_int64erest":null`)
	}
	if j.TotalNonCurrentAssets != nil {
		buf.WriteString(`,"total_non_current_assets":`)
		fflib.AppendFloat(buf, float64(*j.TotalNonCurrentAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_non_current_assets":null`)
	}
	if j.TotalNonCurrentLiabilities != nil {
		buf.WriteString(`,"total_non_current_liabilities":`)
		fflib.AppendFloat(buf, float64(*j.TotalNonCurrentLiabilities), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_non_current_liabilities":null`)
	}
	if j.TotalNonCurrentLiabilitiesNetMinorityInterest != nil {
		buf.WriteString(`,"total_non_current_liabilities_net_minority_int64erest":`)
		fflib.AppendFloat(buf, float64(*j.TotalNonCurrentLiabilitiesNetMinorityInterest), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_non_current_liabilities_net_minority_int64erest":null`)
	}
	if j.WorkingCapital != nil {
		buf.WriteString(`,"working_capital":`)
		fflib.AppendFloat(buf, float64(*j.WorkingCapital), 'g', -1, 64)
	} else {
		buf.WriteString(`,"working_capital":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtBalanceSheetbase = iota
	ffjtBalanceSheetnosuchkey

	ffjtBalanceSheetAccountsPayable

	ffjtBalanceSheetAccountsReceivable

	ffjtBalanceSheetAccumulatedDepreciation

	ffjtBalanceSheetCapitalStock

	ffjtBalanceSheetCashAndCashEquivalents

	ffjtBalanceSheetCashCashEquivalentsAndMarketableSecurities

	ffjtBalanceSheetCommercialPaper

	ffjtBalanceSheetCommonStock

	ffjtBalanceSheetCommonStockEquity

	ffjtBalanceSheetCurrencyID

	ffjtBalanceSheetCurrentAccruedExpenses

	ffjtBalanceSheetCurrentAssets

	ffjtBalanceSheetCurrentDebt

	ffjtBalanceSheetCurrentDebtAndCapitalLeaseObligation

	ffjtBalanceSheetCurrentDeferredLiabilities

	ffjtBalanceSheetCurrentDeferredRevenue

	ffjtBalanceSheetCurrentLiabilities

	ffjtBalanceSheetFileDate

	ffjtBalanceSheetFiscalYearEnd

	ffjtBalanceSheetGainsLossesNotAffectingRetainedEarnings

	ffjtBalanceSheetGoodwill

	ffjtBalanceSheetGoodwillAndOtherIntangibleAssets

	ffjtBalanceSheetGrossPPE

	ffjtBalanceSheetInventory

	ffjtBalanceSheetInvestedCapital

	ffjtBalanceSheetInvestmentsAndAdvances

	ffjtBalanceSheetLandAndImprovements

	ffjtBalanceSheetLeases

	ffjtBalanceSheetLongTermDebt

	ffjtBalanceSheetLongTermDebtAndCapitalLeaseObligation

	ffjtBalanceSheetMachineryFurnitureEquipment

	ffjtBalanceSheetNetDebt

	ffjtBalanceSheetNetPPE

	ffjtBalanceSheetNetTangibleAssets

	ffjtBalanceSheetNonCurrentDeferredLiabilities

	ffjtBalanceSheetNonCurrentDeferredRevenue

	ffjtBalanceSheetNonCurrentDeferredTaxesLiabilities

	ffjtBalanceSheetNumberOfShareHolders

	ffjtBalanceSheetOrdinarySharesNumber

	ffjtBalanceSheetOtherCurrentAssets

	ffjtBalanceSheetOtherCurrentBorrowings

	ffjtBalanceSheetOtherIntangibleAssets

	ffjtBalanceSheetOtherNonCurrentAssets

	ffjtBalanceSheetOtherNonCurrentLiabilities

	ffjtBalanceSheetOtherReceivables

	ffjtBalanceSheetOtherShortTermInvestments

	ffjtBalanceSheetPayables

	ffjtBalanceSheetPayablesAndAccruedExpenses

	ffjtBalanceSheetPeriod

	ffjtBalanceSheetPeriodEndingDate

	ffjtBalanceSheetReceivables

	ffjtBalanceSheetReportType

	ffjtBalanceSheetRetainedEarnings

	ffjtBalanceSheetShareIssued

	ffjtBalanceSheetStockholdersEquity

	ffjtBalanceSheetTangibleBookValue

	ffjtBalanceSheetTotalAssets

	ffjtBalanceSheetTotalCapitalization

	ffjtBalanceSheetTotalDebt

	ffjtBalanceSheetTotalEquity

	ffjtBalanceSheetTotalEquityGrossMinorityInterest

	ffjtBalanceSheetTotalLiabilities

	ffjtBalanceSheetTotalLiabilitiesNetMinorityInterest

	ffjtBalanceSheetTotalNonCurrentAssets

	ffjtBalanceSheetTotalNonCurrentLiabilities

	ffjtBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest

	ffjtBalanceSheetWorkingCapital
)

var ffjKeyBalanceSheetAccountsPayable = []byte("accounts_payable")

var ffjKeyBalanceSheetAccountsReceivable = []byte("accounts_receivable")

var ffjKeyBalanceSheetAccumulatedDepreciation = []byte("accumulated_depreciation")

var ffjKeyBalanceSheetCapitalStock = []byte("capital_stock")

var ffjKeyBalanceSheetCashAndCashEquivalents = []byte("cash_and_cash_equivalents")

var ffjKeyBalanceSheetCashCashEquivalentsAndMarketableSecurities = []byte("cash_cash_equivalents_and_marketable_securities")

var ffjKeyBalanceSheetCommercialPaper = []byte("commercial_paper")

var ffjKeyBalanceSheetCommonStock = []byte("common_stock")

var ffjKeyBalanceSheetCommonStockEquity = []byte("common_stock_equity")

var ffjKeyBalanceSheetCurrencyID = []byte("currency_id")

var ffjKeyBalanceSheetCurrentAccruedExpenses = []byte("current_accrued_expenses")

var ffjKeyBalanceSheetCurrentAssets = []byte("current_assets")

var ffjKeyBalanceSheetCurrentDebt = []byte("current_debt")

var ffjKeyBalanceSheetCurrentDebtAndCapitalLeaseObligation = []byte("current_debt_and_capital_lease_obligation")

var ffjKeyBalanceSheetCurrentDeferredLiabilities = []byte("current_deferred_liabilities")

var ffjKeyBalanceSheetCurrentDeferredRevenue = []byte("current_deferred_revenue")

var ffjKeyBalanceSheetCurrentLiabilities = []byte("current_liabilities")

var ffjKeyBalanceSheetFileDate = []byte("file_date")

var ffjKeyBalanceSheetFiscalYearEnd = []byte("fiscal_year_end")

var ffjKeyBalanceSheetGainsLossesNotAffectingRetainedEarnings = []byte("gains_losses_not_affecting_retained_earnings")

var ffjKeyBalanceSheetGoodwill = []byte("goodwill")

var ffjKeyBalanceSheetGoodwillAndOtherIntangibleAssets = []byte("goodwill_and_other_int64angible_assets")

var ffjKeyBalanceSheetGrossPPE = []byte("gross_p_p_e")

var ffjKeyBalanceSheetInventory = []byte("inventory")

var ffjKeyBalanceSheetInvestedCapital = []byte("invested_capital")

var ffjKeyBalanceSheetInvestmentsAndAdvances = []byte("investments_and_advances")

var ffjKeyBalanceSheetLandAndImprovements = []byte("land_and_improvements")

var ffjKeyBalanceSheetLeases = []byte("leases")

var ffjKeyBalanceSheetLongTermDebt = []byte("long_term_debt")

var ffjKeyBalanceSheetLongTermDebtAndCapitalLeaseObligation = []byte("long_term_debt_and_capital_lease_obligation")

var ffjKeyBalanceSheetMachineryFurnitureEquipment = []byte("machinery_furniture_equipment")

var ffjKeyBalanceSheetNetDebt = []byte("net_debt")

var ffjKeyBalanceSheetNetPPE = []byte("net_p_p_e")

var ffjKeyBalanceSheetNetTangibleAssets = []byte("net_tangible_assets")

var ffjKeyBalanceSheetNonCurrentDeferredLiabilities = []byte("non_current_deferred_liabilities")

var ffjKeyBalanceSheetNonCurrentDeferredRevenue = []byte("non_current_deferred_revenue")

var ffjKeyBalanceSheetNonCurrentDeferredTaxesLiabilities = []byte("non_current_deferred_taxes_liabilities")

var ffjKeyBalanceSheetNumberOfShareHolders = []byte("number_of_share_holders")

var ffjKeyBalanceSheetOrdinarySharesNumber = []byte("ordinary_shares_number")

var ffjKeyBalanceSheetOtherCurrentAssets = []byte("other_current_assets")

var ffjKeyBalanceSheetOtherCurrentBorrowings = []byte("other_current_borrowings")

var ffjKeyBalanceSheetOtherIntangibleAssets = []byte("other_int64angible_assets")

var ffjKeyBalanceSheetOtherNonCurrentAssets = []byte("other_non_current_assets")

var ffjKeyBalanceSheetOtherNonCurrentLiabilities = []byte("other_non_current_liabilities")

var ffjKeyBalanceSheetOtherReceivables = []byte("other_receivables")

var ffjKeyBalanceSheetOtherShortTermInvestments = []byte("other_short_term_investments")

var ffjKeyBalanceSheetPayables = []byte("payables")

var ffjKeyBalanceSheetPayablesAndAccruedExpenses = []byte("payables_and_accrued_expenses")

var ffjKeyBalanceSheetPeriod = []byte("period")

var ffjKeyBalanceSheetPeriodEndingDate = []byte("period_ending_date")

var ffjKeyBalanceSheetReceivables = []byte("receivables")

var ffjKeyBalanceSheetReportType = []byte("report_type")

var ffjKeyBalanceSheetRetainedEarnings = []byte("retained_earnings")

var ffjKeyBalanceSheetShareIssued = []byte("share_issued")

var ffjKeyBalanceSheetStockholdersEquity = []byte("stockholders_equity")

var ffjKeyBalanceSheetTangibleBookValue = []byte("tangible_book_value")

var ffjKeyBalanceSheetTotalAssets = []byte("total_assets")

var ffjKeyBalanceSheetTotalCapitalization = []byte("total_capitalization")

var ffjKeyBalanceSheetTotalDebt = []byte("total_debt")

var ffjKeyBalanceSheetTotalEquity = []byte("total_equity")

var ffjKeyBalanceSheetTotalEquityGrossMinorityInterest = []byte("total_equity_gross_minority_int64erest")

var ffjKeyBalanceSheetTotalLiabilities = []byte("total_liabilities")

var ffjKeyBalanceSheetTotalLiabilitiesNetMinorityInterest = []byte("total_liabilities_net_minority_int64erest")

var ffjKeyBalanceSheetTotalNonCurrentAssets = []byte("total_non_current_assets")

var ffjKeyBalanceSheetTotalNonCurrentLiabilities = []byte("total_non_current_liabilities")

var ffjKeyBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest = []byte("total_non_current_liabilities_net_minority_int64erest")

var ffjKeyBalanceSheetWorkingCapital = []byte("working_capital")

// UnmarshalJSON umarshall json - template of ffjson
func (j *BalanceSheet) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *BalanceSheet) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtBalanceSheetbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtBalanceSheetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyBalanceSheetAccountsPayable, kn) {
						currentKey = ffjtBalanceSheetAccountsPayable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetAccountsReceivable, kn) {
						currentKey = ffjtBalanceSheetAccountsReceivable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetAccumulatedDepreciation, kn) {
						currentKey = ffjtBalanceSheetAccumulatedDepreciation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyBalanceSheetCapitalStock, kn) {
						currentKey = ffjtBalanceSheetCapitalStock
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCashAndCashEquivalents, kn) {
						currentKey = ffjtBalanceSheetCashAndCashEquivalents
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCashCashEquivalentsAndMarketableSecurities, kn) {
						currentKey = ffjtBalanceSheetCashCashEquivalentsAndMarketableSecurities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCommercialPaper, kn) {
						currentKey = ffjtBalanceSheetCommercialPaper
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCommonStock, kn) {
						currentKey = ffjtBalanceSheetCommonStock
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCommonStockEquity, kn) {
						currentKey = ffjtBalanceSheetCommonStockEquity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrencyID, kn) {
						currentKey = ffjtBalanceSheetCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentAccruedExpenses, kn) {
						currentKey = ffjtBalanceSheetCurrentAccruedExpenses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentAssets, kn) {
						currentKey = ffjtBalanceSheetCurrentAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentDebt, kn) {
						currentKey = ffjtBalanceSheetCurrentDebt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentDebtAndCapitalLeaseObligation, kn) {
						currentKey = ffjtBalanceSheetCurrentDebtAndCapitalLeaseObligation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentDeferredLiabilities, kn) {
						currentKey = ffjtBalanceSheetCurrentDeferredLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentDeferredRevenue, kn) {
						currentKey = ffjtBalanceSheetCurrentDeferredRevenue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetCurrentLiabilities, kn) {
						currentKey = ffjtBalanceSheetCurrentLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyBalanceSheetFileDate, kn) {
						currentKey = ffjtBalanceSheetFileDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetFiscalYearEnd, kn) {
						currentKey = ffjtBalanceSheetFiscalYearEnd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyBalanceSheetGainsLossesNotAffectingRetainedEarnings, kn) {
						currentKey = ffjtBalanceSheetGainsLossesNotAffectingRetainedEarnings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetGoodwill, kn) {
						currentKey = ffjtBalanceSheetGoodwill
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetGoodwillAndOtherIntangibleAssets, kn) {
						currentKey = ffjtBalanceSheetGoodwillAndOtherIntangibleAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetGrossPPE, kn) {
						currentKey = ffjtBalanceSheetGrossPPE
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyBalanceSheetInventory, kn) {
						currentKey = ffjtBalanceSheetInventory
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetInvestedCapital, kn) {
						currentKey = ffjtBalanceSheetInvestedCapital
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetInvestmentsAndAdvances, kn) {
						currentKey = ffjtBalanceSheetInvestmentsAndAdvances
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyBalanceSheetLandAndImprovements, kn) {
						currentKey = ffjtBalanceSheetLandAndImprovements
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetLeases, kn) {
						currentKey = ffjtBalanceSheetLeases
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetLongTermDebt, kn) {
						currentKey = ffjtBalanceSheetLongTermDebt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetLongTermDebtAndCapitalLeaseObligation, kn) {
						currentKey = ffjtBalanceSheetLongTermDebtAndCapitalLeaseObligation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyBalanceSheetMachineryFurnitureEquipment, kn) {
						currentKey = ffjtBalanceSheetMachineryFurnitureEquipment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyBalanceSheetNetDebt, kn) {
						currentKey = ffjtBalanceSheetNetDebt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetNetPPE, kn) {
						currentKey = ffjtBalanceSheetNetPPE
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetNetTangibleAssets, kn) {
						currentKey = ffjtBalanceSheetNetTangibleAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetNonCurrentDeferredLiabilities, kn) {
						currentKey = ffjtBalanceSheetNonCurrentDeferredLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetNonCurrentDeferredRevenue, kn) {
						currentKey = ffjtBalanceSheetNonCurrentDeferredRevenue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetNonCurrentDeferredTaxesLiabilities, kn) {
						currentKey = ffjtBalanceSheetNonCurrentDeferredTaxesLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetNumberOfShareHolders, kn) {
						currentKey = ffjtBalanceSheetNumberOfShareHolders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyBalanceSheetOrdinarySharesNumber, kn) {
						currentKey = ffjtBalanceSheetOrdinarySharesNumber
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherCurrentAssets, kn) {
						currentKey = ffjtBalanceSheetOtherCurrentAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherCurrentBorrowings, kn) {
						currentKey = ffjtBalanceSheetOtherCurrentBorrowings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherIntangibleAssets, kn) {
						currentKey = ffjtBalanceSheetOtherIntangibleAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherNonCurrentAssets, kn) {
						currentKey = ffjtBalanceSheetOtherNonCurrentAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherNonCurrentLiabilities, kn) {
						currentKey = ffjtBalanceSheetOtherNonCurrentLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherReceivables, kn) {
						currentKey = ffjtBalanceSheetOtherReceivables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetOtherShortTermInvestments, kn) {
						currentKey = ffjtBalanceSheetOtherShortTermInvestments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyBalanceSheetPayables, kn) {
						currentKey = ffjtBalanceSheetPayables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetPayablesAndAccruedExpenses, kn) {
						currentKey = ffjtBalanceSheetPayablesAndAccruedExpenses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetPeriod, kn) {
						currentKey = ffjtBalanceSheetPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetPeriodEndingDate, kn) {
						currentKey = ffjtBalanceSheetPeriodEndingDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyBalanceSheetReceivables, kn) {
						currentKey = ffjtBalanceSheetReceivables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetReportType, kn) {
						currentKey = ffjtBalanceSheetReportType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetRetainedEarnings, kn) {
						currentKey = ffjtBalanceSheetRetainedEarnings
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyBalanceSheetShareIssued, kn) {
						currentKey = ffjtBalanceSheetShareIssued
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetStockholdersEquity, kn) {
						currentKey = ffjtBalanceSheetStockholdersEquity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyBalanceSheetTangibleBookValue, kn) {
						currentKey = ffjtBalanceSheetTangibleBookValue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalAssets, kn) {
						currentKey = ffjtBalanceSheetTotalAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalCapitalization, kn) {
						currentKey = ffjtBalanceSheetTotalCapitalization
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalDebt, kn) {
						currentKey = ffjtBalanceSheetTotalDebt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalEquity, kn) {
						currentKey = ffjtBalanceSheetTotalEquity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalEquityGrossMinorityInterest, kn) {
						currentKey = ffjtBalanceSheetTotalEquityGrossMinorityInterest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalLiabilities, kn) {
						currentKey = ffjtBalanceSheetTotalLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalLiabilitiesNetMinorityInterest, kn) {
						currentKey = ffjtBalanceSheetTotalLiabilitiesNetMinorityInterest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalNonCurrentAssets, kn) {
						currentKey = ffjtBalanceSheetTotalNonCurrentAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalNonCurrentLiabilities, kn) {
						currentKey = ffjtBalanceSheetTotalNonCurrentLiabilities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest, kn) {
						currentKey = ffjtBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyBalanceSheetWorkingCapital, kn) {
						currentKey = ffjtBalanceSheetWorkingCapital
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetWorkingCapital, kn) {
					currentKey = ffjtBalanceSheetWorkingCapital
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest, kn) {
					currentKey = ffjtBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalNonCurrentLiabilities, kn) {
					currentKey = ffjtBalanceSheetTotalNonCurrentLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalNonCurrentAssets, kn) {
					currentKey = ffjtBalanceSheetTotalNonCurrentAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalLiabilitiesNetMinorityInterest, kn) {
					currentKey = ffjtBalanceSheetTotalLiabilitiesNetMinorityInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalLiabilities, kn) {
					currentKey = ffjtBalanceSheetTotalLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalEquityGrossMinorityInterest, kn) {
					currentKey = ffjtBalanceSheetTotalEquityGrossMinorityInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetTotalEquity, kn) {
					currentKey = ffjtBalanceSheetTotalEquity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetTotalDebt, kn) {
					currentKey = ffjtBalanceSheetTotalDebt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetTotalCapitalization, kn) {
					currentKey = ffjtBalanceSheetTotalCapitalization
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTotalAssets, kn) {
					currentKey = ffjtBalanceSheetTotalAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetTangibleBookValue, kn) {
					currentKey = ffjtBalanceSheetTangibleBookValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetStockholdersEquity, kn) {
					currentKey = ffjtBalanceSheetStockholdersEquity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetShareIssued, kn) {
					currentKey = ffjtBalanceSheetShareIssued
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetRetainedEarnings, kn) {
					currentKey = ffjtBalanceSheetRetainedEarnings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetReportType, kn) {
					currentKey = ffjtBalanceSheetReportType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetReceivables, kn) {
					currentKey = ffjtBalanceSheetReceivables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetPeriodEndingDate, kn) {
					currentKey = ffjtBalanceSheetPeriodEndingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyBalanceSheetPeriod, kn) {
					currentKey = ffjtBalanceSheetPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetPayablesAndAccruedExpenses, kn) {
					currentKey = ffjtBalanceSheetPayablesAndAccruedExpenses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetPayables, kn) {
					currentKey = ffjtBalanceSheetPayables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherShortTermInvestments, kn) {
					currentKey = ffjtBalanceSheetOtherShortTermInvestments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherReceivables, kn) {
					currentKey = ffjtBalanceSheetOtherReceivables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherNonCurrentLiabilities, kn) {
					currentKey = ffjtBalanceSheetOtherNonCurrentLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherNonCurrentAssets, kn) {
					currentKey = ffjtBalanceSheetOtherNonCurrentAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherIntangibleAssets, kn) {
					currentKey = ffjtBalanceSheetOtherIntangibleAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherCurrentBorrowings, kn) {
					currentKey = ffjtBalanceSheetOtherCurrentBorrowings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOtherCurrentAssets, kn) {
					currentKey = ffjtBalanceSheetOtherCurrentAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetOrdinarySharesNumber, kn) {
					currentKey = ffjtBalanceSheetOrdinarySharesNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetNumberOfShareHolders, kn) {
					currentKey = ffjtBalanceSheetNumberOfShareHolders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetNonCurrentDeferredTaxesLiabilities, kn) {
					currentKey = ffjtBalanceSheetNonCurrentDeferredTaxesLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetNonCurrentDeferredRevenue, kn) {
					currentKey = ffjtBalanceSheetNonCurrentDeferredRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetNonCurrentDeferredLiabilities, kn) {
					currentKey = ffjtBalanceSheetNonCurrentDeferredLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetNetTangibleAssets, kn) {
					currentKey = ffjtBalanceSheetNetTangibleAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetNetPPE, kn) {
					currentKey = ffjtBalanceSheetNetPPE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetNetDebt, kn) {
					currentKey = ffjtBalanceSheetNetDebt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetMachineryFurnitureEquipment, kn) {
					currentKey = ffjtBalanceSheetMachineryFurnitureEquipment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetLongTermDebtAndCapitalLeaseObligation, kn) {
					currentKey = ffjtBalanceSheetLongTermDebtAndCapitalLeaseObligation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetLongTermDebt, kn) {
					currentKey = ffjtBalanceSheetLongTermDebt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetLeases, kn) {
					currentKey = ffjtBalanceSheetLeases
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetLandAndImprovements, kn) {
					currentKey = ffjtBalanceSheetLandAndImprovements
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetInvestmentsAndAdvances, kn) {
					currentKey = ffjtBalanceSheetInvestmentsAndAdvances
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetInvestedCapital, kn) {
					currentKey = ffjtBalanceSheetInvestedCapital
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyBalanceSheetInventory, kn) {
					currentKey = ffjtBalanceSheetInventory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetGrossPPE, kn) {
					currentKey = ffjtBalanceSheetGrossPPE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetGoodwillAndOtherIntangibleAssets, kn) {
					currentKey = ffjtBalanceSheetGoodwillAndOtherIntangibleAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyBalanceSheetGoodwill, kn) {
					currentKey = ffjtBalanceSheetGoodwill
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetGainsLossesNotAffectingRetainedEarnings, kn) {
					currentKey = ffjtBalanceSheetGainsLossesNotAffectingRetainedEarnings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetFiscalYearEnd, kn) {
					currentKey = ffjtBalanceSheetFiscalYearEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetFileDate, kn) {
					currentKey = ffjtBalanceSheetFileDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCurrentLiabilities, kn) {
					currentKey = ffjtBalanceSheetCurrentLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetCurrentDeferredRevenue, kn) {
					currentKey = ffjtBalanceSheetCurrentDeferredRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCurrentDeferredLiabilities, kn) {
					currentKey = ffjtBalanceSheetCurrentDeferredLiabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCurrentDebtAndCapitalLeaseObligation, kn) {
					currentKey = ffjtBalanceSheetCurrentDebtAndCapitalLeaseObligation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetCurrentDebt, kn) {
					currentKey = ffjtBalanceSheetCurrentDebt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCurrentAssets, kn) {
					currentKey = ffjtBalanceSheetCurrentAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCurrentAccruedExpenses, kn) {
					currentKey = ffjtBalanceSheetCurrentAccruedExpenses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetCurrencyID, kn) {
					currentKey = ffjtBalanceSheetCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCommonStockEquity, kn) {
					currentKey = ffjtBalanceSheetCommonStockEquity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCommonStock, kn) {
					currentKey = ffjtBalanceSheetCommonStock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetCommercialPaper, kn) {
					currentKey = ffjtBalanceSheetCommercialPaper
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCashCashEquivalentsAndMarketableSecurities, kn) {
					currentKey = ffjtBalanceSheetCashCashEquivalentsAndMarketableSecurities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCashAndCashEquivalents, kn) {
					currentKey = ffjtBalanceSheetCashAndCashEquivalents
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetCapitalStock, kn) {
					currentKey = ffjtBalanceSheetCapitalStock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyBalanceSheetAccumulatedDepreciation, kn) {
					currentKey = ffjtBalanceSheetAccumulatedDepreciation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetAccountsReceivable, kn) {
					currentKey = ffjtBalanceSheetAccountsReceivable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyBalanceSheetAccountsPayable, kn) {
					currentKey = ffjtBalanceSheetAccountsPayable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtBalanceSheetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtBalanceSheetAccountsPayable:
					goto handle_AccountsPayable

				case ffjtBalanceSheetAccountsReceivable:
					goto handle_AccountsReceivable

				case ffjtBalanceSheetAccumulatedDepreciation:
					goto handle_AccumulatedDepreciation

				case ffjtBalanceSheetCapitalStock:
					goto handle_CapitalStock

				case ffjtBalanceSheetCashAndCashEquivalents:
					goto handle_CashAndCashEquivalents

				case ffjtBalanceSheetCashCashEquivalentsAndMarketableSecurities:
					goto handle_CashCashEquivalentsAndMarketableSecurities

				case ffjtBalanceSheetCommercialPaper:
					goto handle_CommercialPaper

				case ffjtBalanceSheetCommonStock:
					goto handle_CommonStock

				case ffjtBalanceSheetCommonStockEquity:
					goto handle_CommonStockEquity

				case ffjtBalanceSheetCurrencyID:
					goto handle_CurrencyID

				case ffjtBalanceSheetCurrentAccruedExpenses:
					goto handle_CurrentAccruedExpenses

				case ffjtBalanceSheetCurrentAssets:
					goto handle_CurrentAssets

				case ffjtBalanceSheetCurrentDebt:
					goto handle_CurrentDebt

				case ffjtBalanceSheetCurrentDebtAndCapitalLeaseObligation:
					goto handle_CurrentDebtAndCapitalLeaseObligation

				case ffjtBalanceSheetCurrentDeferredLiabilities:
					goto handle_CurrentDeferredLiabilities

				case ffjtBalanceSheetCurrentDeferredRevenue:
					goto handle_CurrentDeferredRevenue

				case ffjtBalanceSheetCurrentLiabilities:
					goto handle_CurrentLiabilities

				case ffjtBalanceSheetFileDate:
					goto handle_FileDate

				case ffjtBalanceSheetFiscalYearEnd:
					goto handle_FiscalYearEnd

				case ffjtBalanceSheetGainsLossesNotAffectingRetainedEarnings:
					goto handle_GainsLossesNotAffectingRetainedEarnings

				case ffjtBalanceSheetGoodwill:
					goto handle_Goodwill

				case ffjtBalanceSheetGoodwillAndOtherIntangibleAssets:
					goto handle_GoodwillAndOtherIntangibleAssets

				case ffjtBalanceSheetGrossPPE:
					goto handle_GrossPPE

				case ffjtBalanceSheetInventory:
					goto handle_Inventory

				case ffjtBalanceSheetInvestedCapital:
					goto handle_InvestedCapital

				case ffjtBalanceSheetInvestmentsAndAdvances:
					goto handle_InvestmentsAndAdvances

				case ffjtBalanceSheetLandAndImprovements:
					goto handle_LandAndImprovements

				case ffjtBalanceSheetLeases:
					goto handle_Leases

				case ffjtBalanceSheetLongTermDebt:
					goto handle_LongTermDebt

				case ffjtBalanceSheetLongTermDebtAndCapitalLeaseObligation:
					goto handle_LongTermDebtAndCapitalLeaseObligation

				case ffjtBalanceSheetMachineryFurnitureEquipment:
					goto handle_MachineryFurnitureEquipment

				case ffjtBalanceSheetNetDebt:
					goto handle_NetDebt

				case ffjtBalanceSheetNetPPE:
					goto handle_NetPPE

				case ffjtBalanceSheetNetTangibleAssets:
					goto handle_NetTangibleAssets

				case ffjtBalanceSheetNonCurrentDeferredLiabilities:
					goto handle_NonCurrentDeferredLiabilities

				case ffjtBalanceSheetNonCurrentDeferredRevenue:
					goto handle_NonCurrentDeferredRevenue

				case ffjtBalanceSheetNonCurrentDeferredTaxesLiabilities:
					goto handle_NonCurrentDeferredTaxesLiabilities

				case ffjtBalanceSheetNumberOfShareHolders:
					goto handle_NumberOfShareHolders

				case ffjtBalanceSheetOrdinarySharesNumber:
					goto handle_OrdinarySharesNumber

				case ffjtBalanceSheetOtherCurrentAssets:
					goto handle_OtherCurrentAssets

				case ffjtBalanceSheetOtherCurrentBorrowings:
					goto handle_OtherCurrentBorrowings

				case ffjtBalanceSheetOtherIntangibleAssets:
					goto handle_OtherIntangibleAssets

				case ffjtBalanceSheetOtherNonCurrentAssets:
					goto handle_OtherNonCurrentAssets

				case ffjtBalanceSheetOtherNonCurrentLiabilities:
					goto handle_OtherNonCurrentLiabilities

				case ffjtBalanceSheetOtherReceivables:
					goto handle_OtherReceivables

				case ffjtBalanceSheetOtherShortTermInvestments:
					goto handle_OtherShortTermInvestments

				case ffjtBalanceSheetPayables:
					goto handle_Payables

				case ffjtBalanceSheetPayablesAndAccruedExpenses:
					goto handle_PayablesAndAccruedExpenses

				case ffjtBalanceSheetPeriod:
					goto handle_Period

				case ffjtBalanceSheetPeriodEndingDate:
					goto handle_PeriodEndingDate

				case ffjtBalanceSheetReceivables:
					goto handle_Receivables

				case ffjtBalanceSheetReportType:
					goto handle_ReportType

				case ffjtBalanceSheetRetainedEarnings:
					goto handle_RetainedEarnings

				case ffjtBalanceSheetShareIssued:
					goto handle_ShareIssued

				case ffjtBalanceSheetStockholdersEquity:
					goto handle_StockholdersEquity

				case ffjtBalanceSheetTangibleBookValue:
					goto handle_TangibleBookValue

				case ffjtBalanceSheetTotalAssets:
					goto handle_TotalAssets

				case ffjtBalanceSheetTotalCapitalization:
					goto handle_TotalCapitalization

				case ffjtBalanceSheetTotalDebt:
					goto handle_TotalDebt

				case ffjtBalanceSheetTotalEquity:
					goto handle_TotalEquity

				case ffjtBalanceSheetTotalEquityGrossMinorityInterest:
					goto handle_TotalEquityGrossMinorityInterest

				case ffjtBalanceSheetTotalLiabilities:
					goto handle_TotalLiabilities

				case ffjtBalanceSheetTotalLiabilitiesNetMinorityInterest:
					goto handle_TotalLiabilitiesNetMinorityInterest

				case ffjtBalanceSheetTotalNonCurrentAssets:
					goto handle_TotalNonCurrentAssets

				case ffjtBalanceSheetTotalNonCurrentLiabilities:
					goto handle_TotalNonCurrentLiabilities

				case ffjtBalanceSheetTotalNonCurrentLiabilitiesNetMinorityInterest:
					goto handle_TotalNonCurrentLiabilitiesNetMinorityInterest

				case ffjtBalanceSheetWorkingCapital:
					goto handle_WorkingCapital

				case ffjtBalanceSheetnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccountsPayable:

	/* handler: j.AccountsPayable type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.AccountsPayable = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.AccountsPayable = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccountsReceivable:

	/* handler: j.AccountsReceivable type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.AccountsReceivable = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.AccountsReceivable = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccumulatedDepreciation:

	/* handler: j.AccumulatedDepreciation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.AccumulatedDepreciation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.AccumulatedDepreciation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CapitalStock:

	/* handler: j.CapitalStock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CapitalStock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CapitalStock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashAndCashEquivalents:

	/* handler: j.CashAndCashEquivalents type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashAndCashEquivalents = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashAndCashEquivalents = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashCashEquivalentsAndMarketableSecurities:

	/* handler: j.CashCashEquivalentsAndMarketableSecurities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashCashEquivalentsAndMarketableSecurities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashCashEquivalentsAndMarketableSecurities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommercialPaper:

	/* handler: j.CommercialPaper type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CommercialPaper = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CommercialPaper = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommonStock:

	/* handler: j.CommonStock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CommonStock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CommonStock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommonStockEquity:

	/* handler: j.CommonStockEquity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CommonStockEquity = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CommonStockEquity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentAccruedExpenses:

	/* handler: j.CurrentAccruedExpenses type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentAccruedExpenses = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentAccruedExpenses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentAssets:

	/* handler: j.CurrentAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentDebt:

	/* handler: j.CurrentDebt type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentDebt = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentDebt = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentDebtAndCapitalLeaseObligation:

	/* handler: j.CurrentDebtAndCapitalLeaseObligation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentDebtAndCapitalLeaseObligation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentDebtAndCapitalLeaseObligation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentDeferredLiabilities:

	/* handler: j.CurrentDeferredLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentDeferredLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentDeferredLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentDeferredRevenue:

	/* handler: j.CurrentDeferredRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentDeferredRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentDeferredRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentLiabilities:

	/* handler: j.CurrentLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileDate:

	/* handler: j.FileDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FileDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FileDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FiscalYearEnd:

	/* handler: j.FiscalYearEnd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FiscalYearEnd = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FiscalYearEnd = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GainsLossesNotAffectingRetainedEarnings:

	/* handler: j.GainsLossesNotAffectingRetainedEarnings type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GainsLossesNotAffectingRetainedEarnings = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GainsLossesNotAffectingRetainedEarnings = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Goodwill:

	/* handler: j.Goodwill type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Goodwill = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Goodwill = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GoodwillAndOtherIntangibleAssets:

	/* handler: j.GoodwillAndOtherIntangibleAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GoodwillAndOtherIntangibleAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GoodwillAndOtherIntangibleAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrossPPE:

	/* handler: j.GrossPPE type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GrossPPE = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GrossPPE = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inventory:

	/* handler: j.Inventory type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Inventory = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Inventory = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvestedCapital:

	/* handler: j.InvestedCapital type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InvestedCapital = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InvestedCapital = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvestmentsAndAdvances:

	/* handler: j.InvestmentsAndAdvances type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InvestmentsAndAdvances = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InvestmentsAndAdvances = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LandAndImprovements:

	/* handler: j.LandAndImprovements type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.LandAndImprovements = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.LandAndImprovements = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Leases:

	/* handler: j.Leases type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Leases = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Leases = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LongTermDebt:

	/* handler: j.LongTermDebt type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.LongTermDebt = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.LongTermDebt = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LongTermDebtAndCapitalLeaseObligation:

	/* handler: j.LongTermDebtAndCapitalLeaseObligation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.LongTermDebtAndCapitalLeaseObligation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.LongTermDebtAndCapitalLeaseObligation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MachineryFurnitureEquipment:

	/* handler: j.MachineryFurnitureEquipment type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MachineryFurnitureEquipment = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.MachineryFurnitureEquipment = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetDebt:

	/* handler: j.NetDebt type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetDebt = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetDebt = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetPPE:

	/* handler: j.NetPPE type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetPPE = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetPPE = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTangibleAssets:

	/* handler: j.NetTangibleAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetTangibleAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetTangibleAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonCurrentDeferredLiabilities:

	/* handler: j.NonCurrentDeferredLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonCurrentDeferredLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonCurrentDeferredLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonCurrentDeferredRevenue:

	/* handler: j.NonCurrentDeferredRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonCurrentDeferredRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonCurrentDeferredRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonCurrentDeferredTaxesLiabilities:

	/* handler: j.NonCurrentDeferredTaxesLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonCurrentDeferredTaxesLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonCurrentDeferredTaxesLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfShareHolders:

	/* handler: j.NumberOfShareHolders type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NumberOfShareHolders = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.NumberOfShareHolders = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrdinarySharesNumber:

	/* handler: j.OrdinarySharesNumber type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OrdinarySharesNumber = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OrdinarySharesNumber = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherCurrentAssets:

	/* handler: j.OtherCurrentAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherCurrentAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherCurrentAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherCurrentBorrowings:

	/* handler: j.OtherCurrentBorrowings type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherCurrentBorrowings = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherCurrentBorrowings = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherIntangibleAssets:

	/* handler: j.OtherIntangibleAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherIntangibleAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherIntangibleAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherNonCurrentAssets:

	/* handler: j.OtherNonCurrentAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherNonCurrentAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherNonCurrentAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherNonCurrentLiabilities:

	/* handler: j.OtherNonCurrentLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherNonCurrentLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherNonCurrentLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherReceivables:

	/* handler: j.OtherReceivables type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherReceivables = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherReceivables = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherShortTermInvestments:

	/* handler: j.OtherShortTermInvestments type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherShortTermInvestments = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherShortTermInvestments = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Payables:

	/* handler: j.Payables type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Payables = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Payables = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PayablesAndAccruedExpenses:

	/* handler: j.PayablesAndAccruedExpenses type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PayablesAndAccruedExpenses = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PayablesAndAccruedExpenses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PeriodEndingDate:

	/* handler: j.PeriodEndingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.PeriodEndingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.PeriodEndingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Receivables:

	/* handler: j.Receivables type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Receivables = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Receivables = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReportType:

	/* handler: j.ReportType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ReportType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ReportType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RetainedEarnings:

	/* handler: j.RetainedEarnings type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.RetainedEarnings = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.RetainedEarnings = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareIssued:

	/* handler: j.ShareIssued type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareIssued = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ShareIssued = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockholdersEquity:

	/* handler: j.StockholdersEquity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StockholdersEquity = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.StockholdersEquity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TangibleBookValue:

	/* handler: j.TangibleBookValue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TangibleBookValue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TangibleBookValue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAssets:

	/* handler: j.TotalAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalCapitalization:

	/* handler: j.TotalCapitalization type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalCapitalization = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalCapitalization = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalDebt:

	/* handler: j.TotalDebt type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalDebt = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalDebt = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalEquity:

	/* handler: j.TotalEquity type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalEquity = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalEquity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalEquityGrossMinorityInterest:

	/* handler: j.TotalEquityGrossMinorityInterest type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalEquityGrossMinorityInterest = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalEquityGrossMinorityInterest = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalLiabilities:

	/* handler: j.TotalLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalLiabilitiesNetMinorityInterest:

	/* handler: j.TotalLiabilitiesNetMinorityInterest type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalLiabilitiesNetMinorityInterest = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalLiabilitiesNetMinorityInterest = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalNonCurrentAssets:

	/* handler: j.TotalNonCurrentAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalNonCurrentAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalNonCurrentAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalNonCurrentLiabilities:

	/* handler: j.TotalNonCurrentLiabilities type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalNonCurrentLiabilities = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalNonCurrentLiabilities = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalNonCurrentLiabilitiesNetMinorityInterest:

	/* handler: j.TotalNonCurrentLiabilitiesNetMinorityInterest type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalNonCurrentLiabilitiesNetMinorityInterest = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalNonCurrentLiabilitiesNetMinorityInterest = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkingCapital:

	/* handler: j.WorkingCapital type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.WorkingCapital = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.WorkingCapital = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CashDividend) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CashDividend) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.CashAmount != nil {
		buf.WriteString(`{"cash_amount":`)
		fflib.AppendFloat(buf, float64(*j.CashAmount), 'g', -1, 64)
	} else {
		buf.WriteString(`{"cash_amount":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_i_d":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_i_d":null`)
	}
	if j.DeclarationDate != nil {
		buf.WriteString(`,"declaration_date":`)
		fflib.WriteJsonString(buf, string(*j.DeclarationDate))
	} else {
		buf.WriteString(`,"declaration_date":null`)
	}
	if j.DividendType != nil {
		buf.WriteString(`,"dividend_type":`)
		fflib.WriteJsonString(buf, string(*j.DividendType))
	} else {
		buf.WriteString(`,"dividend_type":null`)
	}
	if j.ExDate != nil {
		buf.WriteString(`,"ex_date":`)
		fflib.WriteJsonString(buf, string(*j.ExDate))
	} else {
		buf.WriteString(`,"ex_date":null`)
	}
	if j.Frequency != nil {
		buf.WriteString(`,"frequency":`)
		fflib.FormatBits2(buf, uint64(*j.Frequency), 10, *j.Frequency < 0)
	} else {
		buf.WriteString(`,"frequency":null`)
	}
	if j.PayDate != nil {
		buf.WriteString(`,"pay_date":`)
		fflib.WriteJsonString(buf, string(*j.PayDate))
	} else {
		buf.WriteString(`,"pay_date":null`)
	}
	if j.RecordDate != nil {
		buf.WriteString(`,"record_date":`)
		fflib.WriteJsonString(buf, string(*j.RecordDate))
	} else {
		buf.WriteString(`,"record_date":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCashDividendbase = iota
	ffjtCashDividendnosuchkey

	ffjtCashDividendCashAmount

	ffjtCashDividendCurrencyID

	ffjtCashDividendDeclarationDate

	ffjtCashDividendDividendType

	ffjtCashDividendExDate

	ffjtCashDividendFrequency

	ffjtCashDividendPayDate

	ffjtCashDividendRecordDate

	ffjtCashDividendShareClassID
)

var ffjKeyCashDividendCashAmount = []byte("cash_amount")

var ffjKeyCashDividendCurrencyID = []byte("currency_i_d")

var ffjKeyCashDividendDeclarationDate = []byte("declaration_date")

var ffjKeyCashDividendDividendType = []byte("dividend_type")

var ffjKeyCashDividendExDate = []byte("ex_date")

var ffjKeyCashDividendFrequency = []byte("frequency")

var ffjKeyCashDividendPayDate = []byte("pay_date")

var ffjKeyCashDividendRecordDate = []byte("record_date")

var ffjKeyCashDividendShareClassID = []byte("share_class_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CashDividend) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CashDividend) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCashDividendbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCashDividendnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyCashDividendCashAmount, kn) {
						currentKey = ffjtCashDividendCashAmount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashDividendCurrencyID, kn) {
						currentKey = ffjtCashDividendCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyCashDividendDeclarationDate, kn) {
						currentKey = ffjtCashDividendDeclarationDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashDividendDividendType, kn) {
						currentKey = ffjtCashDividendDividendType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyCashDividendExDate, kn) {
						currentKey = ffjtCashDividendExDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyCashDividendFrequency, kn) {
						currentKey = ffjtCashDividendFrequency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyCashDividendPayDate, kn) {
						currentKey = ffjtCashDividendPayDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyCashDividendRecordDate, kn) {
						currentKey = ffjtCashDividendRecordDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyCashDividendShareClassID, kn) {
						currentKey = ffjtCashDividendShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyCashDividendShareClassID, kn) {
					currentKey = ffjtCashDividendShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashDividendRecordDate, kn) {
					currentKey = ffjtCashDividendRecordDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashDividendPayDate, kn) {
					currentKey = ffjtCashDividendPayDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCashDividendFrequency, kn) {
					currentKey = ffjtCashDividendFrequency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashDividendExDate, kn) {
					currentKey = ffjtCashDividendExDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashDividendDividendType, kn) {
					currentKey = ffjtCashDividendDividendType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashDividendDeclarationDate, kn) {
					currentKey = ffjtCashDividendDeclarationDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashDividendCurrencyID, kn) {
					currentKey = ffjtCashDividendCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashDividendCashAmount, kn) {
					currentKey = ffjtCashDividendCashAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCashDividendnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCashDividendCashAmount:
					goto handle_CashAmount

				case ffjtCashDividendCurrencyID:
					goto handle_CurrencyID

				case ffjtCashDividendDeclarationDate:
					goto handle_DeclarationDate

				case ffjtCashDividendDividendType:
					goto handle_DividendType

				case ffjtCashDividendExDate:
					goto handle_ExDate

				case ffjtCashDividendFrequency:
					goto handle_Frequency

				case ffjtCashDividendPayDate:
					goto handle_PayDate

				case ffjtCashDividendRecordDate:
					goto handle_RecordDate

				case ffjtCashDividendShareClassID:
					goto handle_ShareClassID

				case ffjtCashDividendnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CashAmount:

	/* handler: j.CashAmount type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashAmount = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashAmount = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeclarationDate:

	/* handler: j.DeclarationDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.DeclarationDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.DeclarationDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DividendType:

	/* handler: j.DividendType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.DividendType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.DividendType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExDate:

	/* handler: j.ExDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ExDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ExDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Frequency:

	/* handler: j.Frequency type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Frequency = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.Frequency = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PayDate:

	/* handler: j.PayDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.PayDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.PayDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RecordDate:

	/* handler: j.RecordDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.RecordDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.RecordDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CashFlowStatement) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CashFlowStatement) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.BeginningCashPosition != nil {
		buf.WriteString(`{"beginning_cash_position":`)
		fflib.AppendFloat(buf, float64(*j.BeginningCashPosition), 'g', -1, 64)
	} else {
		buf.WriteString(`{"beginning_cash_position":null`)
	}
	if j.CapitalExpenditure != nil {
		buf.WriteString(`,"capital_expenditure":`)
		fflib.AppendFloat(buf, float64(*j.CapitalExpenditure), 'g', -1, 64)
	} else {
		buf.WriteString(`,"capital_expenditure":null`)
	}
	if j.CashDividendsPaid != nil {
		buf.WriteString(`,"cash_dividends_paid":`)
		fflib.AppendFloat(buf, float64(*j.CashDividendsPaid), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cash_dividends_paid":null`)
	}
	if j.ChangeInAccountPayable != nil {
		buf.WriteString(`,"change_in_account_payable":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInAccountPayable), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_account_payable":null`)
	}
	if j.ChangeInInventory != nil {
		buf.WriteString(`,"change_in_inventory":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInInventory), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_inventory":null`)
	}
	if j.ChangeInOtherWorkingCapital != nil {
		buf.WriteString(`,"change_in_other_working_capital":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInOtherWorkingCapital), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_other_working_capital":null`)
	}
	if j.ChangeInPayable != nil {
		buf.WriteString(`,"change_in_payable":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInPayable), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_payable":null`)
	}
	if j.ChangeInPayablesAndAccruedExpense != nil {
		buf.WriteString(`,"change_in_payables_and_accrued_expense":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInPayablesAndAccruedExpense), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_payables_and_accrued_expense":null`)
	}
	if j.ChangeInReceivables != nil {
		buf.WriteString(`,"change_in_receivables":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInReceivables), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_receivables":null`)
	}
	if j.ChangeInWorkingCapital != nil {
		buf.WriteString(`,"change_in_working_capital":`)
		fflib.AppendFloat(buf, float64(*j.ChangeInWorkingCapital), 'g', -1, 64)
	} else {
		buf.WriteString(`,"change_in_working_capital":null`)
	}
	if j.ChangesInAccountReceivables != nil {
		buf.WriteString(`,"changes_in_account_receivables":`)
		fflib.AppendFloat(buf, float64(*j.ChangesInAccountReceivables), 'g', -1, 64)
	} else {
		buf.WriteString(`,"changes_in_account_receivables":null`)
	}
	if j.ChangesInCash != nil {
		buf.WriteString(`,"changes_in_cash":`)
		fflib.AppendFloat(buf, float64(*j.ChangesInCash), 'g', -1, 64)
	} else {
		buf.WriteString(`,"changes_in_cash":null`)
	}
	if j.CommonStockIssuance != nil {
		buf.WriteString(`,"common_stock_issuance":`)
		fflib.AppendFloat(buf, float64(*j.CommonStockIssuance), 'g', -1, 64)
	} else {
		buf.WriteString(`,"common_stock_issuance":null`)
	}
	if j.CommonStockPayments != nil {
		buf.WriteString(`,"common_stock_payments":`)
		fflib.AppendFloat(buf, float64(*j.CommonStockPayments), 'g', -1, 64)
	} else {
		buf.WriteString(`,"common_stock_payments":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_id":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_id":null`)
	}
	if j.DeferredIncomeTax != nil {
		buf.WriteString(`,"deferred_income_tax":`)
		fflib.AppendFloat(buf, float64(*j.DeferredIncomeTax), 'g', -1, 64)
	} else {
		buf.WriteString(`,"deferred_income_tax":null`)
	}
	if j.DeferredTax != nil {
		buf.WriteString(`,"deferred_tax":`)
		fflib.AppendFloat(buf, float64(*j.DeferredTax), 'g', -1, 64)
	} else {
		buf.WriteString(`,"deferred_tax":null`)
	}
	if j.DepreciationAmortizationDepletion != nil {
		buf.WriteString(`,"depreciation_amortization_depletion":`)
		fflib.AppendFloat(buf, float64(*j.DepreciationAmortizationDepletion), 'g', -1, 64)
	} else {
		buf.WriteString(`,"depreciation_amortization_depletion":null`)
	}
	if j.DepreciationAndAmortization != nil {
		buf.WriteString(`,"depreciation_and_amortization":`)
		fflib.AppendFloat(buf, float64(*j.DepreciationAndAmortization), 'g', -1, 64)
	} else {
		buf.WriteString(`,"depreciation_and_amortization":null`)
	}
	if j.DomesticSales != nil {
		buf.WriteString(`,"domestic_sales":`)
		fflib.AppendFloat(buf, float64(*j.DomesticSales), 'g', -1, 64)
	} else {
		buf.WriteString(`,"domestic_sales":null`)
	}
	if j.EndCashPosition != nil {
		buf.WriteString(`,"end_cash_position":`)
		fflib.AppendFloat(buf, float64(*j.EndCashPosition), 'g', -1, 64)
	} else {
		buf.WriteString(`,"end_cash_position":null`)
	}
	if j.FileDate != nil {
		buf.WriteString(`,"file_date":`)
		fflib.WriteJsonString(buf, string(*j.FileDate))
	} else {
		buf.WriteString(`,"file_date":null`)
	}
	if j.FinancingCashFlow != nil {
		buf.WriteString(`,"financing_cash_flow":`)
		fflib.AppendFloat(buf, float64(*j.FinancingCashFlow), 'g', -1, 64)
	} else {
		buf.WriteString(`,"financing_cash_flow":null`)
	}
	if j.FiscalYearEnd != nil {
		buf.WriteString(`,"fiscal_year_end":`)
		fflib.WriteJsonString(buf, string(*j.FiscalYearEnd))
	} else {
		buf.WriteString(`,"fiscal_year_end":null`)
	}
	if j.ForeignSales != nil {
		buf.WriteString(`,"foreign_sales":`)
		fflib.AppendFloat(buf, float64(*j.ForeignSales), 'g', -1, 64)
	} else {
		buf.WriteString(`,"foreign_sales":null`)
	}
	if j.FreeCashFlow != nil {
		buf.WriteString(`,"free_cash_flow":`)
		fflib.AppendFloat(buf, float64(*j.FreeCashFlow), 'g', -1, 64)
	} else {
		buf.WriteString(`,"free_cash_flow":null`)
	}
	if j.IncomeTaxPaidSupplementalData != nil {
		buf.WriteString(`,"income_tax_paid_supplemental_data":`)
		fflib.AppendFloat(buf, float64(*j.IncomeTaxPaidSupplementalData), 'g', -1, 64)
	} else {
		buf.WriteString(`,"income_tax_paid_supplemental_data":null`)
	}
	if j.InterestPaidSupplementalData != nil {
		buf.WriteString(`,"int64erest_paid_supplemental_data":`)
		fflib.AppendFloat(buf, float64(*j.InterestPaidSupplementalData), 'g', -1, 64)
	} else {
		buf.WriteString(`,"int64erest_paid_supplemental_data":null`)
	}
	if j.InvestingCashFlow != nil {
		buf.WriteString(`,"investing_cash_flow":`)
		fflib.AppendFloat(buf, float64(*j.InvestingCashFlow), 'g', -1, 64)
	} else {
		buf.WriteString(`,"investing_cash_flow":null`)
	}
	if j.IssuanceOfCapitalStock != nil {
		buf.WriteString(`,"issuance_of_capital_stock":`)
		fflib.AppendFloat(buf, float64(*j.IssuanceOfCapitalStock), 'g', -1, 64)
	} else {
		buf.WriteString(`,"issuance_of_capital_stock":null`)
	}
	if j.NetBusinessPurchaseAndSale != nil {
		buf.WriteString(`,"net_business_purchase_and_sale":`)
		fflib.AppendFloat(buf, float64(*j.NetBusinessPurchaseAndSale), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_business_purchase_and_sale":null`)
	}
	if j.NetCommonStockIssuance != nil {
		buf.WriteString(`,"net_common_stock_issuance":`)
		fflib.AppendFloat(buf, float64(*j.NetCommonStockIssuance), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_common_stock_issuance":null`)
	}
	if j.NetIncome != nil {
		buf.WriteString(`,"net_income":`)
		fflib.AppendFloat(buf, float64(*j.NetIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income":null`)
	}
	if j.NetIncomeFromContinuingOperations != nil {
		buf.WriteString(`,"net_income_from_continuing_operations":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeFromContinuingOperations), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_from_continuing_operations":null`)
	}
	if j.NetIntangiblesPurchaseAndSale != nil {
		buf.WriteString(`,"net_int64angibles_purchase_and_sale":`)
		fflib.AppendFloat(buf, float64(*j.NetIntangiblesPurchaseAndSale), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_int64angibles_purchase_and_sale":null`)
	}
	if j.NetInvestmentPurchaseAndSale != nil {
		buf.WriteString(`,"net_investment_purchase_and_sale":`)
		fflib.AppendFloat(buf, float64(*j.NetInvestmentPurchaseAndSale), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_investment_purchase_and_sale":null`)
	}
	if j.NetIssuancePaymentsOfDebt != nil {
		buf.WriteString(`,"net_issuance_payments_of_debt":`)
		fflib.AppendFloat(buf, float64(*j.NetIssuancePaymentsOfDebt), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_issuance_payments_of_debt":null`)
	}
	if j.NetOtherFinancingCharges != nil {
		buf.WriteString(`,"net_other_financing_charges":`)
		fflib.AppendFloat(buf, float64(*j.NetOtherFinancingCharges), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_other_financing_charges":null`)
	}
	if j.NetOtherInvestingChanges != nil {
		buf.WriteString(`,"net_other_investing_changes":`)
		fflib.AppendFloat(buf, float64(*j.NetOtherInvestingChanges), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_other_investing_changes":null`)
	}
	if j.NetPPEPurchaseAndSale != nil {
		buf.WriteString(`,"net_p_p_e_purchase_and_sale":`)
		fflib.AppendFloat(buf, float64(*j.NetPPEPurchaseAndSale), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_p_p_e_purchase_and_sale":null`)
	}
	if j.NetShortTermDebtIssuance != nil {
		buf.WriteString(`,"net_short_term_debt_issuance":`)
		fflib.AppendFloat(buf, float64(*j.NetShortTermDebtIssuance), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_short_term_debt_issuance":null`)
	}
	if j.NumberOfShareHolders != nil {
		buf.WriteString(`,"number_of_share_holders":`)
		fflib.FormatBits2(buf, uint64(*j.NumberOfShareHolders), 10, *j.NumberOfShareHolders < 0)
	} else {
		buf.WriteString(`,"number_of_share_holders":null`)
	}
	if j.OperatingCashFlow != nil {
		buf.WriteString(`,"operating_cash_flow":`)
		fflib.AppendFloat(buf, float64(*j.OperatingCashFlow), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operating_cash_flow":null`)
	}
	if j.OtherNonCashItems != nil {
		buf.WriteString(`,"other_non_cash_items":`)
		fflib.AppendFloat(buf, float64(*j.OtherNonCashItems), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_non_cash_items":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.PeriodEndingDate != nil {
		buf.WriteString(`,"period_ending_date":`)
		fflib.WriteJsonString(buf, string(*j.PeriodEndingDate))
	} else {
		buf.WriteString(`,"period_ending_date":null`)
	}
	if j.PurchaseOfBusiness != nil {
		buf.WriteString(`,"purchase_of_business":`)
		fflib.AppendFloat(buf, float64(*j.PurchaseOfBusiness), 'g', -1, 64)
	} else {
		buf.WriteString(`,"purchase_of_business":null`)
	}
	if j.PurchaseOfIntangibles != nil {
		buf.WriteString(`,"purchase_of_int64angibles":`)
		fflib.AppendFloat(buf, float64(*j.PurchaseOfIntangibles), 'g', -1, 64)
	} else {
		buf.WriteString(`,"purchase_of_int64angibles":null`)
	}
	if j.PurchaseOfInvestment != nil {
		buf.WriteString(`,"purchase_of_investment":`)
		fflib.AppendFloat(buf, float64(*j.PurchaseOfInvestment), 'g', -1, 64)
	} else {
		buf.WriteString(`,"purchase_of_investment":null`)
	}
	if j.PurchaseOfPPE != nil {
		buf.WriteString(`,"purchase_of_p_p_e":`)
		fflib.AppendFloat(buf, float64(*j.PurchaseOfPPE), 'g', -1, 64)
	} else {
		buf.WriteString(`,"purchase_of_p_p_e":null`)
	}
	if j.ReportType != nil {
		buf.WriteString(`,"report_type":`)
		fflib.WriteJsonString(buf, string(*j.ReportType))
	} else {
		buf.WriteString(`,"report_type":null`)
	}
	if j.RepurchaseOfCapitalStock != nil {
		buf.WriteString(`,"repurchase_of_capital_stock":`)
		fflib.AppendFloat(buf, float64(*j.RepurchaseOfCapitalStock), 'g', -1, 64)
	} else {
		buf.WriteString(`,"repurchase_of_capital_stock":null`)
	}
	if j.SaleOfInvestment != nil {
		buf.WriteString(`,"sale_of_investment":`)
		fflib.AppendFloat(buf, float64(*j.SaleOfInvestment), 'g', -1, 64)
	} else {
		buf.WriteString(`,"sale_of_investment":null`)
	}
	if j.StockBasedCompensation != nil {
		buf.WriteString(`,"stock_based_compensation":`)
		fflib.AppendFloat(buf, float64(*j.StockBasedCompensation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"stock_based_compensation":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCashFlowStatementbase = iota
	ffjtCashFlowStatementnosuchkey

	ffjtCashFlowStatementBeginningCashPosition

	ffjtCashFlowStatementCapitalExpenditure

	ffjtCashFlowStatementCashDividendsPaid

	ffjtCashFlowStatementChangeInAccountPayable

	ffjtCashFlowStatementChangeInInventory

	ffjtCashFlowStatementChangeInOtherWorkingCapital

	ffjtCashFlowStatementChangeInPayable

	ffjtCashFlowStatementChangeInPayablesAndAccruedExpense

	ffjtCashFlowStatementChangeInReceivables

	ffjtCashFlowStatementChangeInWorkingCapital

	ffjtCashFlowStatementChangesInAccountReceivables

	ffjtCashFlowStatementChangesInCash

	ffjtCashFlowStatementCommonStockIssuance

	ffjtCashFlowStatementCommonStockPayments

	ffjtCashFlowStatementCurrencyID

	ffjtCashFlowStatementDeferredIncomeTax

	ffjtCashFlowStatementDeferredTax

	ffjtCashFlowStatementDepreciationAmortizationDepletion

	ffjtCashFlowStatementDepreciationAndAmortization

	ffjtCashFlowStatementDomesticSales

	ffjtCashFlowStatementEndCashPosition

	ffjtCashFlowStatementFileDate

	ffjtCashFlowStatementFinancingCashFlow

	ffjtCashFlowStatementFiscalYearEnd

	ffjtCashFlowStatementForeignSales

	ffjtCashFlowStatementFreeCashFlow

	ffjtCashFlowStatementIncomeTaxPaidSupplementalData

	ffjtCashFlowStatementInterestPaidSupplementalData

	ffjtCashFlowStatementInvestingCashFlow

	ffjtCashFlowStatementIssuanceOfCapitalStock

	ffjtCashFlowStatementNetBusinessPurchaseAndSale

	ffjtCashFlowStatementNetCommonStockIssuance

	ffjtCashFlowStatementNetIncome

	ffjtCashFlowStatementNetIncomeFromContinuingOperations

	ffjtCashFlowStatementNetIntangiblesPurchaseAndSale

	ffjtCashFlowStatementNetInvestmentPurchaseAndSale

	ffjtCashFlowStatementNetIssuancePaymentsOfDebt

	ffjtCashFlowStatementNetOtherFinancingCharges

	ffjtCashFlowStatementNetOtherInvestingChanges

	ffjtCashFlowStatementNetPPEPurchaseAndSale

	ffjtCashFlowStatementNetShortTermDebtIssuance

	ffjtCashFlowStatementNumberOfShareHolders

	ffjtCashFlowStatementOperatingCashFlow

	ffjtCashFlowStatementOtherNonCashItems

	ffjtCashFlowStatementPeriod

	ffjtCashFlowStatementPeriodEndingDate

	ffjtCashFlowStatementPurchaseOfBusiness

	ffjtCashFlowStatementPurchaseOfIntangibles

	ffjtCashFlowStatementPurchaseOfInvestment

	ffjtCashFlowStatementPurchaseOfPPE

	ffjtCashFlowStatementReportType

	ffjtCashFlowStatementRepurchaseOfCapitalStock

	ffjtCashFlowStatementSaleOfInvestment

	ffjtCashFlowStatementStockBasedCompensation
)

var ffjKeyCashFlowStatementBeginningCashPosition = []byte("beginning_cash_position")

var ffjKeyCashFlowStatementCapitalExpenditure = []byte("capital_expenditure")

var ffjKeyCashFlowStatementCashDividendsPaid = []byte("cash_dividends_paid")

var ffjKeyCashFlowStatementChangeInAccountPayable = []byte("change_in_account_payable")

var ffjKeyCashFlowStatementChangeInInventory = []byte("change_in_inventory")

var ffjKeyCashFlowStatementChangeInOtherWorkingCapital = []byte("change_in_other_working_capital")

var ffjKeyCashFlowStatementChangeInPayable = []byte("change_in_payable")

var ffjKeyCashFlowStatementChangeInPayablesAndAccruedExpense = []byte("change_in_payables_and_accrued_expense")

var ffjKeyCashFlowStatementChangeInReceivables = []byte("change_in_receivables")

var ffjKeyCashFlowStatementChangeInWorkingCapital = []byte("change_in_working_capital")

var ffjKeyCashFlowStatementChangesInAccountReceivables = []byte("changes_in_account_receivables")

var ffjKeyCashFlowStatementChangesInCash = []byte("changes_in_cash")

var ffjKeyCashFlowStatementCommonStockIssuance = []byte("common_stock_issuance")

var ffjKeyCashFlowStatementCommonStockPayments = []byte("common_stock_payments")

var ffjKeyCashFlowStatementCurrencyID = []byte("currency_id")

var ffjKeyCashFlowStatementDeferredIncomeTax = []byte("deferred_income_tax")

var ffjKeyCashFlowStatementDeferredTax = []byte("deferred_tax")

var ffjKeyCashFlowStatementDepreciationAmortizationDepletion = []byte("depreciation_amortization_depletion")

var ffjKeyCashFlowStatementDepreciationAndAmortization = []byte("depreciation_and_amortization")

var ffjKeyCashFlowStatementDomesticSales = []byte("domestic_sales")

var ffjKeyCashFlowStatementEndCashPosition = []byte("end_cash_position")

var ffjKeyCashFlowStatementFileDate = []byte("file_date")

var ffjKeyCashFlowStatementFinancingCashFlow = []byte("financing_cash_flow")

var ffjKeyCashFlowStatementFiscalYearEnd = []byte("fiscal_year_end")

var ffjKeyCashFlowStatementForeignSales = []byte("foreign_sales")

var ffjKeyCashFlowStatementFreeCashFlow = []byte("free_cash_flow")

var ffjKeyCashFlowStatementIncomeTaxPaidSupplementalData = []byte("income_tax_paid_supplemental_data")

var ffjKeyCashFlowStatementInterestPaidSupplementalData = []byte("int64erest_paid_supplemental_data")

var ffjKeyCashFlowStatementInvestingCashFlow = []byte("investing_cash_flow")

var ffjKeyCashFlowStatementIssuanceOfCapitalStock = []byte("issuance_of_capital_stock")

var ffjKeyCashFlowStatementNetBusinessPurchaseAndSale = []byte("net_business_purchase_and_sale")

var ffjKeyCashFlowStatementNetCommonStockIssuance = []byte("net_common_stock_issuance")

var ffjKeyCashFlowStatementNetIncome = []byte("net_income")

var ffjKeyCashFlowStatementNetIncomeFromContinuingOperations = []byte("net_income_from_continuing_operations")

var ffjKeyCashFlowStatementNetIntangiblesPurchaseAndSale = []byte("net_int64angibles_purchase_and_sale")

var ffjKeyCashFlowStatementNetInvestmentPurchaseAndSale = []byte("net_investment_purchase_and_sale")

var ffjKeyCashFlowStatementNetIssuancePaymentsOfDebt = []byte("net_issuance_payments_of_debt")

var ffjKeyCashFlowStatementNetOtherFinancingCharges = []byte("net_other_financing_charges")

var ffjKeyCashFlowStatementNetOtherInvestingChanges = []byte("net_other_investing_changes")

var ffjKeyCashFlowStatementNetPPEPurchaseAndSale = []byte("net_p_p_e_purchase_and_sale")

var ffjKeyCashFlowStatementNetShortTermDebtIssuance = []byte("net_short_term_debt_issuance")

var ffjKeyCashFlowStatementNumberOfShareHolders = []byte("number_of_share_holders")

var ffjKeyCashFlowStatementOperatingCashFlow = []byte("operating_cash_flow")

var ffjKeyCashFlowStatementOtherNonCashItems = []byte("other_non_cash_items")

var ffjKeyCashFlowStatementPeriod = []byte("period")

var ffjKeyCashFlowStatementPeriodEndingDate = []byte("period_ending_date")

var ffjKeyCashFlowStatementPurchaseOfBusiness = []byte("purchase_of_business")

var ffjKeyCashFlowStatementPurchaseOfIntangibles = []byte("purchase_of_int64angibles")

var ffjKeyCashFlowStatementPurchaseOfInvestment = []byte("purchase_of_investment")

var ffjKeyCashFlowStatementPurchaseOfPPE = []byte("purchase_of_p_p_e")

var ffjKeyCashFlowStatementReportType = []byte("report_type")

var ffjKeyCashFlowStatementRepurchaseOfCapitalStock = []byte("repurchase_of_capital_stock")

var ffjKeyCashFlowStatementSaleOfInvestment = []byte("sale_of_investment")

var ffjKeyCashFlowStatementStockBasedCompensation = []byte("stock_based_compensation")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CashFlowStatement) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CashFlowStatement) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCashFlowStatementbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCashFlowStatementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyCashFlowStatementBeginningCashPosition, kn) {
						currentKey = ffjtCashFlowStatementBeginningCashPosition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyCashFlowStatementCapitalExpenditure, kn) {
						currentKey = ffjtCashFlowStatementCapitalExpenditure
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementCashDividendsPaid, kn) {
						currentKey = ffjtCashFlowStatementCashDividendsPaid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInAccountPayable, kn) {
						currentKey = ffjtCashFlowStatementChangeInAccountPayable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInInventory, kn) {
						currentKey = ffjtCashFlowStatementChangeInInventory
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInOtherWorkingCapital, kn) {
						currentKey = ffjtCashFlowStatementChangeInOtherWorkingCapital
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInPayable, kn) {
						currentKey = ffjtCashFlowStatementChangeInPayable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInPayablesAndAccruedExpense, kn) {
						currentKey = ffjtCashFlowStatementChangeInPayablesAndAccruedExpense
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInReceivables, kn) {
						currentKey = ffjtCashFlowStatementChangeInReceivables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangeInWorkingCapital, kn) {
						currentKey = ffjtCashFlowStatementChangeInWorkingCapital
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangesInAccountReceivables, kn) {
						currentKey = ffjtCashFlowStatementChangesInAccountReceivables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementChangesInCash, kn) {
						currentKey = ffjtCashFlowStatementChangesInCash
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementCommonStockIssuance, kn) {
						currentKey = ffjtCashFlowStatementCommonStockIssuance
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementCommonStockPayments, kn) {
						currentKey = ffjtCashFlowStatementCommonStockPayments
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementCurrencyID, kn) {
						currentKey = ffjtCashFlowStatementCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyCashFlowStatementDeferredIncomeTax, kn) {
						currentKey = ffjtCashFlowStatementDeferredIncomeTax
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementDeferredTax, kn) {
						currentKey = ffjtCashFlowStatementDeferredTax
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementDepreciationAmortizationDepletion, kn) {
						currentKey = ffjtCashFlowStatementDepreciationAmortizationDepletion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementDepreciationAndAmortization, kn) {
						currentKey = ffjtCashFlowStatementDepreciationAndAmortization
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementDomesticSales, kn) {
						currentKey = ffjtCashFlowStatementDomesticSales
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyCashFlowStatementEndCashPosition, kn) {
						currentKey = ffjtCashFlowStatementEndCashPosition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyCashFlowStatementFileDate, kn) {
						currentKey = ffjtCashFlowStatementFileDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementFinancingCashFlow, kn) {
						currentKey = ffjtCashFlowStatementFinancingCashFlow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementFiscalYearEnd, kn) {
						currentKey = ffjtCashFlowStatementFiscalYearEnd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementForeignSales, kn) {
						currentKey = ffjtCashFlowStatementForeignSales
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementFreeCashFlow, kn) {
						currentKey = ffjtCashFlowStatementFreeCashFlow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyCashFlowStatementIncomeTaxPaidSupplementalData, kn) {
						currentKey = ffjtCashFlowStatementIncomeTaxPaidSupplementalData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementInterestPaidSupplementalData, kn) {
						currentKey = ffjtCashFlowStatementInterestPaidSupplementalData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementInvestingCashFlow, kn) {
						currentKey = ffjtCashFlowStatementInvestingCashFlow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementIssuanceOfCapitalStock, kn) {
						currentKey = ffjtCashFlowStatementIssuanceOfCapitalStock
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyCashFlowStatementNetBusinessPurchaseAndSale, kn) {
						currentKey = ffjtCashFlowStatementNetBusinessPurchaseAndSale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetCommonStockIssuance, kn) {
						currentKey = ffjtCashFlowStatementNetCommonStockIssuance
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetIncome, kn) {
						currentKey = ffjtCashFlowStatementNetIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetIncomeFromContinuingOperations, kn) {
						currentKey = ffjtCashFlowStatementNetIncomeFromContinuingOperations
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetIntangiblesPurchaseAndSale, kn) {
						currentKey = ffjtCashFlowStatementNetIntangiblesPurchaseAndSale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetInvestmentPurchaseAndSale, kn) {
						currentKey = ffjtCashFlowStatementNetInvestmentPurchaseAndSale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetIssuancePaymentsOfDebt, kn) {
						currentKey = ffjtCashFlowStatementNetIssuancePaymentsOfDebt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetOtherFinancingCharges, kn) {
						currentKey = ffjtCashFlowStatementNetOtherFinancingCharges
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetOtherInvestingChanges, kn) {
						currentKey = ffjtCashFlowStatementNetOtherInvestingChanges
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetPPEPurchaseAndSale, kn) {
						currentKey = ffjtCashFlowStatementNetPPEPurchaseAndSale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNetShortTermDebtIssuance, kn) {
						currentKey = ffjtCashFlowStatementNetShortTermDebtIssuance
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementNumberOfShareHolders, kn) {
						currentKey = ffjtCashFlowStatementNumberOfShareHolders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyCashFlowStatementOperatingCashFlow, kn) {
						currentKey = ffjtCashFlowStatementOperatingCashFlow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementOtherNonCashItems, kn) {
						currentKey = ffjtCashFlowStatementOtherNonCashItems
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyCashFlowStatementPeriod, kn) {
						currentKey = ffjtCashFlowStatementPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementPeriodEndingDate, kn) {
						currentKey = ffjtCashFlowStatementPeriodEndingDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementPurchaseOfBusiness, kn) {
						currentKey = ffjtCashFlowStatementPurchaseOfBusiness
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementPurchaseOfIntangibles, kn) {
						currentKey = ffjtCashFlowStatementPurchaseOfIntangibles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementPurchaseOfInvestment, kn) {
						currentKey = ffjtCashFlowStatementPurchaseOfInvestment
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementPurchaseOfPPE, kn) {
						currentKey = ffjtCashFlowStatementPurchaseOfPPE
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyCashFlowStatementReportType, kn) {
						currentKey = ffjtCashFlowStatementReportType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementRepurchaseOfCapitalStock, kn) {
						currentKey = ffjtCashFlowStatementRepurchaseOfCapitalStock
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyCashFlowStatementSaleOfInvestment, kn) {
						currentKey = ffjtCashFlowStatementSaleOfInvestment
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCashFlowStatementStockBasedCompensation, kn) {
						currentKey = ffjtCashFlowStatementStockBasedCompensation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementStockBasedCompensation, kn) {
					currentKey = ffjtCashFlowStatementStockBasedCompensation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementSaleOfInvestment, kn) {
					currentKey = ffjtCashFlowStatementSaleOfInvestment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementRepurchaseOfCapitalStock, kn) {
					currentKey = ffjtCashFlowStatementRepurchaseOfCapitalStock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementReportType, kn) {
					currentKey = ffjtCashFlowStatementReportType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementPurchaseOfPPE, kn) {
					currentKey = ffjtCashFlowStatementPurchaseOfPPE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementPurchaseOfInvestment, kn) {
					currentKey = ffjtCashFlowStatementPurchaseOfInvestment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementPurchaseOfIntangibles, kn) {
					currentKey = ffjtCashFlowStatementPurchaseOfIntangibles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementPurchaseOfBusiness, kn) {
					currentKey = ffjtCashFlowStatementPurchaseOfBusiness
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementPeriodEndingDate, kn) {
					currentKey = ffjtCashFlowStatementPeriodEndingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCashFlowStatementPeriod, kn) {
					currentKey = ffjtCashFlowStatementPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementOtherNonCashItems, kn) {
					currentKey = ffjtCashFlowStatementOtherNonCashItems
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementOperatingCashFlow, kn) {
					currentKey = ffjtCashFlowStatementOperatingCashFlow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNumberOfShareHolders, kn) {
					currentKey = ffjtCashFlowStatementNumberOfShareHolders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetShortTermDebtIssuance, kn) {
					currentKey = ffjtCashFlowStatementNetShortTermDebtIssuance
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetPPEPurchaseAndSale, kn) {
					currentKey = ffjtCashFlowStatementNetPPEPurchaseAndSale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetOtherInvestingChanges, kn) {
					currentKey = ffjtCashFlowStatementNetOtherInvestingChanges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetOtherFinancingCharges, kn) {
					currentKey = ffjtCashFlowStatementNetOtherFinancingCharges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetIssuancePaymentsOfDebt, kn) {
					currentKey = ffjtCashFlowStatementNetIssuancePaymentsOfDebt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetInvestmentPurchaseAndSale, kn) {
					currentKey = ffjtCashFlowStatementNetInvestmentPurchaseAndSale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetIntangiblesPurchaseAndSale, kn) {
					currentKey = ffjtCashFlowStatementNetIntangiblesPurchaseAndSale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetIncomeFromContinuingOperations, kn) {
					currentKey = ffjtCashFlowStatementNetIncomeFromContinuingOperations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementNetIncome, kn) {
					currentKey = ffjtCashFlowStatementNetIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetCommonStockIssuance, kn) {
					currentKey = ffjtCashFlowStatementNetCommonStockIssuance
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementNetBusinessPurchaseAndSale, kn) {
					currentKey = ffjtCashFlowStatementNetBusinessPurchaseAndSale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementIssuanceOfCapitalStock, kn) {
					currentKey = ffjtCashFlowStatementIssuanceOfCapitalStock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementInvestingCashFlow, kn) {
					currentKey = ffjtCashFlowStatementInvestingCashFlow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementInterestPaidSupplementalData, kn) {
					currentKey = ffjtCashFlowStatementInterestPaidSupplementalData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementIncomeTaxPaidSupplementalData, kn) {
					currentKey = ffjtCashFlowStatementIncomeTaxPaidSupplementalData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementFreeCashFlow, kn) {
					currentKey = ffjtCashFlowStatementFreeCashFlow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementForeignSales, kn) {
					currentKey = ffjtCashFlowStatementForeignSales
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementFiscalYearEnd, kn) {
					currentKey = ffjtCashFlowStatementFiscalYearEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementFinancingCashFlow, kn) {
					currentKey = ffjtCashFlowStatementFinancingCashFlow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementFileDate, kn) {
					currentKey = ffjtCashFlowStatementFileDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementEndCashPosition, kn) {
					currentKey = ffjtCashFlowStatementEndCashPosition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementDomesticSales, kn) {
					currentKey = ffjtCashFlowStatementDomesticSales
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementDepreciationAndAmortization, kn) {
					currentKey = ffjtCashFlowStatementDepreciationAndAmortization
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementDepreciationAmortizationDepletion, kn) {
					currentKey = ffjtCashFlowStatementDepreciationAmortizationDepletion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementDeferredTax, kn) {
					currentKey = ffjtCashFlowStatementDeferredTax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementDeferredIncomeTax, kn) {
					currentKey = ffjtCashFlowStatementDeferredIncomeTax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementCurrencyID, kn) {
					currentKey = ffjtCashFlowStatementCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementCommonStockPayments, kn) {
					currentKey = ffjtCashFlowStatementCommonStockPayments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementCommonStockIssuance, kn) {
					currentKey = ffjtCashFlowStatementCommonStockIssuance
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementChangesInCash, kn) {
					currentKey = ffjtCashFlowStatementChangesInCash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementChangesInAccountReceivables, kn) {
					currentKey = ffjtCashFlowStatementChangesInAccountReceivables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementChangeInWorkingCapital, kn) {
					currentKey = ffjtCashFlowStatementChangeInWorkingCapital
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementChangeInReceivables, kn) {
					currentKey = ffjtCashFlowStatementChangeInReceivables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementChangeInPayablesAndAccruedExpense, kn) {
					currentKey = ffjtCashFlowStatementChangeInPayablesAndAccruedExpense
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementChangeInPayable, kn) {
					currentKey = ffjtCashFlowStatementChangeInPayable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementChangeInOtherWorkingCapital, kn) {
					currentKey = ffjtCashFlowStatementChangeInOtherWorkingCapital
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementChangeInInventory, kn) {
					currentKey = ffjtCashFlowStatementChangeInInventory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementChangeInAccountPayable, kn) {
					currentKey = ffjtCashFlowStatementChangeInAccountPayable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementCashDividendsPaid, kn) {
					currentKey = ffjtCashFlowStatementCashDividendsPaid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCashFlowStatementCapitalExpenditure, kn) {
					currentKey = ffjtCashFlowStatementCapitalExpenditure
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCashFlowStatementBeginningCashPosition, kn) {
					currentKey = ffjtCashFlowStatementBeginningCashPosition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCashFlowStatementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCashFlowStatementBeginningCashPosition:
					goto handle_BeginningCashPosition

				case ffjtCashFlowStatementCapitalExpenditure:
					goto handle_CapitalExpenditure

				case ffjtCashFlowStatementCashDividendsPaid:
					goto handle_CashDividendsPaid

				case ffjtCashFlowStatementChangeInAccountPayable:
					goto handle_ChangeInAccountPayable

				case ffjtCashFlowStatementChangeInInventory:
					goto handle_ChangeInInventory

				case ffjtCashFlowStatementChangeInOtherWorkingCapital:
					goto handle_ChangeInOtherWorkingCapital

				case ffjtCashFlowStatementChangeInPayable:
					goto handle_ChangeInPayable

				case ffjtCashFlowStatementChangeInPayablesAndAccruedExpense:
					goto handle_ChangeInPayablesAndAccruedExpense

				case ffjtCashFlowStatementChangeInReceivables:
					goto handle_ChangeInReceivables

				case ffjtCashFlowStatementChangeInWorkingCapital:
					goto handle_ChangeInWorkingCapital

				case ffjtCashFlowStatementChangesInAccountReceivables:
					goto handle_ChangesInAccountReceivables

				case ffjtCashFlowStatementChangesInCash:
					goto handle_ChangesInCash

				case ffjtCashFlowStatementCommonStockIssuance:
					goto handle_CommonStockIssuance

				case ffjtCashFlowStatementCommonStockPayments:
					goto handle_CommonStockPayments

				case ffjtCashFlowStatementCurrencyID:
					goto handle_CurrencyID

				case ffjtCashFlowStatementDeferredIncomeTax:
					goto handle_DeferredIncomeTax

				case ffjtCashFlowStatementDeferredTax:
					goto handle_DeferredTax

				case ffjtCashFlowStatementDepreciationAmortizationDepletion:
					goto handle_DepreciationAmortizationDepletion

				case ffjtCashFlowStatementDepreciationAndAmortization:
					goto handle_DepreciationAndAmortization

				case ffjtCashFlowStatementDomesticSales:
					goto handle_DomesticSales

				case ffjtCashFlowStatementEndCashPosition:
					goto handle_EndCashPosition

				case ffjtCashFlowStatementFileDate:
					goto handle_FileDate

				case ffjtCashFlowStatementFinancingCashFlow:
					goto handle_FinancingCashFlow

				case ffjtCashFlowStatementFiscalYearEnd:
					goto handle_FiscalYearEnd

				case ffjtCashFlowStatementForeignSales:
					goto handle_ForeignSales

				case ffjtCashFlowStatementFreeCashFlow:
					goto handle_FreeCashFlow

				case ffjtCashFlowStatementIncomeTaxPaidSupplementalData:
					goto handle_IncomeTaxPaidSupplementalData

				case ffjtCashFlowStatementInterestPaidSupplementalData:
					goto handle_InterestPaidSupplementalData

				case ffjtCashFlowStatementInvestingCashFlow:
					goto handle_InvestingCashFlow

				case ffjtCashFlowStatementIssuanceOfCapitalStock:
					goto handle_IssuanceOfCapitalStock

				case ffjtCashFlowStatementNetBusinessPurchaseAndSale:
					goto handle_NetBusinessPurchaseAndSale

				case ffjtCashFlowStatementNetCommonStockIssuance:
					goto handle_NetCommonStockIssuance

				case ffjtCashFlowStatementNetIncome:
					goto handle_NetIncome

				case ffjtCashFlowStatementNetIncomeFromContinuingOperations:
					goto handle_NetIncomeFromContinuingOperations

				case ffjtCashFlowStatementNetIntangiblesPurchaseAndSale:
					goto handle_NetIntangiblesPurchaseAndSale

				case ffjtCashFlowStatementNetInvestmentPurchaseAndSale:
					goto handle_NetInvestmentPurchaseAndSale

				case ffjtCashFlowStatementNetIssuancePaymentsOfDebt:
					goto handle_NetIssuancePaymentsOfDebt

				case ffjtCashFlowStatementNetOtherFinancingCharges:
					goto handle_NetOtherFinancingCharges

				case ffjtCashFlowStatementNetOtherInvestingChanges:
					goto handle_NetOtherInvestingChanges

				case ffjtCashFlowStatementNetPPEPurchaseAndSale:
					goto handle_NetPPEPurchaseAndSale

				case ffjtCashFlowStatementNetShortTermDebtIssuance:
					goto handle_NetShortTermDebtIssuance

				case ffjtCashFlowStatementNumberOfShareHolders:
					goto handle_NumberOfShareHolders

				case ffjtCashFlowStatementOperatingCashFlow:
					goto handle_OperatingCashFlow

				case ffjtCashFlowStatementOtherNonCashItems:
					goto handle_OtherNonCashItems

				case ffjtCashFlowStatementPeriod:
					goto handle_Period

				case ffjtCashFlowStatementPeriodEndingDate:
					goto handle_PeriodEndingDate

				case ffjtCashFlowStatementPurchaseOfBusiness:
					goto handle_PurchaseOfBusiness

				case ffjtCashFlowStatementPurchaseOfIntangibles:
					goto handle_PurchaseOfIntangibles

				case ffjtCashFlowStatementPurchaseOfInvestment:
					goto handle_PurchaseOfInvestment

				case ffjtCashFlowStatementPurchaseOfPPE:
					goto handle_PurchaseOfPPE

				case ffjtCashFlowStatementReportType:
					goto handle_ReportType

				case ffjtCashFlowStatementRepurchaseOfCapitalStock:
					goto handle_RepurchaseOfCapitalStock

				case ffjtCashFlowStatementSaleOfInvestment:
					goto handle_SaleOfInvestment

				case ffjtCashFlowStatementStockBasedCompensation:
					goto handle_StockBasedCompensation

				case ffjtCashFlowStatementnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_BeginningCashPosition:

	/* handler: j.BeginningCashPosition type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BeginningCashPosition = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BeginningCashPosition = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CapitalExpenditure:

	/* handler: j.CapitalExpenditure type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CapitalExpenditure = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CapitalExpenditure = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashDividendsPaid:

	/* handler: j.CashDividendsPaid type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashDividendsPaid = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashDividendsPaid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInAccountPayable:

	/* handler: j.ChangeInAccountPayable type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInAccountPayable = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInAccountPayable = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInInventory:

	/* handler: j.ChangeInInventory type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInInventory = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInInventory = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInOtherWorkingCapital:

	/* handler: j.ChangeInOtherWorkingCapital type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInOtherWorkingCapital = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInOtherWorkingCapital = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInPayable:

	/* handler: j.ChangeInPayable type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInPayable = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInPayable = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInPayablesAndAccruedExpense:

	/* handler: j.ChangeInPayablesAndAccruedExpense type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInPayablesAndAccruedExpense = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInPayablesAndAccruedExpense = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInReceivables:

	/* handler: j.ChangeInReceivables type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInReceivables = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInReceivables = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeInWorkingCapital:

	/* handler: j.ChangeInWorkingCapital type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangeInWorkingCapital = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangeInWorkingCapital = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangesInAccountReceivables:

	/* handler: j.ChangesInAccountReceivables type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangesInAccountReceivables = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangesInAccountReceivables = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangesInCash:

	/* handler: j.ChangesInCash type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ChangesInCash = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ChangesInCash = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommonStockIssuance:

	/* handler: j.CommonStockIssuance type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CommonStockIssuance = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CommonStockIssuance = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommonStockPayments:

	/* handler: j.CommonStockPayments type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CommonStockPayments = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CommonStockPayments = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeferredIncomeTax:

	/* handler: j.DeferredIncomeTax type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DeferredIncomeTax = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DeferredIncomeTax = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeferredTax:

	/* handler: j.DeferredTax type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DeferredTax = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DeferredTax = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DepreciationAmortizationDepletion:

	/* handler: j.DepreciationAmortizationDepletion type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DepreciationAmortizationDepletion = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DepreciationAmortizationDepletion = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DepreciationAndAmortization:

	/* handler: j.DepreciationAndAmortization type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DepreciationAndAmortization = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DepreciationAndAmortization = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DomesticSales:

	/* handler: j.DomesticSales type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DomesticSales = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DomesticSales = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndCashPosition:

	/* handler: j.EndCashPosition type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EndCashPosition = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EndCashPosition = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileDate:

	/* handler: j.FileDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FileDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FileDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinancingCashFlow:

	/* handler: j.FinancingCashFlow type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FinancingCashFlow = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FinancingCashFlow = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FiscalYearEnd:

	/* handler: j.FiscalYearEnd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FiscalYearEnd = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FiscalYearEnd = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForeignSales:

	/* handler: j.ForeignSales type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ForeignSales = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ForeignSales = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FreeCashFlow:

	/* handler: j.FreeCashFlow type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FreeCashFlow = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FreeCashFlow = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IncomeTaxPaidSupplementalData:

	/* handler: j.IncomeTaxPaidSupplementalData type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.IncomeTaxPaidSupplementalData = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.IncomeTaxPaidSupplementalData = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InterestPaidSupplementalData:

	/* handler: j.InterestPaidSupplementalData type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InterestPaidSupplementalData = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InterestPaidSupplementalData = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvestingCashFlow:

	/* handler: j.InvestingCashFlow type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InvestingCashFlow = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InvestingCashFlow = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IssuanceOfCapitalStock:

	/* handler: j.IssuanceOfCapitalStock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.IssuanceOfCapitalStock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.IssuanceOfCapitalStock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetBusinessPurchaseAndSale:

	/* handler: j.NetBusinessPurchaseAndSale type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetBusinessPurchaseAndSale = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetBusinessPurchaseAndSale = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetCommonStockIssuance:

	/* handler: j.NetCommonStockIssuance type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetCommonStockIssuance = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetCommonStockIssuance = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncome:

	/* handler: j.NetIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeFromContinuingOperations:

	/* handler: j.NetIncomeFromContinuingOperations type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeFromContinuingOperations = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeFromContinuingOperations = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIntangiblesPurchaseAndSale:

	/* handler: j.NetIntangiblesPurchaseAndSale type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIntangiblesPurchaseAndSale = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIntangiblesPurchaseAndSale = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetInvestmentPurchaseAndSale:

	/* handler: j.NetInvestmentPurchaseAndSale type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetInvestmentPurchaseAndSale = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetInvestmentPurchaseAndSale = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIssuancePaymentsOfDebt:

	/* handler: j.NetIssuancePaymentsOfDebt type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIssuancePaymentsOfDebt = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIssuancePaymentsOfDebt = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetOtherFinancingCharges:

	/* handler: j.NetOtherFinancingCharges type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetOtherFinancingCharges = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetOtherFinancingCharges = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetOtherInvestingChanges:

	/* handler: j.NetOtherInvestingChanges type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetOtherInvestingChanges = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetOtherInvestingChanges = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetPPEPurchaseAndSale:

	/* handler: j.NetPPEPurchaseAndSale type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetPPEPurchaseAndSale = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetPPEPurchaseAndSale = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetShortTermDebtIssuance:

	/* handler: j.NetShortTermDebtIssuance type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetShortTermDebtIssuance = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetShortTermDebtIssuance = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfShareHolders:

	/* handler: j.NumberOfShareHolders type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NumberOfShareHolders = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.NumberOfShareHolders = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperatingCashFlow:

	/* handler: j.OperatingCashFlow type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperatingCashFlow = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperatingCashFlow = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherNonCashItems:

	/* handler: j.OtherNonCashItems type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherNonCashItems = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherNonCashItems = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PeriodEndingDate:

	/* handler: j.PeriodEndingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.PeriodEndingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.PeriodEndingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PurchaseOfBusiness:

	/* handler: j.PurchaseOfBusiness type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PurchaseOfBusiness = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PurchaseOfBusiness = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PurchaseOfIntangibles:

	/* handler: j.PurchaseOfIntangibles type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PurchaseOfIntangibles = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PurchaseOfIntangibles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PurchaseOfInvestment:

	/* handler: j.PurchaseOfInvestment type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PurchaseOfInvestment = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PurchaseOfInvestment = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PurchaseOfPPE:

	/* handler: j.PurchaseOfPPE type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PurchaseOfPPE = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PurchaseOfPPE = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReportType:

	/* handler: j.ReportType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ReportType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ReportType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RepurchaseOfCapitalStock:

	/* handler: j.RepurchaseOfCapitalStock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.RepurchaseOfCapitalStock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.RepurchaseOfCapitalStock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SaleOfInvestment:

	/* handler: j.SaleOfInvestment type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SaleOfInvestment = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SaleOfInvestment = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockBasedCompensation:

	/* handler: j.StockBasedCompensation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StockBasedCompensation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.StockBasedCompensation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CompanyHeadquarter) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CompanyHeadquarter) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AddressLine1 != nil {
		buf.WriteString(`{"address_line1":`)
		fflib.WriteJsonString(buf, string(*j.AddressLine1))
	} else {
		buf.WriteString(`{"address_line1":null`)
	}
	if j.City != nil {
		buf.WriteString(`,"city":`)
		fflib.WriteJsonString(buf, string(*j.City))
	} else {
		buf.WriteString(`,"city":null`)
	}
	if j.Country != nil {
		buf.WriteString(`,"country":`)
		fflib.WriteJsonString(buf, string(*j.Country))
	} else {
		buf.WriteString(`,"country":null`)
	}
	if j.Fax != nil {
		buf.WriteString(`,"fax":`)
		fflib.WriteJsonString(buf, string(*j.Fax))
	} else {
		buf.WriteString(`,"fax":null`)
	}
	if j.Homepage != nil {
		buf.WriteString(`,"homepage":`)
		fflib.WriteJsonString(buf, string(*j.Homepage))
	} else {
		buf.WriteString(`,"homepage":null`)
	}
	if j.Phone != nil {
		buf.WriteString(`,"phone":`)
		fflib.WriteJsonString(buf, string(*j.Phone))
	} else {
		buf.WriteString(`,"phone":null`)
	}
	if j.PostalCode != nil {
		buf.WriteString(`,"postal_code":`)
		fflib.WriteJsonString(buf, string(*j.PostalCode))
	} else {
		buf.WriteString(`,"postal_code":null`)
	}
	if j.Province != nil {
		buf.WriteString(`,"province":`)
		fflib.WriteJsonString(buf, string(*j.Province))
	} else {
		buf.WriteString(`,"province":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCompanyHeadquarterbase = iota
	ffjtCompanyHeadquarternosuchkey

	ffjtCompanyHeadquarterAddressLine1

	ffjtCompanyHeadquarterCity

	ffjtCompanyHeadquarterCountry

	ffjtCompanyHeadquarterFax

	ffjtCompanyHeadquarterHomepage

	ffjtCompanyHeadquarterPhone

	ffjtCompanyHeadquarterPostalCode

	ffjtCompanyHeadquarterProvince
)

var ffjKeyCompanyHeadquarterAddressLine1 = []byte("address_line1")

var ffjKeyCompanyHeadquarterCity = []byte("city")

var ffjKeyCompanyHeadquarterCountry = []byte("country")

var ffjKeyCompanyHeadquarterFax = []byte("fax")

var ffjKeyCompanyHeadquarterHomepage = []byte("homepage")

var ffjKeyCompanyHeadquarterPhone = []byte("phone")

var ffjKeyCompanyHeadquarterPostalCode = []byte("postal_code")

var ffjKeyCompanyHeadquarterProvince = []byte("province")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CompanyHeadquarter) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CompanyHeadquarter) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCompanyHeadquarterbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCompanyHeadquarternosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyCompanyHeadquarterAddressLine1, kn) {
						currentKey = ffjtCompanyHeadquarterAddressLine1
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyCompanyHeadquarterCity, kn) {
						currentKey = ffjtCompanyHeadquarterCity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCompanyHeadquarterCountry, kn) {
						currentKey = ffjtCompanyHeadquarterCountry
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyCompanyHeadquarterFax, kn) {
						currentKey = ffjtCompanyHeadquarterFax
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyCompanyHeadquarterHomepage, kn) {
						currentKey = ffjtCompanyHeadquarterHomepage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyCompanyHeadquarterPhone, kn) {
						currentKey = ffjtCompanyHeadquarterPhone
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCompanyHeadquarterPostalCode, kn) {
						currentKey = ffjtCompanyHeadquarterPostalCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCompanyHeadquarterProvince, kn) {
						currentKey = ffjtCompanyHeadquarterProvince
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyHeadquarterProvince, kn) {
					currentKey = ffjtCompanyHeadquarterProvince
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCompanyHeadquarterPostalCode, kn) {
					currentKey = ffjtCompanyHeadquarterPostalCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyHeadquarterPhone, kn) {
					currentKey = ffjtCompanyHeadquarterPhone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyHeadquarterHomepage, kn) {
					currentKey = ffjtCompanyHeadquarterHomepage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyHeadquarterFax, kn) {
					currentKey = ffjtCompanyHeadquarterFax
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyHeadquarterCountry, kn) {
					currentKey = ffjtCompanyHeadquarterCountry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyHeadquarterCity, kn) {
					currentKey = ffjtCompanyHeadquarterCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCompanyHeadquarterAddressLine1, kn) {
					currentKey = ffjtCompanyHeadquarterAddressLine1
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCompanyHeadquarternosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCompanyHeadquarterAddressLine1:
					goto handle_AddressLine1

				case ffjtCompanyHeadquarterCity:
					goto handle_City

				case ffjtCompanyHeadquarterCountry:
					goto handle_Country

				case ffjtCompanyHeadquarterFax:
					goto handle_Fax

				case ffjtCompanyHeadquarterHomepage:
					goto handle_Homepage

				case ffjtCompanyHeadquarterPhone:
					goto handle_Phone

				case ffjtCompanyHeadquarterPostalCode:
					goto handle_PostalCode

				case ffjtCompanyHeadquarterProvince:
					goto handle_Province

				case ffjtCompanyHeadquarternosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AddressLine1:

	/* handler: j.AddressLine1 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AddressLine1 = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AddressLine1 = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.City = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.City = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Country:

	/* handler: j.Country type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Country = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Country = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fax:

	/* handler: j.Fax type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Fax = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Fax = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Homepage:

	/* handler: j.Homepage type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Homepage = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Homepage = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: j.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Phone = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Phone = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PostalCode:

	/* handler: j.PostalCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.PostalCode = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.PostalCode = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Province:

	/* handler: j.Province type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Province = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Province = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CompanyInfoResult) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CompanyInfoResult) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	/* Inline struct. type=struct { AssetClassification *tradier.AssetClassification "json:\"asset_classification\""; CompanyProfile *tradier.CompanyProfile "json:\"company_profile\""; HistoricalAssetClassification *tradier.HistoricalAssetClassification "json:\"historical_asset_classification\""; LongDescriptions *string "json:\"long_descriptions\""; OwnershipDetails tradier.OwnershipDetails "json:\"ownership_details\""; OwnershipSummary *tradier.OwnershipSummary "json:\"ownership_summary\""; ShareClass *tradier.ShareClass "json:\"share_class\""; ShareClassProfile *tradier.ShareClassProfile "json:\"share_class_profile\"" } kind=struct */
	if j.Tables.AssetClassification != nil {
		buf.WriteString(`,"tables":{ "asset_classification":`)

		{

			err = j.Tables.AssetClassification.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"tables":{ "asset_classification":null`)
	}
	if j.Tables.CompanyProfile != nil {
		buf.WriteString(`,"company_profile":`)

		{

			err = j.Tables.CompanyProfile.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"company_profile":null`)
	}
	if j.Tables.HistoricalAssetClassification != nil {
		buf.WriteString(`,"historical_asset_classification":`)

		{

			err = j.Tables.HistoricalAssetClassification.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"historical_asset_classification":null`)
	}
	if j.Tables.LongDescriptions != nil {
		buf.WriteString(`,"long_descriptions":`)
		fflib.WriteJsonString(buf, string(*j.Tables.LongDescriptions))
	} else {
		buf.WriteString(`,"long_descriptions":null`)
	}
	buf.WriteString(`,"ownership_details":`)
	if j.Tables.OwnershipDetails != nil {
		buf.WriteString(`[`)
		for i, v := range j.Tables.OwnershipDetails {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.Tables.OwnershipSummary != nil {
		buf.WriteString(`,"ownership_summary":`)

		{

			err = j.Tables.OwnershipSummary.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"ownership_summary":null`)
	}
	if j.Tables.ShareClass != nil {
		buf.WriteString(`,"share_class":`)

		{

			err = j.Tables.ShareClass.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"share_class":null`)
	}
	if j.Tables.ShareClassProfile != nil {
		buf.WriteString(`,"share_class_profile":`)

		{

			err = j.Tables.ShareClassProfile.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"share_class_profile":null`)
	}
	buf.WriteByte('}')
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCompanyInfoResultbase = iota
	ffjtCompanyInfoResultnosuchkey

	ffjtCompanyInfoResultID

	ffjtCompanyInfoResultTables

	ffjtCompanyInfoResultType
)

var ffjKeyCompanyInfoResultID = []byte("id")

var ffjKeyCompanyInfoResultTables = []byte("tables")

var ffjKeyCompanyInfoResultType = []byte("type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CompanyInfoResult) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CompanyInfoResult) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCompanyInfoResultbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCompanyInfoResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyCompanyInfoResultID, kn) {
						currentKey = ffjtCompanyInfoResultID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyCompanyInfoResultTables, kn) {
						currentKey = ffjtCompanyInfoResultTables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCompanyInfoResultType, kn) {
						currentKey = ffjtCompanyInfoResultType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyInfoResultType, kn) {
					currentKey = ffjtCompanyInfoResultType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCompanyInfoResultTables, kn) {
					currentKey = ffjtCompanyInfoResultTables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyInfoResultID, kn) {
					currentKey = ffjtCompanyInfoResultID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCompanyInfoResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCompanyInfoResultID:
					goto handle_ID

				case ffjtCompanyInfoResultTables:
					goto handle_Tables

				case ffjtCompanyInfoResultType:
					goto handle_Type

				case ffjtCompanyInfoResultnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tables:

	/* handler: j.Tables type=struct { AssetClassification *tradier.AssetClassification "json:\"asset_classification\""; CompanyProfile *tradier.CompanyProfile "json:\"company_profile\""; HistoricalAssetClassification *tradier.HistoricalAssetClassification "json:\"historical_asset_classification\""; LongDescriptions *string "json:\"long_descriptions\""; OwnershipDetails tradier.OwnershipDetails "json:\"ownership_details\""; OwnershipSummary *tradier.OwnershipSummary "json:\"ownership_summary\""; ShareClass *tradier.ShareClass "json:\"share_class\""; ShareClassProfile *tradier.ShareClassProfile "json:\"share_class_profile\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { AssetClassification *tradier.AssetClassification "json:\"asset_classification\""; CompanyProfile *tradier.CompanyProfile "json:\"company_profile\""; HistoricalAssetClassification *tradier.HistoricalAssetClassification "json:\"historical_asset_classification\""; LongDescriptions *string "json:\"long_descriptions\""; OwnershipDetails tradier.OwnershipDetails "json:\"ownership_details\""; OwnershipSummary *tradier.OwnershipSummary "json:\"ownership_summary\""; ShareClass *tradier.ShareClass "json:\"share_class\""; ShareClassProfile *tradier.ShareClassProfile "json:\"share_class_profile\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Tables)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CompanyProfile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CompanyProfile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.TotalEmployeeNumberAsOfDate != nil {
		buf.WriteString(`{"TotalEmployeeNumber.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.TotalEmployeeNumberAsOfDate))
	} else {
		buf.WriteString(`{"TotalEmployeeNumber.asOfDate":null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	if j.ContactEmail != nil {
		buf.WriteString(`,"contact_email":`)
		fflib.WriteJsonString(buf, string(*j.ContactEmail))
	} else {
		buf.WriteString(`,"contact_email":null`)
	}
	if j.Headquarter != nil {
		buf.WriteString(`,"headquarter":`)

		{

			err = j.Headquarter.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"headquarter":null`)
	}
	if j.ShortDescription != nil {
		buf.WriteString(`,"short_description":`)
		fflib.WriteJsonString(buf, string(*j.ShortDescription))
	} else {
		buf.WriteString(`,"short_description":null`)
	}
	if j.TotalEmployeeNumber != nil {
		buf.WriteString(`,"total_employee_number":`)
		fflib.FormatBits2(buf, uint64(*j.TotalEmployeeNumber), 10, *j.TotalEmployeeNumber < 0)
	} else {
		buf.WriteString(`,"total_employee_number":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCompanyProfilebase = iota
	ffjtCompanyProfilenosuchkey

	ffjtCompanyProfileTotalEmployeeNumberAsOfDate

	ffjtCompanyProfileCompanyID

	ffjtCompanyProfileContactEmail

	ffjtCompanyProfileHeadquarter

	ffjtCompanyProfileShortDescription

	ffjtCompanyProfileTotalEmployeeNumber
)

var ffjKeyCompanyProfileTotalEmployeeNumberAsOfDate = []byte("TotalEmployeeNumber.asOfDate")

var ffjKeyCompanyProfileCompanyID = []byte("company_id")

var ffjKeyCompanyProfileContactEmail = []byte("contact_email")

var ffjKeyCompanyProfileHeadquarter = []byte("headquarter")

var ffjKeyCompanyProfileShortDescription = []byte("short_description")

var ffjKeyCompanyProfileTotalEmployeeNumber = []byte("total_employee_number")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CompanyProfile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CompanyProfile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCompanyProfilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCompanyProfilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'T':

					if bytes.Equal(ffjKeyCompanyProfileTotalEmployeeNumberAsOfDate, kn) {
						currentKey = ffjtCompanyProfileTotalEmployeeNumberAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyCompanyProfileCompanyID, kn) {
						currentKey = ffjtCompanyProfileCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCompanyProfileContactEmail, kn) {
						currentKey = ffjtCompanyProfileContactEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyCompanyProfileHeadquarter, kn) {
						currentKey = ffjtCompanyProfileHeadquarter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyCompanyProfileShortDescription, kn) {
						currentKey = ffjtCompanyProfileShortDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyCompanyProfileTotalEmployeeNumber, kn) {
						currentKey = ffjtCompanyProfileTotalEmployeeNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyCompanyProfileTotalEmployeeNumber, kn) {
					currentKey = ffjtCompanyProfileTotalEmployeeNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCompanyProfileShortDescription, kn) {
					currentKey = ffjtCompanyProfileShortDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCompanyProfileHeadquarter, kn) {
					currentKey = ffjtCompanyProfileHeadquarter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCompanyProfileContactEmail, kn) {
					currentKey = ffjtCompanyProfileContactEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCompanyProfileCompanyID, kn) {
					currentKey = ffjtCompanyProfileCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCompanyProfileTotalEmployeeNumberAsOfDate, kn) {
					currentKey = ffjtCompanyProfileTotalEmployeeNumberAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCompanyProfilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCompanyProfileTotalEmployeeNumberAsOfDate:
					goto handle_TotalEmployeeNumberAsOfDate

				case ffjtCompanyProfileCompanyID:
					goto handle_CompanyID

				case ffjtCompanyProfileContactEmail:
					goto handle_ContactEmail

				case ffjtCompanyProfileHeadquarter:
					goto handle_Headquarter

				case ffjtCompanyProfileShortDescription:
					goto handle_ShortDescription

				case ffjtCompanyProfileTotalEmployeeNumber:
					goto handle_TotalEmployeeNumber

				case ffjtCompanyProfilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TotalEmployeeNumberAsOfDate:

	/* handler: j.TotalEmployeeNumberAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.TotalEmployeeNumberAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.TotalEmployeeNumberAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContactEmail:

	/* handler: j.ContactEmail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ContactEmail = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ContactEmail = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Headquarter:

	/* handler: j.Headquarter type=tradier.CompanyHeadquarter kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Headquarter = nil

		} else {

			if j.Headquarter == nil {
				j.Headquarter = new(CompanyHeadquarter)
			}

			err = j.Headquarter.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortDescription:

	/* handler: j.ShortDescription type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShortDescription = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShortDescription = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalEmployeeNumber:

	/* handler: j.TotalEmployeeNumber type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalEmployeeNumber = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.TotalEmployeeNumber = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CorporateEvent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CorporateEvent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.BeginDateTime != nil {
		buf.WriteString(`{ "begin_date_time":`)
		fflib.WriteJsonString(buf, string(*j.BeginDateTime))
	} else {
		buf.WriteString(`{ "begin_date_time":null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	if j.EndDateTime != nil {
		buf.WriteString(`,"end_date_time":`)
		fflib.WriteJsonString(buf, string(*j.EndDateTime))
	} else {
		buf.WriteString(`,"end_date_time":null`)
	}
	if j.Event != nil {
		buf.WriteString(`,"event":`)
		fflib.WriteJsonString(buf, string(*j.Event))
	} else {
		buf.WriteString(`,"event":null`)
	}
	if j.EventType != nil {
		buf.WriteString(`,"event_type":`)
		fflib.FormatBits2(buf, uint64(*j.EventType), 10, *j.EventType < 0)
	} else {
		buf.WriteString(`,"event_type":null`)
	}
	buf.WriteByte(',')
	if j.TimeZone != nil {
		if true {
			buf.WriteString(`"time_zone":`)
			fflib.WriteJsonString(buf, string(*j.TimeZone))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCorporateEventbase = iota
	ffjtCorporateEventnosuchkey

	ffjtCorporateEventBeginDateTime

	ffjtCorporateEventCompanyID

	ffjtCorporateEventEndDateTime

	ffjtCorporateEventEvent

	ffjtCorporateEventEventType

	ffjtCorporateEventTimeZone
)

var ffjKeyCorporateEventBeginDateTime = []byte("begin_date_time")

var ffjKeyCorporateEventCompanyID = []byte("company_id")

var ffjKeyCorporateEventEndDateTime = []byte("end_date_time")

var ffjKeyCorporateEventEvent = []byte("event")

var ffjKeyCorporateEventEventType = []byte("event_type")

var ffjKeyCorporateEventTimeZone = []byte("time_zone")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CorporateEvent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CorporateEvent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCorporateEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCorporateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyCorporateEventBeginDateTime, kn) {
						currentKey = ffjtCorporateEventBeginDateTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyCorporateEventCompanyID, kn) {
						currentKey = ffjtCorporateEventCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyCorporateEventEndDateTime, kn) {
						currentKey = ffjtCorporateEventEndDateTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCorporateEventEvent, kn) {
						currentKey = ffjtCorporateEventEvent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCorporateEventEventType, kn) {
						currentKey = ffjtCorporateEventEventType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyCorporateEventTimeZone, kn) {
						currentKey = ffjtCorporateEventTimeZone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyCorporateEventTimeZone, kn) {
					currentKey = ffjtCorporateEventTimeZone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCorporateEventEventType, kn) {
					currentKey = ffjtCorporateEventEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCorporateEventEvent, kn) {
					currentKey = ffjtCorporateEventEvent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCorporateEventEndDateTime, kn) {
					currentKey = ffjtCorporateEventEndDateTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCorporateEventCompanyID, kn) {
					currentKey = ffjtCorporateEventCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyCorporateEventBeginDateTime, kn) {
					currentKey = ffjtCorporateEventBeginDateTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCorporateEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCorporateEventBeginDateTime:
					goto handle_BeginDateTime

				case ffjtCorporateEventCompanyID:
					goto handle_CompanyID

				case ffjtCorporateEventEndDateTime:
					goto handle_EndDateTime

				case ffjtCorporateEventEvent:
					goto handle_Event

				case ffjtCorporateEventEventType:
					goto handle_EventType

				case ffjtCorporateEventTimeZone:
					goto handle_TimeZone

				case ffjtCorporateEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_BeginDateTime:

	/* handler: j.BeginDateTime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.BeginDateTime = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.BeginDateTime = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndDateTime:

	/* handler: j.EndDateTime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.EndDateTime = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.EndDateTime = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Event:

	/* handler: j.Event type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Event = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Event = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EventType:

	/* handler: j.EventType type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EventType = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.EventType = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeZone:

	/* handler: j.TimeZone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.TimeZone = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.TimeZone = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EarningReport) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EarningReport) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AccessionNumber != nil {
		buf.WriteString(`{"accession_number":`)
		fflib.WriteJsonString(buf, string(*j.AccessionNumber))
	} else {
		buf.WriteString(`{"accession_number":null`)
	}
	if j.AsOfDate != nil {
		buf.WriteString(`,"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`,"as_of_date":null`)
	}
	if j.BasicAverageShares != nil {
		buf.WriteString(`,"basic_average_shares":`)
		fflib.AppendFloat(buf, float64(*j.BasicAverageShares), 'g', -1, 64)
	} else {
		buf.WriteString(`,"basic_average_shares":null`)
	}
	if j.BasicContinuousOperations != nil {
		buf.WriteString(`,"basic_continuous_operations":`)
		fflib.AppendFloat(buf, float64(*j.BasicContinuousOperations), 'g', -1, 64)
	} else {
		buf.WriteString(`,"basic_continuous_operations":null`)
	}
	if j.BasicEPS != nil {
		buf.WriteString(`,"basic_e_p_s":`)
		fflib.AppendFloat(buf, float64(*j.BasicEPS), 'g', -1, 64)
	} else {
		buf.WriteString(`,"basic_e_p_s":null`)
	}
	if j.ContinuingAndDiscontinuedBasicEPS != nil {
		buf.WriteString(`,"continuing_and_discontinued_basic_e_p_s":`)
		fflib.AppendFloat(buf, float64(*j.ContinuingAndDiscontinuedBasicEPS), 'g', -1, 64)
	} else {
		buf.WriteString(`,"continuing_and_discontinued_basic_e_p_s":null`)
	}
	if j.ContinuingAndDiscontinuedDilutedEPS != nil {
		buf.WriteString(`,"continuing_and_discontinued_diluted_e_p_s":`)
		fflib.AppendFloat(buf, float64(*j.ContinuingAndDiscontinuedDilutedEPS), 'g', -1, 64)
	} else {
		buf.WriteString(`,"continuing_and_discontinued_diluted_e_p_s":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_id":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_id":null`)
	}
	if j.DilutedAverageShares != nil {
		buf.WriteString(`,"diluted_average_shares":`)
		fflib.AppendFloat(buf, float64(*j.DilutedAverageShares), 'g', -1, 64)
	} else {
		buf.WriteString(`,"diluted_average_shares":null`)
	}
	if j.DilutedContinuousOperations != nil {
		buf.WriteString(`,"diluted_continuous_operations":`)
		fflib.AppendFloat(buf, float64(*j.DilutedContinuousOperations), 'g', -1, 64)
	} else {
		buf.WriteString(`,"diluted_continuous_operations":null`)
	}
	if j.DilutedEPS != nil {
		buf.WriteString(`,"diluted_e_p_s":`)
		fflib.AppendFloat(buf, float64(*j.DilutedEPS), 'g', -1, 64)
	} else {
		buf.WriteString(`,"diluted_e_p_s":null`)
	}
	if j.DividendPerShare != nil {
		buf.WriteString(`,"dividend_per_share":`)
		fflib.AppendFloat(buf, float64(*j.DividendPerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"dividend_per_share":null`)
	}
	if j.FileDate != nil {
		buf.WriteString(`,"file_date":`)
		fflib.WriteJsonString(buf, string(*j.FileDate))
	} else {
		buf.WriteString(`,"file_date":null`)
	}
	if j.FiscalYearEnd != nil {
		buf.WriteString(`,"fiscal_year_end":`)
		fflib.WriteJsonString(buf, string(*j.FiscalYearEnd))
	} else {
		buf.WriteString(`,"fiscal_year_end":null`)
	}
	if j.FormType != nil {
		buf.WriteString(`,"form_type":`)
		fflib.WriteJsonString(buf, string(*j.FormType))
	} else {
		buf.WriteString(`,"form_type":null`)
	}
	if j.NormalizedBasicEPS != nil {
		buf.WriteString(`,"normalized_basic_e_p_s":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedBasicEPS), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_basic_e_p_s":null`)
	}
	if j.NormalizedDilutedEPS != nil {
		buf.WriteString(`,"normalized_diluted_e_p_s":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedDilutedEPS), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_diluted_e_p_s":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.PeriodEndingDate != nil {
		buf.WriteString(`,"period_ending_date":`)
		fflib.WriteJsonString(buf, string(*j.PeriodEndingDate))
	} else {
		buf.WriteString(`,"period_ending_date":null`)
	}
	if j.ReportType != nil {
		buf.WriteString(`,"report_type":`)
		fflib.WriteJsonString(buf, string(*j.ReportType))
	} else {
		buf.WriteString(`,"report_type":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEarningReportbase = iota
	ffjtEarningReportnosuchkey

	ffjtEarningReportAccessionNumber

	ffjtEarningReportAsOfDate

	ffjtEarningReportBasicAverageShares

	ffjtEarningReportBasicContinuousOperations

	ffjtEarningReportBasicEPS

	ffjtEarningReportContinuingAndDiscontinuedBasicEPS

	ffjtEarningReportContinuingAndDiscontinuedDilutedEPS

	ffjtEarningReportCurrencyID

	ffjtEarningReportDilutedAverageShares

	ffjtEarningReportDilutedContinuousOperations

	ffjtEarningReportDilutedEPS

	ffjtEarningReportDividendPerShare

	ffjtEarningReportFileDate

	ffjtEarningReportFiscalYearEnd

	ffjtEarningReportFormType

	ffjtEarningReportNormalizedBasicEPS

	ffjtEarningReportNormalizedDilutedEPS

	ffjtEarningReportPeriod

	ffjtEarningReportPeriodEndingDate

	ffjtEarningReportReportType

	ffjtEarningReportShareClassID
)

var ffjKeyEarningReportAccessionNumber = []byte("accession_number")

var ffjKeyEarningReportAsOfDate = []byte("as_of_date")

var ffjKeyEarningReportBasicAverageShares = []byte("basic_average_shares")

var ffjKeyEarningReportBasicContinuousOperations = []byte("basic_continuous_operations")

var ffjKeyEarningReportBasicEPS = []byte("basic_e_p_s")

var ffjKeyEarningReportContinuingAndDiscontinuedBasicEPS = []byte("continuing_and_discontinued_basic_e_p_s")

var ffjKeyEarningReportContinuingAndDiscontinuedDilutedEPS = []byte("continuing_and_discontinued_diluted_e_p_s")

var ffjKeyEarningReportCurrencyID = []byte("currency_id")

var ffjKeyEarningReportDilutedAverageShares = []byte("diluted_average_shares")

var ffjKeyEarningReportDilutedContinuousOperations = []byte("diluted_continuous_operations")

var ffjKeyEarningReportDilutedEPS = []byte("diluted_e_p_s")

var ffjKeyEarningReportDividendPerShare = []byte("dividend_per_share")

var ffjKeyEarningReportFileDate = []byte("file_date")

var ffjKeyEarningReportFiscalYearEnd = []byte("fiscal_year_end")

var ffjKeyEarningReportFormType = []byte("form_type")

var ffjKeyEarningReportNormalizedBasicEPS = []byte("normalized_basic_e_p_s")

var ffjKeyEarningReportNormalizedDilutedEPS = []byte("normalized_diluted_e_p_s")

var ffjKeyEarningReportPeriod = []byte("period")

var ffjKeyEarningReportPeriodEndingDate = []byte("period_ending_date")

var ffjKeyEarningReportReportType = []byte("report_type")

var ffjKeyEarningReportShareClassID = []byte("share_class_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EarningReport) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EarningReport) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEarningReportbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEarningReportnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyEarningReportAccessionNumber, kn) {
						currentKey = ffjtEarningReportAccessionNumber
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportAsOfDate, kn) {
						currentKey = ffjtEarningReportAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyEarningReportBasicAverageShares, kn) {
						currentKey = ffjtEarningReportBasicAverageShares
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportBasicContinuousOperations, kn) {
						currentKey = ffjtEarningReportBasicContinuousOperations
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportBasicEPS, kn) {
						currentKey = ffjtEarningReportBasicEPS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyEarningReportContinuingAndDiscontinuedBasicEPS, kn) {
						currentKey = ffjtEarningReportContinuingAndDiscontinuedBasicEPS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportContinuingAndDiscontinuedDilutedEPS, kn) {
						currentKey = ffjtEarningReportContinuingAndDiscontinuedDilutedEPS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportCurrencyID, kn) {
						currentKey = ffjtEarningReportCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyEarningReportDilutedAverageShares, kn) {
						currentKey = ffjtEarningReportDilutedAverageShares
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportDilutedContinuousOperations, kn) {
						currentKey = ffjtEarningReportDilutedContinuousOperations
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportDilutedEPS, kn) {
						currentKey = ffjtEarningReportDilutedEPS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportDividendPerShare, kn) {
						currentKey = ffjtEarningReportDividendPerShare
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyEarningReportFileDate, kn) {
						currentKey = ffjtEarningReportFileDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportFiscalYearEnd, kn) {
						currentKey = ffjtEarningReportFiscalYearEnd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportFormType, kn) {
						currentKey = ffjtEarningReportFormType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyEarningReportNormalizedBasicEPS, kn) {
						currentKey = ffjtEarningReportNormalizedBasicEPS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportNormalizedDilutedEPS, kn) {
						currentKey = ffjtEarningReportNormalizedDilutedEPS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyEarningReportPeriod, kn) {
						currentKey = ffjtEarningReportPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningReportPeriodEndingDate, kn) {
						currentKey = ffjtEarningReportPeriodEndingDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyEarningReportReportType, kn) {
						currentKey = ffjtEarningReportReportType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEarningReportShareClassID, kn) {
						currentKey = ffjtEarningReportShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEarningReportShareClassID, kn) {
					currentKey = ffjtEarningReportShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEarningReportReportType, kn) {
					currentKey = ffjtEarningReportReportType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEarningReportPeriodEndingDate, kn) {
					currentKey = ffjtEarningReportPeriodEndingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEarningReportPeriod, kn) {
					currentKey = ffjtEarningReportPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportNormalizedDilutedEPS, kn) {
					currentKey = ffjtEarningReportNormalizedDilutedEPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportNormalizedBasicEPS, kn) {
					currentKey = ffjtEarningReportNormalizedBasicEPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEarningReportFormType, kn) {
					currentKey = ffjtEarningReportFormType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportFiscalYearEnd, kn) {
					currentKey = ffjtEarningReportFiscalYearEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEarningReportFileDate, kn) {
					currentKey = ffjtEarningReportFileDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportDividendPerShare, kn) {
					currentKey = ffjtEarningReportDividendPerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportDilutedEPS, kn) {
					currentKey = ffjtEarningReportDilutedEPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportDilutedContinuousOperations, kn) {
					currentKey = ffjtEarningReportDilutedContinuousOperations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportDilutedAverageShares, kn) {
					currentKey = ffjtEarningReportDilutedAverageShares
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEarningReportCurrencyID, kn) {
					currentKey = ffjtEarningReportCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportContinuingAndDiscontinuedDilutedEPS, kn) {
					currentKey = ffjtEarningReportContinuingAndDiscontinuedDilutedEPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportContinuingAndDiscontinuedBasicEPS, kn) {
					currentKey = ffjtEarningReportContinuingAndDiscontinuedBasicEPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportBasicEPS, kn) {
					currentKey = ffjtEarningReportBasicEPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportBasicContinuousOperations, kn) {
					currentKey = ffjtEarningReportBasicContinuousOperations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportBasicAverageShares, kn) {
					currentKey = ffjtEarningReportBasicAverageShares
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportAsOfDate, kn) {
					currentKey = ffjtEarningReportAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningReportAccessionNumber, kn) {
					currentKey = ffjtEarningReportAccessionNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEarningReportnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEarningReportAccessionNumber:
					goto handle_AccessionNumber

				case ffjtEarningReportAsOfDate:
					goto handle_AsOfDate

				case ffjtEarningReportBasicAverageShares:
					goto handle_BasicAverageShares

				case ffjtEarningReportBasicContinuousOperations:
					goto handle_BasicContinuousOperations

				case ffjtEarningReportBasicEPS:
					goto handle_BasicEPS

				case ffjtEarningReportContinuingAndDiscontinuedBasicEPS:
					goto handle_ContinuingAndDiscontinuedBasicEPS

				case ffjtEarningReportContinuingAndDiscontinuedDilutedEPS:
					goto handle_ContinuingAndDiscontinuedDilutedEPS

				case ffjtEarningReportCurrencyID:
					goto handle_CurrencyID

				case ffjtEarningReportDilutedAverageShares:
					goto handle_DilutedAverageShares

				case ffjtEarningReportDilutedContinuousOperations:
					goto handle_DilutedContinuousOperations

				case ffjtEarningReportDilutedEPS:
					goto handle_DilutedEPS

				case ffjtEarningReportDividendPerShare:
					goto handle_DividendPerShare

				case ffjtEarningReportFileDate:
					goto handle_FileDate

				case ffjtEarningReportFiscalYearEnd:
					goto handle_FiscalYearEnd

				case ffjtEarningReportFormType:
					goto handle_FormType

				case ffjtEarningReportNormalizedBasicEPS:
					goto handle_NormalizedBasicEPS

				case ffjtEarningReportNormalizedDilutedEPS:
					goto handle_NormalizedDilutedEPS

				case ffjtEarningReportPeriod:
					goto handle_Period

				case ffjtEarningReportPeriodEndingDate:
					goto handle_PeriodEndingDate

				case ffjtEarningReportReportType:
					goto handle_ReportType

				case ffjtEarningReportShareClassID:
					goto handle_ShareClassID

				case ffjtEarningReportnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccessionNumber:

	/* handler: j.AccessionNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AccessionNumber = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AccessionNumber = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BasicAverageShares:

	/* handler: j.BasicAverageShares type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BasicAverageShares = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BasicAverageShares = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BasicContinuousOperations:

	/* handler: j.BasicContinuousOperations type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BasicContinuousOperations = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BasicContinuousOperations = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BasicEPS:

	/* handler: j.BasicEPS type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BasicEPS = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BasicEPS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContinuingAndDiscontinuedBasicEPS:

	/* handler: j.ContinuingAndDiscontinuedBasicEPS type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ContinuingAndDiscontinuedBasicEPS = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ContinuingAndDiscontinuedBasicEPS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContinuingAndDiscontinuedDilutedEPS:

	/* handler: j.ContinuingAndDiscontinuedDilutedEPS type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ContinuingAndDiscontinuedDilutedEPS = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ContinuingAndDiscontinuedDilutedEPS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DilutedAverageShares:

	/* handler: j.DilutedAverageShares type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DilutedAverageShares = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DilutedAverageShares = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DilutedContinuousOperations:

	/* handler: j.DilutedContinuousOperations type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DilutedContinuousOperations = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DilutedContinuousOperations = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DilutedEPS:

	/* handler: j.DilutedEPS type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DilutedEPS = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DilutedEPS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DividendPerShare:

	/* handler: j.DividendPerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DividendPerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DividendPerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileDate:

	/* handler: j.FileDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FileDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FileDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FiscalYearEnd:

	/* handler: j.FiscalYearEnd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FiscalYearEnd = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FiscalYearEnd = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FormType:

	/* handler: j.FormType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FormType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FormType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedBasicEPS:

	/* handler: j.NormalizedBasicEPS type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedBasicEPS = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedBasicEPS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedDilutedEPS:

	/* handler: j.NormalizedDilutedEPS type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedDilutedEPS = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedDilutedEPS = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PeriodEndingDate:

	/* handler: j.PeriodEndingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.PeriodEndingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.PeriodEndingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReportType:

	/* handler: j.ReportType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ReportType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ReportType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EarningsRatiosRestate) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EarningsRatiosRestate) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.DPSGrowth != nil {
		buf.WriteString(`,"d_p_s_growth":`)
		fflib.AppendFloat(buf, float64(*j.DPSGrowth), 'g', -1, 64)
	} else {
		buf.WriteString(`,"d_p_s_growth":null`)
	}
	if j.DilutedContEPSGrowth != nil {
		buf.WriteString(`,"diluted_cont_e_p_s_growth":`)
		fflib.AppendFloat(buf, float64(*j.DilutedContEPSGrowth), 'g', -1, 64)
	} else {
		buf.WriteString(`,"diluted_cont_e_p_s_growth":null`)
	}
	if j.DilutedEPSGrowth != nil {
		buf.WriteString(`,"diluted_e_p_s_growth":`)
		fflib.AppendFloat(buf, float64(*j.DilutedEPSGrowth), 'g', -1, 64)
	} else {
		buf.WriteString(`,"diluted_e_p_s_growth":null`)
	}
	if j.FiscalYearEnd != nil {
		buf.WriteString(`,"fiscal_year_end":`)
		fflib.WriteJsonString(buf, string(*j.FiscalYearEnd))
	} else {
		buf.WriteString(`,"fiscal_year_end":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.ReportType != nil {
		buf.WriteString(`,"report_type":`)
		fflib.WriteJsonString(buf, string(*j.ReportType))
	} else {
		buf.WriteString(`,"report_type":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEarningsRatiosRestatebase = iota
	ffjtEarningsRatiosRestatenosuchkey

	ffjtEarningsRatiosRestateAsOfDate

	ffjtEarningsRatiosRestateDPSGrowth

	ffjtEarningsRatiosRestateDilutedContEPSGrowth

	ffjtEarningsRatiosRestateDilutedEPSGrowth

	ffjtEarningsRatiosRestateFiscalYearEnd

	ffjtEarningsRatiosRestatePeriod

	ffjtEarningsRatiosRestateReportType

	ffjtEarningsRatiosRestateShareClassID
)

var ffjKeyEarningsRatiosRestateAsOfDate = []byte("as_of_date")

var ffjKeyEarningsRatiosRestateDPSGrowth = []byte("d_p_s_growth")

var ffjKeyEarningsRatiosRestateDilutedContEPSGrowth = []byte("diluted_cont_e_p_s_growth")

var ffjKeyEarningsRatiosRestateDilutedEPSGrowth = []byte("diluted_e_p_s_growth")

var ffjKeyEarningsRatiosRestateFiscalYearEnd = []byte("fiscal_year_end")

var ffjKeyEarningsRatiosRestatePeriod = []byte("period")

var ffjKeyEarningsRatiosRestateReportType = []byte("report_type")

var ffjKeyEarningsRatiosRestateShareClassID = []byte("share_class_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EarningsRatiosRestate) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EarningsRatiosRestate) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEarningsRatiosRestatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEarningsRatiosRestatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyEarningsRatiosRestateAsOfDate, kn) {
						currentKey = ffjtEarningsRatiosRestateAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyEarningsRatiosRestateDPSGrowth, kn) {
						currentKey = ffjtEarningsRatiosRestateDPSGrowth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningsRatiosRestateDilutedContEPSGrowth, kn) {
						currentKey = ffjtEarningsRatiosRestateDilutedContEPSGrowth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEarningsRatiosRestateDilutedEPSGrowth, kn) {
						currentKey = ffjtEarningsRatiosRestateDilutedEPSGrowth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyEarningsRatiosRestateFiscalYearEnd, kn) {
						currentKey = ffjtEarningsRatiosRestateFiscalYearEnd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyEarningsRatiosRestatePeriod, kn) {
						currentKey = ffjtEarningsRatiosRestatePeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyEarningsRatiosRestateReportType, kn) {
						currentKey = ffjtEarningsRatiosRestateReportType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEarningsRatiosRestateShareClassID, kn) {
						currentKey = ffjtEarningsRatiosRestateShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEarningsRatiosRestateShareClassID, kn) {
					currentKey = ffjtEarningsRatiosRestateShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEarningsRatiosRestateReportType, kn) {
					currentKey = ffjtEarningsRatiosRestateReportType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEarningsRatiosRestatePeriod, kn) {
					currentKey = ffjtEarningsRatiosRestatePeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningsRatiosRestateFiscalYearEnd, kn) {
					currentKey = ffjtEarningsRatiosRestateFiscalYearEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningsRatiosRestateDilutedEPSGrowth, kn) {
					currentKey = ffjtEarningsRatiosRestateDilutedEPSGrowth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningsRatiosRestateDilutedContEPSGrowth, kn) {
					currentKey = ffjtEarningsRatiosRestateDilutedContEPSGrowth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningsRatiosRestateDPSGrowth, kn) {
					currentKey = ffjtEarningsRatiosRestateDPSGrowth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEarningsRatiosRestateAsOfDate, kn) {
					currentKey = ffjtEarningsRatiosRestateAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEarningsRatiosRestatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEarningsRatiosRestateAsOfDate:
					goto handle_AsOfDate

				case ffjtEarningsRatiosRestateDPSGrowth:
					goto handle_DPSGrowth

				case ffjtEarningsRatiosRestateDilutedContEPSGrowth:
					goto handle_DilutedContEPSGrowth

				case ffjtEarningsRatiosRestateDilutedEPSGrowth:
					goto handle_DilutedEPSGrowth

				case ffjtEarningsRatiosRestateFiscalYearEnd:
					goto handle_FiscalYearEnd

				case ffjtEarningsRatiosRestatePeriod:
					goto handle_Period

				case ffjtEarningsRatiosRestateReportType:
					goto handle_ReportType

				case ffjtEarningsRatiosRestateShareClassID:
					goto handle_ShareClassID

				case ffjtEarningsRatiosRestatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DPSGrowth:

	/* handler: j.DPSGrowth type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DPSGrowth = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DPSGrowth = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DilutedContEPSGrowth:

	/* handler: j.DilutedContEPSGrowth type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DilutedContEPSGrowth = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DilutedContEPSGrowth = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DilutedEPSGrowth:

	/* handler: j.DilutedEPSGrowth type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DilutedEPSGrowth = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DilutedEPSGrowth = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FiscalYearEnd:

	/* handler: j.FiscalYearEnd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FiscalYearEnd = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FiscalYearEnd = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReportType:

	/* handler: j.ReportType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ReportType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ReportType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FinancialStatementsRestate) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FinancialStatementsRestate) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	buf.WriteString(`,"balance_sheet":`)
	if j.BalanceSheet != nil {
		buf.WriteString(`[`)
		for i, v := range j.BalanceSheet {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Falling back. type=map[string]tradier.BalanceSheet kind=map */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"cash_flow_statement":`)
	if j.CashFlowStatement != nil {
		buf.WriteString(`[`)
		for i, v := range j.CashFlowStatement {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Falling back. type=map[string]tradier.CashFlowStatement kind=map */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	buf.WriteString(`,"income_statement":`)
	if j.IncomeStatement != nil {
		buf.WriteString(`[`)
		for i, v := range j.IncomeStatement {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Falling back. type=map[string]tradier.IncomeStatement kind=map */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFinancialStatementsRestatebase = iota
	ffjtFinancialStatementsRestatenosuchkey

	ffjtFinancialStatementsRestateAsOfDate

	ffjtFinancialStatementsRestateBalanceSheet

	ffjtFinancialStatementsRestateCashFlowStatement

	ffjtFinancialStatementsRestateCompanyID

	ffjtFinancialStatementsRestateIncomeStatement
)

var ffjKeyFinancialStatementsRestateAsOfDate = []byte("as_of_date")

var ffjKeyFinancialStatementsRestateBalanceSheet = []byte("balance_sheet")

var ffjKeyFinancialStatementsRestateCashFlowStatement = []byte("cash_flow_statement")

var ffjKeyFinancialStatementsRestateCompanyID = []byte("company_id")

var ffjKeyFinancialStatementsRestateIncomeStatement = []byte("income_statement")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FinancialStatementsRestate) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FinancialStatementsRestate) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFinancialStatementsRestatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFinancialStatementsRestatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyFinancialStatementsRestateAsOfDate, kn) {
						currentKey = ffjtFinancialStatementsRestateAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyFinancialStatementsRestateBalanceSheet, kn) {
						currentKey = ffjtFinancialStatementsRestateBalanceSheet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyFinancialStatementsRestateCashFlowStatement, kn) {
						currentKey = ffjtFinancialStatementsRestateCashFlowStatement
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFinancialStatementsRestateCompanyID, kn) {
						currentKey = ffjtFinancialStatementsRestateCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyFinancialStatementsRestateIncomeStatement, kn) {
						currentKey = ffjtFinancialStatementsRestateIncomeStatement
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFinancialStatementsRestateIncomeStatement, kn) {
					currentKey = ffjtFinancialStatementsRestateIncomeStatement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyFinancialStatementsRestateCompanyID, kn) {
					currentKey = ffjtFinancialStatementsRestateCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFinancialStatementsRestateCashFlowStatement, kn) {
					currentKey = ffjtFinancialStatementsRestateCashFlowStatement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFinancialStatementsRestateBalanceSheet, kn) {
					currentKey = ffjtFinancialStatementsRestateBalanceSheet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFinancialStatementsRestateAsOfDate, kn) {
					currentKey = ffjtFinancialStatementsRestateAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFinancialStatementsRestatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFinancialStatementsRestateAsOfDate:
					goto handle_AsOfDate

				case ffjtFinancialStatementsRestateBalanceSheet:
					goto handle_BalanceSheet

				case ffjtFinancialStatementsRestateCashFlowStatement:
					goto handle_CashFlowStatement

				case ffjtFinancialStatementsRestateCompanyID:
					goto handle_CompanyID

				case ffjtFinancialStatementsRestateIncomeStatement:
					goto handle_IncomeStatement

				case ffjtFinancialStatementsRestatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BalanceSheet:

	/* handler: j.BalanceSheet type=tradier.BalanceSheetResults kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BalanceSheet.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashFlowStatement:

	/* handler: j.CashFlowStatement type=tradier.CashFlowStatements kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CashFlowStatement.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IncomeStatement:

	/* handler: j.IncomeStatement type=tradier.IncomeStatements kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.IncomeStatement.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HistoricalAssetClassification) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HistoricalAssetClassification) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	if j.FinancialHealthGrade != nil {
		buf.WriteString(`,"financial_health_grade":`)
		fflib.WriteJsonString(buf, string(*j.FinancialHealthGrade))
	} else {
		buf.WriteString(`,"financial_health_grade":null`)
	}
	if j.GrowthScore != nil {
		buf.WriteString(`,"growth_score":`)
		fflib.AppendFloat(buf, float64(*j.GrowthScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"growth_score":null`)
	}
	if j.MorningstarEconomySphereCode != nil {
		buf.WriteString(`,"morningstar_economy_sphere_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarEconomySphereCode), 10, *j.MorningstarEconomySphereCode < 0)
	} else {
		buf.WriteString(`,"morningstar_economy_sphere_code":null`)
	}
	if j.MorningstarIndustryCode != nil {
		buf.WriteString(`,"morningstar_industry_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarIndustryCode), 10, *j.MorningstarIndustryCode < 0)
	} else {
		buf.WriteString(`,"morningstar_industry_code":null`)
	}
	if j.MorningstarIndustryGroupCode != nil {
		buf.WriteString(`,"morningstar_industry_group_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarIndustryGroupCode), 10, *j.MorningstarIndustryGroupCode < 0)
	} else {
		buf.WriteString(`,"morningstar_industry_group_code":null`)
	}
	if j.MorningstarSectorCode != nil {
		buf.WriteString(`,"morningstar_sector_code":`)
		fflib.FormatBits2(buf, uint64(*j.MorningstarSectorCode), 10, *j.MorningstarSectorCode < 0)
	} else {
		buf.WriteString(`,"morningstar_sector_code":null`)
	}
	if j.ProfitabilityGrade != nil {
		buf.WriteString(`,"profitability_grade":`)
		fflib.WriteJsonString(buf, string(*j.ProfitabilityGrade))
	} else {
		buf.WriteString(`,"profitability_grade":null`)
	}
	if j.SizeScore != nil {
		buf.WriteString(`,"size_score":`)
		fflib.AppendFloat(buf, float64(*j.SizeScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"size_score":null`)
	}
	if j.StockType != nil {
		buf.WriteString(`,"stock_type":`)
		fflib.FormatBits2(buf, uint64(*j.StockType), 10, *j.StockType < 0)
	} else {
		buf.WriteString(`,"stock_type":null`)
	}
	if j.StyleBox != nil {
		buf.WriteString(`,"style_box":`)
		fflib.FormatBits2(buf, uint64(*j.StyleBox), 10, *j.StyleBox < 0)
	} else {
		buf.WriteString(`,"style_box":null`)
	}
	if j.StyleScore != nil {
		buf.WriteString(`,"style_score":`)
		fflib.AppendFloat(buf, float64(*j.StyleScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"style_score":null`)
	}
	if j.ValueScore != nil {
		buf.WriteString(`,"value_score":`)
		fflib.AppendFloat(buf, float64(*j.ValueScore), 'g', -1, 64)
	} else {
		buf.WriteString(`,"value_score":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHistoricalAssetClassificationbase = iota
	ffjtHistoricalAssetClassificationnosuchkey

	ffjtHistoricalAssetClassificationAsOfDate

	ffjtHistoricalAssetClassificationCompanyID

	ffjtHistoricalAssetClassificationFinancialHealthGrade

	ffjtHistoricalAssetClassificationGrowthScore

	ffjtHistoricalAssetClassificationMorningstarEconomySphereCode

	ffjtHistoricalAssetClassificationMorningstarIndustryCode

	ffjtHistoricalAssetClassificationMorningstarIndustryGroupCode

	ffjtHistoricalAssetClassificationMorningstarSectorCode

	ffjtHistoricalAssetClassificationProfitabilityGrade

	ffjtHistoricalAssetClassificationSizeScore

	ffjtHistoricalAssetClassificationStockType

	ffjtHistoricalAssetClassificationStyleBox

	ffjtHistoricalAssetClassificationStyleScore

	ffjtHistoricalAssetClassificationValueScore
)

var ffjKeyHistoricalAssetClassificationAsOfDate = []byte("as_of_date")

var ffjKeyHistoricalAssetClassificationCompanyID = []byte("company_id")

var ffjKeyHistoricalAssetClassificationFinancialHealthGrade = []byte("financial_health_grade")

var ffjKeyHistoricalAssetClassificationGrowthScore = []byte("growth_score")

var ffjKeyHistoricalAssetClassificationMorningstarEconomySphereCode = []byte("morningstar_economy_sphere_code")

var ffjKeyHistoricalAssetClassificationMorningstarIndustryCode = []byte("morningstar_industry_code")

var ffjKeyHistoricalAssetClassificationMorningstarIndustryGroupCode = []byte("morningstar_industry_group_code")

var ffjKeyHistoricalAssetClassificationMorningstarSectorCode = []byte("morningstar_sector_code")

var ffjKeyHistoricalAssetClassificationProfitabilityGrade = []byte("profitability_grade")

var ffjKeyHistoricalAssetClassificationSizeScore = []byte("size_score")

var ffjKeyHistoricalAssetClassificationStockType = []byte("stock_type")

var ffjKeyHistoricalAssetClassificationStyleBox = []byte("style_box")

var ffjKeyHistoricalAssetClassificationStyleScore = []byte("style_score")

var ffjKeyHistoricalAssetClassificationValueScore = []byte("value_score")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HistoricalAssetClassification) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HistoricalAssetClassification) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHistoricalAssetClassificationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHistoricalAssetClassificationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationAsOfDate, kn) {
						currentKey = ffjtHistoricalAssetClassificationAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationCompanyID, kn) {
						currentKey = ffjtHistoricalAssetClassificationCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationFinancialHealthGrade, kn) {
						currentKey = ffjtHistoricalAssetClassificationFinancialHealthGrade
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationGrowthScore, kn) {
						currentKey = ffjtHistoricalAssetClassificationGrowthScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationMorningstarEconomySphereCode, kn) {
						currentKey = ffjtHistoricalAssetClassificationMorningstarEconomySphereCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHistoricalAssetClassificationMorningstarIndustryCode, kn) {
						currentKey = ffjtHistoricalAssetClassificationMorningstarIndustryCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHistoricalAssetClassificationMorningstarIndustryGroupCode, kn) {
						currentKey = ffjtHistoricalAssetClassificationMorningstarIndustryGroupCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHistoricalAssetClassificationMorningstarSectorCode, kn) {
						currentKey = ffjtHistoricalAssetClassificationMorningstarSectorCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationProfitabilityGrade, kn) {
						currentKey = ffjtHistoricalAssetClassificationProfitabilityGrade
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationSizeScore, kn) {
						currentKey = ffjtHistoricalAssetClassificationSizeScore
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHistoricalAssetClassificationStockType, kn) {
						currentKey = ffjtHistoricalAssetClassificationStockType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHistoricalAssetClassificationStyleBox, kn) {
						currentKey = ffjtHistoricalAssetClassificationStyleBox
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyHistoricalAssetClassificationStyleScore, kn) {
						currentKey = ffjtHistoricalAssetClassificationStyleScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyHistoricalAssetClassificationValueScore, kn) {
						currentKey = ffjtHistoricalAssetClassificationValueScore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationValueScore, kn) {
					currentKey = ffjtHistoricalAssetClassificationValueScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationStyleScore, kn) {
					currentKey = ffjtHistoricalAssetClassificationStyleScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationStyleBox, kn) {
					currentKey = ffjtHistoricalAssetClassificationStyleBox
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationStockType, kn) {
					currentKey = ffjtHistoricalAssetClassificationStockType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationSizeScore, kn) {
					currentKey = ffjtHistoricalAssetClassificationSizeScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyHistoricalAssetClassificationProfitabilityGrade, kn) {
					currentKey = ffjtHistoricalAssetClassificationProfitabilityGrade
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationMorningstarSectorCode, kn) {
					currentKey = ffjtHistoricalAssetClassificationMorningstarSectorCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationMorningstarIndustryGroupCode, kn) {
					currentKey = ffjtHistoricalAssetClassificationMorningstarIndustryGroupCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationMorningstarIndustryCode, kn) {
					currentKey = ffjtHistoricalAssetClassificationMorningstarIndustryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationMorningstarEconomySphereCode, kn) {
					currentKey = ffjtHistoricalAssetClassificationMorningstarEconomySphereCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationGrowthScore, kn) {
					currentKey = ffjtHistoricalAssetClassificationGrowthScore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyHistoricalAssetClassificationFinancialHealthGrade, kn) {
					currentKey = ffjtHistoricalAssetClassificationFinancialHealthGrade
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyHistoricalAssetClassificationCompanyID, kn) {
					currentKey = ffjtHistoricalAssetClassificationCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalAssetClassificationAsOfDate, kn) {
					currentKey = ffjtHistoricalAssetClassificationAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHistoricalAssetClassificationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHistoricalAssetClassificationAsOfDate:
					goto handle_AsOfDate

				case ffjtHistoricalAssetClassificationCompanyID:
					goto handle_CompanyID

				case ffjtHistoricalAssetClassificationFinancialHealthGrade:
					goto handle_FinancialHealthGrade

				case ffjtHistoricalAssetClassificationGrowthScore:
					goto handle_GrowthScore

				case ffjtHistoricalAssetClassificationMorningstarEconomySphereCode:
					goto handle_MorningstarEconomySphereCode

				case ffjtHistoricalAssetClassificationMorningstarIndustryCode:
					goto handle_MorningstarIndustryCode

				case ffjtHistoricalAssetClassificationMorningstarIndustryGroupCode:
					goto handle_MorningstarIndustryGroupCode

				case ffjtHistoricalAssetClassificationMorningstarSectorCode:
					goto handle_MorningstarSectorCode

				case ffjtHistoricalAssetClassificationProfitabilityGrade:
					goto handle_ProfitabilityGrade

				case ffjtHistoricalAssetClassificationSizeScore:
					goto handle_SizeScore

				case ffjtHistoricalAssetClassificationStockType:
					goto handle_StockType

				case ffjtHistoricalAssetClassificationStyleBox:
					goto handle_StyleBox

				case ffjtHistoricalAssetClassificationStyleScore:
					goto handle_StyleScore

				case ffjtHistoricalAssetClassificationValueScore:
					goto handle_ValueScore

				case ffjtHistoricalAssetClassificationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinancialHealthGrade:

	/* handler: j.FinancialHealthGrade type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FinancialHealthGrade = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FinancialHealthGrade = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrowthScore:

	/* handler: j.GrowthScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GrowthScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GrowthScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarEconomySphereCode:

	/* handler: j.MorningstarEconomySphereCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarEconomySphereCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarEconomySphereCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarIndustryCode:

	/* handler: j.MorningstarIndustryCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarIndustryCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarIndustryCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarIndustryGroupCode:

	/* handler: j.MorningstarIndustryGroupCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarIndustryGroupCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarIndustryGroupCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MorningstarSectorCode:

	/* handler: j.MorningstarSectorCode type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MorningstarSectorCode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MorningstarSectorCode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfitabilityGrade:

	/* handler: j.ProfitabilityGrade type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ProfitabilityGrade = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ProfitabilityGrade = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SizeScore:

	/* handler: j.SizeScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SizeScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SizeScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StockType:

	/* handler: j.StockType type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StockType = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.StockType = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StyleBox:

	/* handler: j.StyleBox type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StyleBox = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.StyleBox = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StyleScore:

	/* handler: j.StyleScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StyleScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.StyleScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueScore:

	/* handler: j.ValueScore type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ValueScore = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ValueScore = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *HistoricalReturns) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *HistoricalReturns) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	if j.TotalReturn != nil {
		buf.WriteString(`,"total_return":`)
		fflib.AppendFloat(buf, float64(*j.TotalReturn), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_return":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtHistoricalReturnsbase = iota
	ffjtHistoricalReturnsnosuchkey

	ffjtHistoricalReturnsAsOfDate

	ffjtHistoricalReturnsPeriod

	ffjtHistoricalReturnsShareClassID

	ffjtHistoricalReturnsTotalReturn
)

var ffjKeyHistoricalReturnsAsOfDate = []byte("as_of_date")

var ffjKeyHistoricalReturnsPeriod = []byte("period")

var ffjKeyHistoricalReturnsShareClassID = []byte("share_class_id")

var ffjKeyHistoricalReturnsTotalReturn = []byte("total_return")

// UnmarshalJSON umarshall json - template of ffjson
func (j *HistoricalReturns) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *HistoricalReturns) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtHistoricalReturnsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtHistoricalReturnsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyHistoricalReturnsAsOfDate, kn) {
						currentKey = ffjtHistoricalReturnsAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyHistoricalReturnsPeriod, kn) {
						currentKey = ffjtHistoricalReturnsPeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyHistoricalReturnsShareClassID, kn) {
						currentKey = ffjtHistoricalReturnsShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyHistoricalReturnsTotalReturn, kn) {
						currentKey = ffjtHistoricalReturnsTotalReturn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyHistoricalReturnsTotalReturn, kn) {
					currentKey = ffjtHistoricalReturnsTotalReturn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalReturnsShareClassID, kn) {
					currentKey = ffjtHistoricalReturnsShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyHistoricalReturnsPeriod, kn) {
					currentKey = ffjtHistoricalReturnsPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyHistoricalReturnsAsOfDate, kn) {
					currentKey = ffjtHistoricalReturnsAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtHistoricalReturnsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtHistoricalReturnsAsOfDate:
					goto handle_AsOfDate

				case ffjtHistoricalReturnsPeriod:
					goto handle_Period

				case ffjtHistoricalReturnsShareClassID:
					goto handle_ShareClassID

				case ffjtHistoricalReturnsTotalReturn:
					goto handle_TotalReturn

				case ffjtHistoricalReturnsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalReturn:

	/* handler: j.TotalReturn type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalReturn = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalReturn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *IncomeStatement) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *IncomeStatement) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AccessionNumber != nil {
		buf.WriteString(`{"accession_number":`)
		fflib.WriteJsonString(buf, string(*j.AccessionNumber))
	} else {
		buf.WriteString(`{"accession_number":null`)
	}
	if j.CostOfRevenue != nil {
		buf.WriteString(`,"cost_of_revenue":`)
		fflib.AppendFloat(buf, float64(*j.CostOfRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cost_of_revenue":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_id":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_id":null`)
	}
	if j.EBIT != nil {
		buf.WriteString(`,"e_b_i_t":`)
		fflib.AppendFloat(buf, float64(*j.EBIT), 'g', -1, 64)
	} else {
		buf.WriteString(`,"e_b_i_t":null`)
	}
	if j.EBITDA != nil {
		buf.WriteString(`,"e_b_i_t_d_a":`)
		fflib.AppendFloat(buf, float64(*j.EBITDA), 'g', -1, 64)
	} else {
		buf.WriteString(`,"e_b_i_t_d_a":null`)
	}
	if j.FileDate != nil {
		buf.WriteString(`,"file_date":`)
		fflib.WriteJsonString(buf, string(*j.FileDate))
	} else {
		buf.WriteString(`,"file_date":null`)
	}
	if j.FiscalYearEnd != nil {
		buf.WriteString(`,"fiscal_year_end":`)
		fflib.WriteJsonString(buf, string(*j.FiscalYearEnd))
	} else {
		buf.WriteString(`,"fiscal_year_end":null`)
	}
	if j.FormType != nil {
		buf.WriteString(`,"form_type":`)
		fflib.WriteJsonString(buf, string(*j.FormType))
	} else {
		buf.WriteString(`,"form_type":null`)
	}
	if j.GrossProfit != nil {
		buf.WriteString(`,"gross_profit":`)
		fflib.AppendFloat(buf, float64(*j.GrossProfit), 'g', -1, 64)
	} else {
		buf.WriteString(`,"gross_profit":null`)
	}
	if j.InterestIncome != nil {
		buf.WriteString(`,"int64erest_income":`)
		fflib.AppendFloat(buf, float64(*j.InterestIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"int64erest_income":null`)
	}
	if j.InterestIncomeNonOperating != nil {
		buf.WriteString(`,"int64erest_income_non_operating":`)
		fflib.AppendFloat(buf, float64(*j.InterestIncomeNonOperating), 'g', -1, 64)
	} else {
		buf.WriteString(`,"int64erest_income_non_operating":null`)
	}
	if j.InterestAndSimilarIncome != nil {
		buf.WriteString(`,"int64erestand_similar_income":`)
		fflib.AppendFloat(buf, float64(*j.InterestAndSimilarIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"int64erestand_similar_income":null`)
	}
	if j.NetIncome != nil {
		buf.WriteString(`,"net_income":`)
		fflib.AppendFloat(buf, float64(*j.NetIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income":null`)
	}
	if j.NetIncomeCommonStockholders != nil {
		buf.WriteString(`,"net_income_common_stockholders":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeCommonStockholders), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_common_stockholders":null`)
	}
	if j.NetIncomeContinuousOperations != nil {
		buf.WriteString(`,"net_income_continuous_operations":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeContinuousOperations), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_continuous_operations":null`)
	}
	if j.NetIncomeFromContinuingAndDiscontinuedOperation != nil {
		buf.WriteString(`,"net_income_from_continuing_and_discontinued_operation":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeFromContinuingAndDiscontinuedOperation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_from_continuing_and_discontinued_operation":null`)
	}
	if j.NetIncomeFromContinuingOperationNetMinorityInterest != nil {
		buf.WriteString(`,"net_income_from_continuing_operation_net_minority_int64erest":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeFromContinuingOperationNetMinorityInterest), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_from_continuing_operation_net_minority_int64erest":null`)
	}
	if j.NetIncomeIncludingNoncontrollingInterests != nil {
		buf.WriteString(`,"net_income_including_noncontrolling_int64erests":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeIncludingNoncontrollingInterests), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_including_noncontrolling_int64erests":null`)
	}
	if j.NetInterestIncome != nil {
		buf.WriteString(`,"net_int64erest_income":`)
		fflib.AppendFloat(buf, float64(*j.NetInterestIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_int64erest_income":null`)
	}
	if j.NetNonOperatingInterestIncomeExpense != nil {
		buf.WriteString(`,"net_non_operating_int64erest_income_expense":`)
		fflib.AppendFloat(buf, float64(*j.NetNonOperatingInterestIncomeExpense), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_non_operating_int64erest_income_expense":null`)
	}
	if j.NonOperatingExpenses != nil {
		buf.WriteString(`,"non_operating_expenses":`)
		fflib.AppendFloat(buf, float64(*j.NonOperatingExpenses), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_operating_expenses":null`)
	}
	if j.NonOperatingIncome != nil {
		buf.WriteString(`,"non_operating_income":`)
		fflib.AppendFloat(buf, float64(*j.NonOperatingIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"non_operating_income":null`)
	}
	if j.NormalizedEBITDA != nil {
		buf.WriteString(`,"normalized_e_b_i_t_d_a":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedEBITDA), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_e_b_i_t_d_a":null`)
	}
	if j.NormalizedIncome != nil {
		buf.WriteString(`,"normalized_income":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_income":null`)
	}
	if j.NumberOfShareHolders != nil {
		buf.WriteString(`,"number_of_share_holders":`)
		fflib.FormatBits2(buf, uint64(*j.NumberOfShareHolders), 10, *j.NumberOfShareHolders < 0)
	} else {
		buf.WriteString(`,"number_of_share_holders":null`)
	}
	if j.OperatingExpense != nil {
		buf.WriteString(`,"operating_expense":`)
		fflib.AppendFloat(buf, float64(*j.OperatingExpense), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operating_expense":null`)
	}
	if j.OperatingIncome != nil {
		buf.WriteString(`,"operating_income":`)
		fflib.AppendFloat(buf, float64(*j.OperatingIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operating_income":null`)
	}
	if j.OperatingRevenue != nil {
		buf.WriteString(`,"operating_revenue":`)
		fflib.AppendFloat(buf, float64(*j.OperatingRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operating_revenue":null`)
	}
	if j.OtherIncomeExpense != nil {
		buf.WriteString(`,"other_income_expense":`)
		fflib.AppendFloat(buf, float64(*j.OtherIncomeExpense), 'g', -1, 64)
	} else {
		buf.WriteString(`,"other_income_expense":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.PeriodEndingDate != nil {
		buf.WriteString(`,"period_ending_date":`)
		fflib.WriteJsonString(buf, string(*j.PeriodEndingDate))
	} else {
		buf.WriteString(`,"period_ending_date":null`)
	}
	if j.PretaxIncome != nil {
		buf.WriteString(`,"pretax_income":`)
		fflib.AppendFloat(buf, float64(*j.PretaxIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"pretax_income":null`)
	}
	if j.ReconciledCostOfRevenue != nil {
		buf.WriteString(`,"reconciled_cost_of_revenue":`)
		fflib.AppendFloat(buf, float64(*j.ReconciledCostOfRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"reconciled_cost_of_revenue":null`)
	}
	if j.ReconciledDepreciation != nil {
		buf.WriteString(`,"reconciled_depreciation":`)
		fflib.AppendFloat(buf, float64(*j.ReconciledDepreciation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"reconciled_depreciation":null`)
	}
	if j.ReportType != nil {
		buf.WriteString(`,"report_type":`)
		fflib.WriteJsonString(buf, string(*j.ReportType))
	} else {
		buf.WriteString(`,"report_type":null`)
	}
	if j.ResearchAndDevelopment != nil {
		buf.WriteString(`,"research_and_development":`)
		fflib.AppendFloat(buf, float64(*j.ResearchAndDevelopment), 'g', -1, 64)
	} else {
		buf.WriteString(`,"research_and_development":null`)
	}
	if j.SellingGeneralAndAdministration != nil {
		buf.WriteString(`,"selling_general_and_administration":`)
		fflib.AppendFloat(buf, float64(*j.SellingGeneralAndAdministration), 'g', -1, 64)
	} else {
		buf.WriteString(`,"selling_general_and_administration":null`)
	}
	if j.TaxEffectOfUnusualItems != nil {
		buf.WriteString(`,"tax_effect_of_unusual_items":`)
		fflib.AppendFloat(buf, float64(*j.TaxEffectOfUnusualItems), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tax_effect_of_unusual_items":null`)
	}
	if j.TaxProvision != nil {
		buf.WriteString(`,"tax_provision":`)
		fflib.AppendFloat(buf, float64(*j.TaxProvision), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tax_provision":null`)
	}
	if j.TaxRateForCalcs != nil {
		buf.WriteString(`,"tax_rate_for_calcs":`)
		fflib.AppendFloat(buf, float64(*j.TaxRateForCalcs), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tax_rate_for_calcs":null`)
	}
	if j.TotalExpenses != nil {
		buf.WriteString(`,"total_expenses":`)
		fflib.AppendFloat(buf, float64(*j.TotalExpenses), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_expenses":null`)
	}
	if j.TotalRevenue != nil {
		buf.WriteString(`,"total_revenue":`)
		fflib.AppendFloat(buf, float64(*j.TotalRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_revenue":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtIncomeStatementbase = iota
	ffjtIncomeStatementnosuchkey

	ffjtIncomeStatementAccessionNumber

	ffjtIncomeStatementCostOfRevenue

	ffjtIncomeStatementCurrencyID

	ffjtIncomeStatementEBIT

	ffjtIncomeStatementEBITDA

	ffjtIncomeStatementFileDate

	ffjtIncomeStatementFiscalYearEnd

	ffjtIncomeStatementFormType

	ffjtIncomeStatementGrossProfit

	ffjtIncomeStatementInterestIncome

	ffjtIncomeStatementInterestIncomeNonOperating

	ffjtIncomeStatementInterestAndSimilarIncome

	ffjtIncomeStatementNetIncome

	ffjtIncomeStatementNetIncomeCommonStockholders

	ffjtIncomeStatementNetIncomeContinuousOperations

	ffjtIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation

	ffjtIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest

	ffjtIncomeStatementNetIncomeIncludingNoncontrollingInterests

	ffjtIncomeStatementNetInterestIncome

	ffjtIncomeStatementNetNonOperatingInterestIncomeExpense

	ffjtIncomeStatementNonOperatingExpenses

	ffjtIncomeStatementNonOperatingIncome

	ffjtIncomeStatementNormalizedEBITDA

	ffjtIncomeStatementNormalizedIncome

	ffjtIncomeStatementNumberOfShareHolders

	ffjtIncomeStatementOperatingExpense

	ffjtIncomeStatementOperatingIncome

	ffjtIncomeStatementOperatingRevenue

	ffjtIncomeStatementOtherIncomeExpense

	ffjtIncomeStatementPeriod

	ffjtIncomeStatementPeriodEndingDate

	ffjtIncomeStatementPretaxIncome

	ffjtIncomeStatementReconciledCostOfRevenue

	ffjtIncomeStatementReconciledDepreciation

	ffjtIncomeStatementReportType

	ffjtIncomeStatementResearchAndDevelopment

	ffjtIncomeStatementSellingGeneralAndAdministration

	ffjtIncomeStatementTaxEffectOfUnusualItems

	ffjtIncomeStatementTaxProvision

	ffjtIncomeStatementTaxRateForCalcs

	ffjtIncomeStatementTotalExpenses

	ffjtIncomeStatementTotalRevenue
)

var ffjKeyIncomeStatementAccessionNumber = []byte("accession_number")

var ffjKeyIncomeStatementCostOfRevenue = []byte("cost_of_revenue")

var ffjKeyIncomeStatementCurrencyID = []byte("currency_id")

var ffjKeyIncomeStatementEBIT = []byte("e_b_i_t")

var ffjKeyIncomeStatementEBITDA = []byte("e_b_i_t_d_a")

var ffjKeyIncomeStatementFileDate = []byte("file_date")

var ffjKeyIncomeStatementFiscalYearEnd = []byte("fiscal_year_end")

var ffjKeyIncomeStatementFormType = []byte("form_type")

var ffjKeyIncomeStatementGrossProfit = []byte("gross_profit")

var ffjKeyIncomeStatementInterestIncome = []byte("int64erest_income")

var ffjKeyIncomeStatementInterestIncomeNonOperating = []byte("int64erest_income_non_operating")

var ffjKeyIncomeStatementInterestAndSimilarIncome = []byte("int64erestand_similar_income")

var ffjKeyIncomeStatementNetIncome = []byte("net_income")

var ffjKeyIncomeStatementNetIncomeCommonStockholders = []byte("net_income_common_stockholders")

var ffjKeyIncomeStatementNetIncomeContinuousOperations = []byte("net_income_continuous_operations")

var ffjKeyIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation = []byte("net_income_from_continuing_and_discontinued_operation")

var ffjKeyIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest = []byte("net_income_from_continuing_operation_net_minority_int64erest")

var ffjKeyIncomeStatementNetIncomeIncludingNoncontrollingInterests = []byte("net_income_including_noncontrolling_int64erests")

var ffjKeyIncomeStatementNetInterestIncome = []byte("net_int64erest_income")

var ffjKeyIncomeStatementNetNonOperatingInterestIncomeExpense = []byte("net_non_operating_int64erest_income_expense")

var ffjKeyIncomeStatementNonOperatingExpenses = []byte("non_operating_expenses")

var ffjKeyIncomeStatementNonOperatingIncome = []byte("non_operating_income")

var ffjKeyIncomeStatementNormalizedEBITDA = []byte("normalized_e_b_i_t_d_a")

var ffjKeyIncomeStatementNormalizedIncome = []byte("normalized_income")

var ffjKeyIncomeStatementNumberOfShareHolders = []byte("number_of_share_holders")

var ffjKeyIncomeStatementOperatingExpense = []byte("operating_expense")

var ffjKeyIncomeStatementOperatingIncome = []byte("operating_income")

var ffjKeyIncomeStatementOperatingRevenue = []byte("operating_revenue")

var ffjKeyIncomeStatementOtherIncomeExpense = []byte("other_income_expense")

var ffjKeyIncomeStatementPeriod = []byte("period")

var ffjKeyIncomeStatementPeriodEndingDate = []byte("period_ending_date")

var ffjKeyIncomeStatementPretaxIncome = []byte("pretax_income")

var ffjKeyIncomeStatementReconciledCostOfRevenue = []byte("reconciled_cost_of_revenue")

var ffjKeyIncomeStatementReconciledDepreciation = []byte("reconciled_depreciation")

var ffjKeyIncomeStatementReportType = []byte("report_type")

var ffjKeyIncomeStatementResearchAndDevelopment = []byte("research_and_development")

var ffjKeyIncomeStatementSellingGeneralAndAdministration = []byte("selling_general_and_administration")

var ffjKeyIncomeStatementTaxEffectOfUnusualItems = []byte("tax_effect_of_unusual_items")

var ffjKeyIncomeStatementTaxProvision = []byte("tax_provision")

var ffjKeyIncomeStatementTaxRateForCalcs = []byte("tax_rate_for_calcs")

var ffjKeyIncomeStatementTotalExpenses = []byte("total_expenses")

var ffjKeyIncomeStatementTotalRevenue = []byte("total_revenue")

// UnmarshalJSON umarshall json - template of ffjson
func (j *IncomeStatement) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *IncomeStatement) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtIncomeStatementbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtIncomeStatementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyIncomeStatementAccessionNumber, kn) {
						currentKey = ffjtIncomeStatementAccessionNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyIncomeStatementCostOfRevenue, kn) {
						currentKey = ffjtIncomeStatementCostOfRevenue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementCurrencyID, kn) {
						currentKey = ffjtIncomeStatementCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyIncomeStatementEBIT, kn) {
						currentKey = ffjtIncomeStatementEBIT
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementEBITDA, kn) {
						currentKey = ffjtIncomeStatementEBITDA
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyIncomeStatementFileDate, kn) {
						currentKey = ffjtIncomeStatementFileDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementFiscalYearEnd, kn) {
						currentKey = ffjtIncomeStatementFiscalYearEnd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementFormType, kn) {
						currentKey = ffjtIncomeStatementFormType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyIncomeStatementGrossProfit, kn) {
						currentKey = ffjtIncomeStatementGrossProfit
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyIncomeStatementInterestIncome, kn) {
						currentKey = ffjtIncomeStatementInterestIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementInterestIncomeNonOperating, kn) {
						currentKey = ffjtIncomeStatementInterestIncomeNonOperating
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementInterestAndSimilarIncome, kn) {
						currentKey = ffjtIncomeStatementInterestAndSimilarIncome
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyIncomeStatementNetIncome, kn) {
						currentKey = ffjtIncomeStatementNetIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetIncomeCommonStockholders, kn) {
						currentKey = ffjtIncomeStatementNetIncomeCommonStockholders
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetIncomeContinuousOperations, kn) {
						currentKey = ffjtIncomeStatementNetIncomeContinuousOperations
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation, kn) {
						currentKey = ffjtIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest, kn) {
						currentKey = ffjtIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetIncomeIncludingNoncontrollingInterests, kn) {
						currentKey = ffjtIncomeStatementNetIncomeIncludingNoncontrollingInterests
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetInterestIncome, kn) {
						currentKey = ffjtIncomeStatementNetInterestIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNetNonOperatingInterestIncomeExpense, kn) {
						currentKey = ffjtIncomeStatementNetNonOperatingInterestIncomeExpense
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNonOperatingExpenses, kn) {
						currentKey = ffjtIncomeStatementNonOperatingExpenses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNonOperatingIncome, kn) {
						currentKey = ffjtIncomeStatementNonOperatingIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNormalizedEBITDA, kn) {
						currentKey = ffjtIncomeStatementNormalizedEBITDA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNormalizedIncome, kn) {
						currentKey = ffjtIncomeStatementNormalizedIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementNumberOfShareHolders, kn) {
						currentKey = ffjtIncomeStatementNumberOfShareHolders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyIncomeStatementOperatingExpense, kn) {
						currentKey = ffjtIncomeStatementOperatingExpense
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementOperatingIncome, kn) {
						currentKey = ffjtIncomeStatementOperatingIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementOperatingRevenue, kn) {
						currentKey = ffjtIncomeStatementOperatingRevenue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementOtherIncomeExpense, kn) {
						currentKey = ffjtIncomeStatementOtherIncomeExpense
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyIncomeStatementPeriod, kn) {
						currentKey = ffjtIncomeStatementPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementPeriodEndingDate, kn) {
						currentKey = ffjtIncomeStatementPeriodEndingDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementPretaxIncome, kn) {
						currentKey = ffjtIncomeStatementPretaxIncome
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyIncomeStatementReconciledCostOfRevenue, kn) {
						currentKey = ffjtIncomeStatementReconciledCostOfRevenue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementReconciledDepreciation, kn) {
						currentKey = ffjtIncomeStatementReconciledDepreciation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementReportType, kn) {
						currentKey = ffjtIncomeStatementReportType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementResearchAndDevelopment, kn) {
						currentKey = ffjtIncomeStatementResearchAndDevelopment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyIncomeStatementSellingGeneralAndAdministration, kn) {
						currentKey = ffjtIncomeStatementSellingGeneralAndAdministration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyIncomeStatementTaxEffectOfUnusualItems, kn) {
						currentKey = ffjtIncomeStatementTaxEffectOfUnusualItems
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementTaxProvision, kn) {
						currentKey = ffjtIncomeStatementTaxProvision
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementTaxRateForCalcs, kn) {
						currentKey = ffjtIncomeStatementTaxRateForCalcs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementTotalExpenses, kn) {
						currentKey = ffjtIncomeStatementTotalExpenses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyIncomeStatementTotalRevenue, kn) {
						currentKey = ffjtIncomeStatementTotalRevenue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementTotalRevenue, kn) {
					currentKey = ffjtIncomeStatementTotalRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementTotalExpenses, kn) {
					currentKey = ffjtIncomeStatementTotalExpenses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementTaxRateForCalcs, kn) {
					currentKey = ffjtIncomeStatementTaxRateForCalcs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementTaxProvision, kn) {
					currentKey = ffjtIncomeStatementTaxProvision
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementTaxEffectOfUnusualItems, kn) {
					currentKey = ffjtIncomeStatementTaxEffectOfUnusualItems
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementSellingGeneralAndAdministration, kn) {
					currentKey = ffjtIncomeStatementSellingGeneralAndAdministration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementResearchAndDevelopment, kn) {
					currentKey = ffjtIncomeStatementResearchAndDevelopment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementReportType, kn) {
					currentKey = ffjtIncomeStatementReportType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementReconciledDepreciation, kn) {
					currentKey = ffjtIncomeStatementReconciledDepreciation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementReconciledCostOfRevenue, kn) {
					currentKey = ffjtIncomeStatementReconciledCostOfRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementPretaxIncome, kn) {
					currentKey = ffjtIncomeStatementPretaxIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementPeriodEndingDate, kn) {
					currentKey = ffjtIncomeStatementPeriodEndingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyIncomeStatementPeriod, kn) {
					currentKey = ffjtIncomeStatementPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementOtherIncomeExpense, kn) {
					currentKey = ffjtIncomeStatementOtherIncomeExpense
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementOperatingRevenue, kn) {
					currentKey = ffjtIncomeStatementOperatingRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementOperatingIncome, kn) {
					currentKey = ffjtIncomeStatementOperatingIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementOperatingExpense, kn) {
					currentKey = ffjtIncomeStatementOperatingExpense
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNumberOfShareHolders, kn) {
					currentKey = ffjtIncomeStatementNumberOfShareHolders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementNormalizedIncome, kn) {
					currentKey = ffjtIncomeStatementNormalizedIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementNormalizedEBITDA, kn) {
					currentKey = ffjtIncomeStatementNormalizedEBITDA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementNonOperatingIncome, kn) {
					currentKey = ffjtIncomeStatementNonOperatingIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNonOperatingExpenses, kn) {
					currentKey = ffjtIncomeStatementNonOperatingExpenses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetNonOperatingInterestIncomeExpense, kn) {
					currentKey = ffjtIncomeStatementNetNonOperatingInterestIncomeExpense
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetInterestIncome, kn) {
					currentKey = ffjtIncomeStatementNetInterestIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetIncomeIncludingNoncontrollingInterests, kn) {
					currentKey = ffjtIncomeStatementNetIncomeIncludingNoncontrollingInterests
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest, kn) {
					currentKey = ffjtIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation, kn) {
					currentKey = ffjtIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetIncomeContinuousOperations, kn) {
					currentKey = ffjtIncomeStatementNetIncomeContinuousOperations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementNetIncomeCommonStockholders, kn) {
					currentKey = ffjtIncomeStatementNetIncomeCommonStockholders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementNetIncome, kn) {
					currentKey = ffjtIncomeStatementNetIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementInterestAndSimilarIncome, kn) {
					currentKey = ffjtIncomeStatementInterestAndSimilarIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementInterestIncomeNonOperating, kn) {
					currentKey = ffjtIncomeStatementInterestIncomeNonOperating
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementInterestIncome, kn) {
					currentKey = ffjtIncomeStatementInterestIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementGrossProfit, kn) {
					currentKey = ffjtIncomeStatementGrossProfit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementFormType, kn) {
					currentKey = ffjtIncomeStatementFormType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementFiscalYearEnd, kn) {
					currentKey = ffjtIncomeStatementFiscalYearEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementFileDate, kn) {
					currentKey = ffjtIncomeStatementFileDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementEBITDA, kn) {
					currentKey = ffjtIncomeStatementEBITDA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementEBIT, kn) {
					currentKey = ffjtIncomeStatementEBIT
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyIncomeStatementCurrencyID, kn) {
					currentKey = ffjtIncomeStatementCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementCostOfRevenue, kn) {
					currentKey = ffjtIncomeStatementCostOfRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyIncomeStatementAccessionNumber, kn) {
					currentKey = ffjtIncomeStatementAccessionNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtIncomeStatementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtIncomeStatementAccessionNumber:
					goto handle_AccessionNumber

				case ffjtIncomeStatementCostOfRevenue:
					goto handle_CostOfRevenue

				case ffjtIncomeStatementCurrencyID:
					goto handle_CurrencyID

				case ffjtIncomeStatementEBIT:
					goto handle_EBIT

				case ffjtIncomeStatementEBITDA:
					goto handle_EBITDA

				case ffjtIncomeStatementFileDate:
					goto handle_FileDate

				case ffjtIncomeStatementFiscalYearEnd:
					goto handle_FiscalYearEnd

				case ffjtIncomeStatementFormType:
					goto handle_FormType

				case ffjtIncomeStatementGrossProfit:
					goto handle_GrossProfit

				case ffjtIncomeStatementInterestIncome:
					goto handle_InterestIncome

				case ffjtIncomeStatementInterestIncomeNonOperating:
					goto handle_InterestIncomeNonOperating

				case ffjtIncomeStatementInterestAndSimilarIncome:
					goto handle_InterestAndSimilarIncome

				case ffjtIncomeStatementNetIncome:
					goto handle_NetIncome

				case ffjtIncomeStatementNetIncomeCommonStockholders:
					goto handle_NetIncomeCommonStockholders

				case ffjtIncomeStatementNetIncomeContinuousOperations:
					goto handle_NetIncomeContinuousOperations

				case ffjtIncomeStatementNetIncomeFromContinuingAndDiscontinuedOperation:
					goto handle_NetIncomeFromContinuingAndDiscontinuedOperation

				case ffjtIncomeStatementNetIncomeFromContinuingOperationNetMinorityInterest:
					goto handle_NetIncomeFromContinuingOperationNetMinorityInterest

				case ffjtIncomeStatementNetIncomeIncludingNoncontrollingInterests:
					goto handle_NetIncomeIncludingNoncontrollingInterests

				case ffjtIncomeStatementNetInterestIncome:
					goto handle_NetInterestIncome

				case ffjtIncomeStatementNetNonOperatingInterestIncomeExpense:
					goto handle_NetNonOperatingInterestIncomeExpense

				case ffjtIncomeStatementNonOperatingExpenses:
					goto handle_NonOperatingExpenses

				case ffjtIncomeStatementNonOperatingIncome:
					goto handle_NonOperatingIncome

				case ffjtIncomeStatementNormalizedEBITDA:
					goto handle_NormalizedEBITDA

				case ffjtIncomeStatementNormalizedIncome:
					goto handle_NormalizedIncome

				case ffjtIncomeStatementNumberOfShareHolders:
					goto handle_NumberOfShareHolders

				case ffjtIncomeStatementOperatingExpense:
					goto handle_OperatingExpense

				case ffjtIncomeStatementOperatingIncome:
					goto handle_OperatingIncome

				case ffjtIncomeStatementOperatingRevenue:
					goto handle_OperatingRevenue

				case ffjtIncomeStatementOtherIncomeExpense:
					goto handle_OtherIncomeExpense

				case ffjtIncomeStatementPeriod:
					goto handle_Period

				case ffjtIncomeStatementPeriodEndingDate:
					goto handle_PeriodEndingDate

				case ffjtIncomeStatementPretaxIncome:
					goto handle_PretaxIncome

				case ffjtIncomeStatementReconciledCostOfRevenue:
					goto handle_ReconciledCostOfRevenue

				case ffjtIncomeStatementReconciledDepreciation:
					goto handle_ReconciledDepreciation

				case ffjtIncomeStatementReportType:
					goto handle_ReportType

				case ffjtIncomeStatementResearchAndDevelopment:
					goto handle_ResearchAndDevelopment

				case ffjtIncomeStatementSellingGeneralAndAdministration:
					goto handle_SellingGeneralAndAdministration

				case ffjtIncomeStatementTaxEffectOfUnusualItems:
					goto handle_TaxEffectOfUnusualItems

				case ffjtIncomeStatementTaxProvision:
					goto handle_TaxProvision

				case ffjtIncomeStatementTaxRateForCalcs:
					goto handle_TaxRateForCalcs

				case ffjtIncomeStatementTotalExpenses:
					goto handle_TotalExpenses

				case ffjtIncomeStatementTotalRevenue:
					goto handle_TotalRevenue

				case ffjtIncomeStatementnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccessionNumber:

	/* handler: j.AccessionNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AccessionNumber = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AccessionNumber = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CostOfRevenue:

	/* handler: j.CostOfRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CostOfRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CostOfRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EBIT:

	/* handler: j.EBIT type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EBIT = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EBIT = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EBITDA:

	/* handler: j.EBITDA type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EBITDA = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EBITDA = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileDate:

	/* handler: j.FileDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FileDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FileDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FiscalYearEnd:

	/* handler: j.FiscalYearEnd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FiscalYearEnd = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FiscalYearEnd = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FormType:

	/* handler: j.FormType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FormType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FormType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrossProfit:

	/* handler: j.GrossProfit type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GrossProfit = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GrossProfit = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InterestIncome:

	/* handler: j.InterestIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InterestIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InterestIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InterestIncomeNonOperating:

	/* handler: j.InterestIncomeNonOperating type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InterestIncomeNonOperating = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InterestIncomeNonOperating = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InterestAndSimilarIncome:

	/* handler: j.InterestAndSimilarIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InterestAndSimilarIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InterestAndSimilarIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncome:

	/* handler: j.NetIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeCommonStockholders:

	/* handler: j.NetIncomeCommonStockholders type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeCommonStockholders = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeCommonStockholders = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeContinuousOperations:

	/* handler: j.NetIncomeContinuousOperations type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeContinuousOperations = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeContinuousOperations = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeFromContinuingAndDiscontinuedOperation:

	/* handler: j.NetIncomeFromContinuingAndDiscontinuedOperation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeFromContinuingAndDiscontinuedOperation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeFromContinuingAndDiscontinuedOperation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeFromContinuingOperationNetMinorityInterest:

	/* handler: j.NetIncomeFromContinuingOperationNetMinorityInterest type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeFromContinuingOperationNetMinorityInterest = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeFromContinuingOperationNetMinorityInterest = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeIncludingNoncontrollingInterests:

	/* handler: j.NetIncomeIncludingNoncontrollingInterests type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeIncludingNoncontrollingInterests = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeIncludingNoncontrollingInterests = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetInterestIncome:

	/* handler: j.NetInterestIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetInterestIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetInterestIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetNonOperatingInterestIncomeExpense:

	/* handler: j.NetNonOperatingInterestIncomeExpense type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetNonOperatingInterestIncomeExpense = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetNonOperatingInterestIncomeExpense = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonOperatingExpenses:

	/* handler: j.NonOperatingExpenses type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonOperatingExpenses = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonOperatingExpenses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NonOperatingIncome:

	/* handler: j.NonOperatingIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NonOperatingIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NonOperatingIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedEBITDA:

	/* handler: j.NormalizedEBITDA type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedEBITDA = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedEBITDA = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedIncome:

	/* handler: j.NormalizedIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfShareHolders:

	/* handler: j.NumberOfShareHolders type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NumberOfShareHolders = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.NumberOfShareHolders = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperatingExpense:

	/* handler: j.OperatingExpense type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperatingExpense = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperatingExpense = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperatingIncome:

	/* handler: j.OperatingIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperatingIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperatingIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperatingRevenue:

	/* handler: j.OperatingRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperatingRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperatingRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OtherIncomeExpense:

	/* handler: j.OtherIncomeExpense type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OtherIncomeExpense = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OtherIncomeExpense = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PeriodEndingDate:

	/* handler: j.PeriodEndingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.PeriodEndingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.PeriodEndingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PretaxIncome:

	/* handler: j.PretaxIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PretaxIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PretaxIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReconciledCostOfRevenue:

	/* handler: j.ReconciledCostOfRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ReconciledCostOfRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ReconciledCostOfRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReconciledDepreciation:

	/* handler: j.ReconciledDepreciation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ReconciledDepreciation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ReconciledDepreciation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReportType:

	/* handler: j.ReportType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ReportType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ReportType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResearchAndDevelopment:

	/* handler: j.ResearchAndDevelopment type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ResearchAndDevelopment = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ResearchAndDevelopment = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SellingGeneralAndAdministration:

	/* handler: j.SellingGeneralAndAdministration type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SellingGeneralAndAdministration = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SellingGeneralAndAdministration = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaxEffectOfUnusualItems:

	/* handler: j.TaxEffectOfUnusualItems type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TaxEffectOfUnusualItems = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TaxEffectOfUnusualItems = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaxProvision:

	/* handler: j.TaxProvision type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TaxProvision = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TaxProvision = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaxRateForCalcs:

	/* handler: j.TaxRateForCalcs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TaxRateForCalcs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TaxRateForCalcs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalExpenses:

	/* handler: j.TotalExpenses type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalExpenses = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalExpenses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalRevenue:

	/* handler: j.TotalRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MergerAndAcquisition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MergerAndAcquisition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AcquiredCompanyID != nil {
		buf.WriteString(`{"acquired_company_id":`)
		fflib.WriteJsonString(buf, string(*j.AcquiredCompanyID))
	} else {
		buf.WriteString(`{"acquired_company_id":null`)
	}
	if j.CashAmount != nil {
		buf.WriteString(`,"cash_amount":`)
		fflib.AppendFloat(buf, float64(*j.CashAmount), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cash_amount":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_id":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_id":null`)
	}
	if j.EffectiveDate != nil {
		buf.WriteString(`,"effective_date":`)
		fflib.WriteJsonString(buf, string(*j.EffectiveDate))
	} else {
		buf.WriteString(`,"effective_date":null`)
	}
	if j.Notes != nil {
		buf.WriteString(`,"notes":`)
		fflib.WriteJsonString(buf, string(*j.Notes))
	} else {
		buf.WriteString(`,"notes":null`)
	}
	if j.ParentCompanyID != nil {
		buf.WriteString(`,"parent_company_id":`)
		fflib.WriteJsonString(buf, string(*j.ParentCompanyID))
	} else {
		buf.WriteString(`,"parent_company_id":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMergerAndAcquisitionbase = iota
	ffjtMergerAndAcquisitionnosuchkey

	ffjtMergerAndAcquisitionAcquiredCompanyID

	ffjtMergerAndAcquisitionCashAmount

	ffjtMergerAndAcquisitionCurrencyID

	ffjtMergerAndAcquisitionEffectiveDate

	ffjtMergerAndAcquisitionNotes

	ffjtMergerAndAcquisitionParentCompanyID
)

var ffjKeyMergerAndAcquisitionAcquiredCompanyID = []byte("acquired_company_id")

var ffjKeyMergerAndAcquisitionCashAmount = []byte("cash_amount")

var ffjKeyMergerAndAcquisitionCurrencyID = []byte("currency_id")

var ffjKeyMergerAndAcquisitionEffectiveDate = []byte("effective_date")

var ffjKeyMergerAndAcquisitionNotes = []byte("notes")

var ffjKeyMergerAndAcquisitionParentCompanyID = []byte("parent_company_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MergerAndAcquisition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MergerAndAcquisition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMergerAndAcquisitionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMergerAndAcquisitionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMergerAndAcquisitionAcquiredCompanyID, kn) {
						currentKey = ffjtMergerAndAcquisitionAcquiredCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMergerAndAcquisitionCashAmount, kn) {
						currentKey = ffjtMergerAndAcquisitionCashAmount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMergerAndAcquisitionCurrencyID, kn) {
						currentKey = ffjtMergerAndAcquisitionCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMergerAndAcquisitionEffectiveDate, kn) {
						currentKey = ffjtMergerAndAcquisitionEffectiveDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMergerAndAcquisitionNotes, kn) {
						currentKey = ffjtMergerAndAcquisitionNotes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMergerAndAcquisitionParentCompanyID, kn) {
						currentKey = ffjtMergerAndAcquisitionParentCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyMergerAndAcquisitionParentCompanyID, kn) {
					currentKey = ffjtMergerAndAcquisitionParentCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMergerAndAcquisitionNotes, kn) {
					currentKey = ffjtMergerAndAcquisitionNotes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMergerAndAcquisitionEffectiveDate, kn) {
					currentKey = ffjtMergerAndAcquisitionEffectiveDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMergerAndAcquisitionCurrencyID, kn) {
					currentKey = ffjtMergerAndAcquisitionCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMergerAndAcquisitionCashAmount, kn) {
					currentKey = ffjtMergerAndAcquisitionCashAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMergerAndAcquisitionAcquiredCompanyID, kn) {
					currentKey = ffjtMergerAndAcquisitionAcquiredCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMergerAndAcquisitionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMergerAndAcquisitionAcquiredCompanyID:
					goto handle_AcquiredCompanyID

				case ffjtMergerAndAcquisitionCashAmount:
					goto handle_CashAmount

				case ffjtMergerAndAcquisitionCurrencyID:
					goto handle_CurrencyID

				case ffjtMergerAndAcquisitionEffectiveDate:
					goto handle_EffectiveDate

				case ffjtMergerAndAcquisitionNotes:
					goto handle_Notes

				case ffjtMergerAndAcquisitionParentCompanyID:
					goto handle_ParentCompanyID

				case ffjtMergerAndAcquisitionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AcquiredCompanyID:

	/* handler: j.AcquiredCompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AcquiredCompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AcquiredCompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashAmount:

	/* handler: j.CashAmount type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashAmount = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashAmount = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EffectiveDate:

	/* handler: j.EffectiveDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.EffectiveDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.EffectiveDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notes:

	/* handler: j.Notes type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Notes = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Notes = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParentCompanyID:

	/* handler: j.ParentCompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ParentCompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ParentCompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OperationRatio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OperationRatio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.AssetsTurnover != nil {
		buf.WriteString(`,"assets_turnover":`)
		fflib.AppendFloat(buf, float64(*j.AssetsTurnover), 'g', -1, 64)
	} else {
		buf.WriteString(`,"assets_turnover":null`)
	}
	if j.CapExSalesRatio != nil {
		buf.WriteString(`,"cap_ex_sales_ratio":`)
		fflib.AppendFloat(buf, float64(*j.CapExSalesRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cap_ex_sales_ratio":null`)
	}
	if j.CashConversionCycle != nil {
		buf.WriteString(`,"cash_conversion_cycle":`)
		fflib.AppendFloat(buf, float64(*j.CashConversionCycle), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cash_conversion_cycle":null`)
	}
	if j.CommonEquityToAssets != nil {
		buf.WriteString(`,"common_equity_to_assets":`)
		fflib.AppendFloat(buf, float64(*j.CommonEquityToAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"common_equity_to_assets":null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	if j.CurrentRatio != nil {
		buf.WriteString(`,"current_ratio":`)
		fflib.AppendFloat(buf, float64(*j.CurrentRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"current_ratio":null`)
	}
	if j.DaysInInventory != nil {
		buf.WriteString(`,"days_in_inventory":`)
		fflib.AppendFloat(buf, float64(*j.DaysInInventory), 'g', -1, 64)
	} else {
		buf.WriteString(`,"days_in_inventory":null`)
	}
	if j.DaysInPayment != nil {
		buf.WriteString(`,"days_in_payment":`)
		fflib.AppendFloat(buf, float64(*j.DaysInPayment), 'g', -1, 64)
	} else {
		buf.WriteString(`,"days_in_payment":null`)
	}
	if j.DaysInSales != nil {
		buf.WriteString(`,"days_in_sales":`)
		fflib.AppendFloat(buf, float64(*j.DaysInSales), 'g', -1, 64)
	} else {
		buf.WriteString(`,"days_in_sales":null`)
	}
	if j.DebtToAssets != nil {
		buf.WriteString(`,"debt_to_assets":`)
		fflib.AppendFloat(buf, float64(*j.DebtToAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"debt_to_assets":null`)
	}
	if j.EBITDAMargin != nil {
		buf.WriteString(`,"e_b_i_t_d_a_margin":`)
		fflib.AppendFloat(buf, float64(*j.EBITDAMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"e_b_i_t_d_a_margin":null`)
	}
	if j.EBITMargin != nil {
		buf.WriteString(`,"e_b_i_t_margin":`)
		fflib.AppendFloat(buf, float64(*j.EBITMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"e_b_i_t_margin":null`)
	}
	if j.FCFNetIncomeRatio != nil {
		buf.WriteString(`,"f_c_f_net_income_ratio":`)
		fflib.AppendFloat(buf, float64(*j.FCFNetIncomeRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"f_c_f_net_income_ratio":null`)
	}
	if j.FCFSalesRatio != nil {
		buf.WriteString(`,"f_c_f_sales_ratio":`)
		fflib.AppendFloat(buf, float64(*j.FCFSalesRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"f_c_f_sales_ratio":null`)
	}
	if j.FinancialLeverage != nil {
		buf.WriteString(`,"financial_leverage":`)
		fflib.AppendFloat(buf, float64(*j.FinancialLeverage), 'g', -1, 64)
	} else {
		buf.WriteString(`,"financial_leverage":null`)
	}
	if j.FiscalYearEnd != nil {
		buf.WriteString(`,"fiscal_year_end":`)
		fflib.WriteJsonString(buf, string(*j.FiscalYearEnd))
	} else {
		buf.WriteString(`,"fiscal_year_end":null`)
	}
	if j.FixAssetsTurnover != nil {
		buf.WriteString(`,"fix_assets_turonver":`)
		fflib.AppendFloat(buf, float64(*j.FixAssetsTurnover), 'g', -1, 64)
	} else {
		buf.WriteString(`,"fix_assets_turonver":null`)
	}
	if j.GrossMargin != nil {
		buf.WriteString(`,"gross_margin":`)
		fflib.AppendFloat(buf, float64(*j.GrossMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"gross_margin":null`)
	}
	if j.InterestCoverage != nil {
		buf.WriteString(`,"int64erest_coverage":`)
		fflib.AppendFloat(buf, float64(*j.InterestCoverage), 'g', -1, 64)
	} else {
		buf.WriteString(`,"int64erest_coverage":null`)
	}
	if j.InventoryTurnover != nil {
		buf.WriteString(`,"inventory_turnover":`)
		fflib.AppendFloat(buf, float64(*j.InventoryTurnover), 'g', -1, 64)
	} else {
		buf.WriteString(`,"inventory_turnover":null`)
	}
	if j.LongTermDebtEquityRatio != nil {
		buf.WriteString(`,"long_term_debt_equity_ratio":`)
		fflib.AppendFloat(buf, float64(*j.LongTermDebtEquityRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"long_term_debt_equity_ratio":null`)
	}
	if j.LongTermDebtTotalCapitalRatio != nil {
		buf.WriteString(`,"long_term_debt_total_capital_ratio":`)
		fflib.AppendFloat(buf, float64(*j.LongTermDebtTotalCapitalRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"long_term_debt_total_capital_ratio":null`)
	}
	if j.NetIncomeGrowth != nil {
		buf.WriteString(`,"net_income_growth":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeGrowth), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_growth":null`)
	}
	if j.NetIncomeContOpsGrowth != nil {
		buf.WriteString(`,"net_income_cont_ops_growth":`)
		fflib.AppendFloat(buf, float64(*j.NetIncomeContOpsGrowth), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_income_cont_ops_growth":null`)
	}
	if j.NetMargin != nil {
		buf.WriteString(`,"net_margin":`)
		fflib.AppendFloat(buf, float64(*j.NetMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"net_margin":null`)
	}
	if j.NormalizedNetProfitMargin != nil {
		buf.WriteString(`,"normalized_net_profit_margin":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedNetProfitMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_net_profit_margin":null`)
	}
	if j.NormalizedROIC != nil {
		buf.WriteString(`,"normalized_r_o_i_c":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedROIC), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_r_o_i_c":null`)
	}
	if j.OperationIncomeGrowth != nil {
		buf.WriteString(`,"operation_income_growth":`)
		fflib.AppendFloat(buf, float64(*j.OperationIncomeGrowth), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operation_income_growth":null`)
	}
	if j.OperationMargin != nil {
		buf.WriteString(`,"operation_margin":`)
		fflib.AppendFloat(buf, float64(*j.OperationMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operation_margin":null`)
	}
	if j.PaymentTurnover != nil {
		buf.WriteString(`,"payment_turnover":`)
		fflib.AppendFloat(buf, float64(*j.PaymentTurnover), 'g', -1, 64)
	} else {
		buf.WriteString(`,"payment_turnover":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.PretaxMargin != nil {
		buf.WriteString(`,"pretax_margin":`)
		fflib.AppendFloat(buf, float64(*j.PretaxMargin), 'g', -1, 64)
	} else {
		buf.WriteString(`,"pretax_margin":null`)
	}
	if j.QuickRatio != nil {
		buf.WriteString(`,"quick_ratio":`)
		fflib.AppendFloat(buf, float64(*j.QuickRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"quick_ratio":null`)
	}
	if j.ROA != nil {
		buf.WriteString(`,"r_o_a":`)
		fflib.AppendFloat(buf, float64(*j.ROA), 'g', -1, 64)
	} else {
		buf.WriteString(`,"r_o_a":null`)
	}
	if j.ROE != nil {
		buf.WriteString(`,"r_o_e":`)
		fflib.AppendFloat(buf, float64(*j.ROE), 'g', -1, 64)
	} else {
		buf.WriteString(`,"r_o_e":null`)
	}
	if j.ROIC != nil {
		buf.WriteString(`,"r_o_i_c":`)
		fflib.AppendFloat(buf, float64(*j.ROIC), 'g', -1, 64)
	} else {
		buf.WriteString(`,"r_o_i_c":null`)
	}
	if j.ReceivableTurnover != nil {
		buf.WriteString(`,"receivable_turnover":`)
		fflib.AppendFloat(buf, float64(*j.ReceivableTurnover), 'g', -1, 64)
	} else {
		buf.WriteString(`,"receivable_turnover":null`)
	}
	if j.ReportType != nil {
		buf.WriteString(`,"report_type":`)
		fflib.WriteJsonString(buf, string(*j.ReportType))
	} else {
		buf.WriteString(`,"report_type":null`)
	}
	if j.SalesPerEmployee != nil {
		buf.WriteString(`,"sales_per_employee":`)
		fflib.AppendFloat(buf, float64(*j.SalesPerEmployee), 'g', -1, 64)
	} else {
		buf.WriteString(`,"sales_per_employee":null`)
	}
	if j.TaxRate != nil {
		buf.WriteString(`,"tax_rate":`)
		fflib.AppendFloat(buf, float64(*j.TaxRate), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tax_rate":null`)
	}
	if j.TotalDebtEquityRatio != nil {
		buf.WriteString(`,"total_debt_equity_ratio":`)
		fflib.AppendFloat(buf, float64(*j.TotalDebtEquityRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_debt_equity_ratio":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOperationRatiobase = iota
	ffjtOperationRationosuchkey

	ffjtOperationRatioAsOfDate

	ffjtOperationRatioAssetsTurnover

	ffjtOperationRatioCapExSalesRatio

	ffjtOperationRatioCashConversionCycle

	ffjtOperationRatioCommonEquityToAssets

	ffjtOperationRatioCompanyID

	ffjtOperationRatioCurrentRatio

	ffjtOperationRatioDaysInInventory

	ffjtOperationRatioDaysInPayment

	ffjtOperationRatioDaysInSales

	ffjtOperationRatioDebtToAssets

	ffjtOperationRatioEBITDAMargin

	ffjtOperationRatioEBITMargin

	ffjtOperationRatioFCFNetIncomeRatio

	ffjtOperationRatioFCFSalesRatio

	ffjtOperationRatioFinancialLeverage

	ffjtOperationRatioFiscalYearEnd

	ffjtOperationRatioFixAssetsTurnover

	ffjtOperationRatioGrossMargin

	ffjtOperationRatioInterestCoverage

	ffjtOperationRatioInventoryTurnover

	ffjtOperationRatioLongTermDebtEquityRatio

	ffjtOperationRatioLongTermDebtTotalCapitalRatio

	ffjtOperationRatioNetIncomeGrowth

	ffjtOperationRatioNetIncomeContOpsGrowth

	ffjtOperationRatioNetMargin

	ffjtOperationRatioNormalizedNetProfitMargin

	ffjtOperationRatioNormalizedROIC

	ffjtOperationRatioOperationIncomeGrowth

	ffjtOperationRatioOperationMargin

	ffjtOperationRatioPaymentTurnover

	ffjtOperationRatioPeriod

	ffjtOperationRatioPretaxMargin

	ffjtOperationRatioQuickRatio

	ffjtOperationRatioROA

	ffjtOperationRatioROE

	ffjtOperationRatioROIC

	ffjtOperationRatioReceivableTurnover

	ffjtOperationRatioReportType

	ffjtOperationRatioSalesPerEmployee

	ffjtOperationRatioTaxRate

	ffjtOperationRatioTotalDebtEquityRatio
)

var ffjKeyOperationRatioAsOfDate = []byte("as_of_date")

var ffjKeyOperationRatioAssetsTurnover = []byte("assets_turnover")

var ffjKeyOperationRatioCapExSalesRatio = []byte("cap_ex_sales_ratio")

var ffjKeyOperationRatioCashConversionCycle = []byte("cash_conversion_cycle")

var ffjKeyOperationRatioCommonEquityToAssets = []byte("common_equity_to_assets")

var ffjKeyOperationRatioCompanyID = []byte("company_id")

var ffjKeyOperationRatioCurrentRatio = []byte("current_ratio")

var ffjKeyOperationRatioDaysInInventory = []byte("days_in_inventory")

var ffjKeyOperationRatioDaysInPayment = []byte("days_in_payment")

var ffjKeyOperationRatioDaysInSales = []byte("days_in_sales")

var ffjKeyOperationRatioDebtToAssets = []byte("debt_to_assets")

var ffjKeyOperationRatioEBITDAMargin = []byte("e_b_i_t_d_a_margin")

var ffjKeyOperationRatioEBITMargin = []byte("e_b_i_t_margin")

var ffjKeyOperationRatioFCFNetIncomeRatio = []byte("f_c_f_net_income_ratio")

var ffjKeyOperationRatioFCFSalesRatio = []byte("f_c_f_sales_ratio")

var ffjKeyOperationRatioFinancialLeverage = []byte("financial_leverage")

var ffjKeyOperationRatioFiscalYearEnd = []byte("fiscal_year_end")

var ffjKeyOperationRatioFixAssetsTurnover = []byte("fix_assets_turonver")

var ffjKeyOperationRatioGrossMargin = []byte("gross_margin")

var ffjKeyOperationRatioInterestCoverage = []byte("int64erest_coverage")

var ffjKeyOperationRatioInventoryTurnover = []byte("inventory_turnover")

var ffjKeyOperationRatioLongTermDebtEquityRatio = []byte("long_term_debt_equity_ratio")

var ffjKeyOperationRatioLongTermDebtTotalCapitalRatio = []byte("long_term_debt_total_capital_ratio")

var ffjKeyOperationRatioNetIncomeGrowth = []byte("net_income_growth")

var ffjKeyOperationRatioNetIncomeContOpsGrowth = []byte("net_income_cont_ops_growth")

var ffjKeyOperationRatioNetMargin = []byte("net_margin")

var ffjKeyOperationRatioNormalizedNetProfitMargin = []byte("normalized_net_profit_margin")

var ffjKeyOperationRatioNormalizedROIC = []byte("normalized_r_o_i_c")

var ffjKeyOperationRatioOperationIncomeGrowth = []byte("operation_income_growth")

var ffjKeyOperationRatioOperationMargin = []byte("operation_margin")

var ffjKeyOperationRatioPaymentTurnover = []byte("payment_turnover")

var ffjKeyOperationRatioPeriod = []byte("period")

var ffjKeyOperationRatioPretaxMargin = []byte("pretax_margin")

var ffjKeyOperationRatioQuickRatio = []byte("quick_ratio")

var ffjKeyOperationRatioROA = []byte("r_o_a")

var ffjKeyOperationRatioROE = []byte("r_o_e")

var ffjKeyOperationRatioROIC = []byte("r_o_i_c")

var ffjKeyOperationRatioReceivableTurnover = []byte("receivable_turnover")

var ffjKeyOperationRatioReportType = []byte("report_type")

var ffjKeyOperationRatioSalesPerEmployee = []byte("sales_per_employee")

var ffjKeyOperationRatioTaxRate = []byte("tax_rate")

var ffjKeyOperationRatioTotalDebtEquityRatio = []byte("total_debt_equity_ratio")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OperationRatio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OperationRatio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOperationRatiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOperationRationosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyOperationRatioAsOfDate, kn) {
						currentKey = ffjtOperationRatioAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioAssetsTurnover, kn) {
						currentKey = ffjtOperationRatioAssetsTurnover
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyOperationRatioCapExSalesRatio, kn) {
						currentKey = ffjtOperationRatioCapExSalesRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioCashConversionCycle, kn) {
						currentKey = ffjtOperationRatioCashConversionCycle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioCommonEquityToAssets, kn) {
						currentKey = ffjtOperationRatioCommonEquityToAssets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioCompanyID, kn) {
						currentKey = ffjtOperationRatioCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioCurrentRatio, kn) {
						currentKey = ffjtOperationRatioCurrentRatio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyOperationRatioDaysInInventory, kn) {
						currentKey = ffjtOperationRatioDaysInInventory
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioDaysInPayment, kn) {
						currentKey = ffjtOperationRatioDaysInPayment
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioDaysInSales, kn) {
						currentKey = ffjtOperationRatioDaysInSales
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioDebtToAssets, kn) {
						currentKey = ffjtOperationRatioDebtToAssets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyOperationRatioEBITDAMargin, kn) {
						currentKey = ffjtOperationRatioEBITDAMargin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioEBITMargin, kn) {
						currentKey = ffjtOperationRatioEBITMargin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyOperationRatioFCFNetIncomeRatio, kn) {
						currentKey = ffjtOperationRatioFCFNetIncomeRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioFCFSalesRatio, kn) {
						currentKey = ffjtOperationRatioFCFSalesRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioFinancialLeverage, kn) {
						currentKey = ffjtOperationRatioFinancialLeverage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioFiscalYearEnd, kn) {
						currentKey = ffjtOperationRatioFiscalYearEnd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioFixAssetsTurnover, kn) {
						currentKey = ffjtOperationRatioFixAssetsTurnover
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyOperationRatioGrossMargin, kn) {
						currentKey = ffjtOperationRatioGrossMargin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyOperationRatioInterestCoverage, kn) {
						currentKey = ffjtOperationRatioInterestCoverage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioInventoryTurnover, kn) {
						currentKey = ffjtOperationRatioInventoryTurnover
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyOperationRatioLongTermDebtEquityRatio, kn) {
						currentKey = ffjtOperationRatioLongTermDebtEquityRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioLongTermDebtTotalCapitalRatio, kn) {
						currentKey = ffjtOperationRatioLongTermDebtTotalCapitalRatio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyOperationRatioNetIncomeGrowth, kn) {
						currentKey = ffjtOperationRatioNetIncomeGrowth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioNetIncomeContOpsGrowth, kn) {
						currentKey = ffjtOperationRatioNetIncomeContOpsGrowth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioNetMargin, kn) {
						currentKey = ffjtOperationRatioNetMargin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioNormalizedNetProfitMargin, kn) {
						currentKey = ffjtOperationRatioNormalizedNetProfitMargin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioNormalizedROIC, kn) {
						currentKey = ffjtOperationRatioNormalizedROIC
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyOperationRatioOperationIncomeGrowth, kn) {
						currentKey = ffjtOperationRatioOperationIncomeGrowth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioOperationMargin, kn) {
						currentKey = ffjtOperationRatioOperationMargin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyOperationRatioPaymentTurnover, kn) {
						currentKey = ffjtOperationRatioPaymentTurnover
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioPeriod, kn) {
						currentKey = ffjtOperationRatioPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioPretaxMargin, kn) {
						currentKey = ffjtOperationRatioPretaxMargin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyOperationRatioQuickRatio, kn) {
						currentKey = ffjtOperationRatioQuickRatio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyOperationRatioROA, kn) {
						currentKey = ffjtOperationRatioROA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioROE, kn) {
						currentKey = ffjtOperationRatioROE
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioROIC, kn) {
						currentKey = ffjtOperationRatioROIC
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioReceivableTurnover, kn) {
						currentKey = ffjtOperationRatioReceivableTurnover
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioReportType, kn) {
						currentKey = ffjtOperationRatioReportType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOperationRatioSalesPerEmployee, kn) {
						currentKey = ffjtOperationRatioSalesPerEmployee
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyOperationRatioTaxRate, kn) {
						currentKey = ffjtOperationRatioTaxRate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOperationRatioTotalDebtEquityRatio, kn) {
						currentKey = ffjtOperationRatioTotalDebtEquityRatio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioTotalDebtEquityRatio, kn) {
					currentKey = ffjtOperationRatioTotalDebtEquityRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioTaxRate, kn) {
					currentKey = ffjtOperationRatioTaxRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioSalesPerEmployee, kn) {
					currentKey = ffjtOperationRatioSalesPerEmployee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioReportType, kn) {
					currentKey = ffjtOperationRatioReportType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioReceivableTurnover, kn) {
					currentKey = ffjtOperationRatioReceivableTurnover
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioROIC, kn) {
					currentKey = ffjtOperationRatioROIC
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioROE, kn) {
					currentKey = ffjtOperationRatioROE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioROA, kn) {
					currentKey = ffjtOperationRatioROA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioQuickRatio, kn) {
					currentKey = ffjtOperationRatioQuickRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioPretaxMargin, kn) {
					currentKey = ffjtOperationRatioPretaxMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOperationRatioPeriod, kn) {
					currentKey = ffjtOperationRatioPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioPaymentTurnover, kn) {
					currentKey = ffjtOperationRatioPaymentTurnover
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioOperationMargin, kn) {
					currentKey = ffjtOperationRatioOperationMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioOperationIncomeGrowth, kn) {
					currentKey = ffjtOperationRatioOperationIncomeGrowth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioNormalizedROIC, kn) {
					currentKey = ffjtOperationRatioNormalizedROIC
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioNormalizedNetProfitMargin, kn) {
					currentKey = ffjtOperationRatioNormalizedNetProfitMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioNetMargin, kn) {
					currentKey = ffjtOperationRatioNetMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioNetIncomeContOpsGrowth, kn) {
					currentKey = ffjtOperationRatioNetIncomeContOpsGrowth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioNetIncomeGrowth, kn) {
					currentKey = ffjtOperationRatioNetIncomeGrowth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioLongTermDebtTotalCapitalRatio, kn) {
					currentKey = ffjtOperationRatioLongTermDebtTotalCapitalRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioLongTermDebtEquityRatio, kn) {
					currentKey = ffjtOperationRatioLongTermDebtEquityRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioInventoryTurnover, kn) {
					currentKey = ffjtOperationRatioInventoryTurnover
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioInterestCoverage, kn) {
					currentKey = ffjtOperationRatioInterestCoverage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioGrossMargin, kn) {
					currentKey = ffjtOperationRatioGrossMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioFixAssetsTurnover, kn) {
					currentKey = ffjtOperationRatioFixAssetsTurnover
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioFiscalYearEnd, kn) {
					currentKey = ffjtOperationRatioFiscalYearEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioFinancialLeverage, kn) {
					currentKey = ffjtOperationRatioFinancialLeverage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioFCFSalesRatio, kn) {
					currentKey = ffjtOperationRatioFCFSalesRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioFCFNetIncomeRatio, kn) {
					currentKey = ffjtOperationRatioFCFNetIncomeRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioEBITMargin, kn) {
					currentKey = ffjtOperationRatioEBITMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioEBITDAMargin, kn) {
					currentKey = ffjtOperationRatioEBITDAMargin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioDebtToAssets, kn) {
					currentKey = ffjtOperationRatioDebtToAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioDaysInSales, kn) {
					currentKey = ffjtOperationRatioDaysInSales
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioDaysInPayment, kn) {
					currentKey = ffjtOperationRatioDaysInPayment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioDaysInInventory, kn) {
					currentKey = ffjtOperationRatioDaysInInventory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioCurrentRatio, kn) {
					currentKey = ffjtOperationRatioCurrentRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOperationRatioCompanyID, kn) {
					currentKey = ffjtOperationRatioCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioCommonEquityToAssets, kn) {
					currentKey = ffjtOperationRatioCommonEquityToAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioCashConversionCycle, kn) {
					currentKey = ffjtOperationRatioCashConversionCycle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioCapExSalesRatio, kn) {
					currentKey = ffjtOperationRatioCapExSalesRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioAssetsTurnover, kn) {
					currentKey = ffjtOperationRatioAssetsTurnover
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOperationRatioAsOfDate, kn) {
					currentKey = ffjtOperationRatioAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOperationRationosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOperationRatioAsOfDate:
					goto handle_AsOfDate

				case ffjtOperationRatioAssetsTurnover:
					goto handle_AssetsTurnover

				case ffjtOperationRatioCapExSalesRatio:
					goto handle_CapExSalesRatio

				case ffjtOperationRatioCashConversionCycle:
					goto handle_CashConversionCycle

				case ffjtOperationRatioCommonEquityToAssets:
					goto handle_CommonEquityToAssets

				case ffjtOperationRatioCompanyID:
					goto handle_CompanyID

				case ffjtOperationRatioCurrentRatio:
					goto handle_CurrentRatio

				case ffjtOperationRatioDaysInInventory:
					goto handle_DaysInInventory

				case ffjtOperationRatioDaysInPayment:
					goto handle_DaysInPayment

				case ffjtOperationRatioDaysInSales:
					goto handle_DaysInSales

				case ffjtOperationRatioDebtToAssets:
					goto handle_DebtToAssets

				case ffjtOperationRatioEBITDAMargin:
					goto handle_EBITDAMargin

				case ffjtOperationRatioEBITMargin:
					goto handle_EBITMargin

				case ffjtOperationRatioFCFNetIncomeRatio:
					goto handle_FCFNetIncomeRatio

				case ffjtOperationRatioFCFSalesRatio:
					goto handle_FCFSalesRatio

				case ffjtOperationRatioFinancialLeverage:
					goto handle_FinancialLeverage

				case ffjtOperationRatioFiscalYearEnd:
					goto handle_FiscalYearEnd

				case ffjtOperationRatioFixAssetsTurnover:
					goto handle_FixAssetsTurnover

				case ffjtOperationRatioGrossMargin:
					goto handle_GrossMargin

				case ffjtOperationRatioInterestCoverage:
					goto handle_InterestCoverage

				case ffjtOperationRatioInventoryTurnover:
					goto handle_InventoryTurnover

				case ffjtOperationRatioLongTermDebtEquityRatio:
					goto handle_LongTermDebtEquityRatio

				case ffjtOperationRatioLongTermDebtTotalCapitalRatio:
					goto handle_LongTermDebtTotalCapitalRatio

				case ffjtOperationRatioNetIncomeGrowth:
					goto handle_NetIncomeGrowth

				case ffjtOperationRatioNetIncomeContOpsGrowth:
					goto handle_NetIncomeContOpsGrowth

				case ffjtOperationRatioNetMargin:
					goto handle_NetMargin

				case ffjtOperationRatioNormalizedNetProfitMargin:
					goto handle_NormalizedNetProfitMargin

				case ffjtOperationRatioNormalizedROIC:
					goto handle_NormalizedROIC

				case ffjtOperationRatioOperationIncomeGrowth:
					goto handle_OperationIncomeGrowth

				case ffjtOperationRatioOperationMargin:
					goto handle_OperationMargin

				case ffjtOperationRatioPaymentTurnover:
					goto handle_PaymentTurnover

				case ffjtOperationRatioPeriod:
					goto handle_Period

				case ffjtOperationRatioPretaxMargin:
					goto handle_PretaxMargin

				case ffjtOperationRatioQuickRatio:
					goto handle_QuickRatio

				case ffjtOperationRatioROA:
					goto handle_ROA

				case ffjtOperationRatioROE:
					goto handle_ROE

				case ffjtOperationRatioROIC:
					goto handle_ROIC

				case ffjtOperationRatioReceivableTurnover:
					goto handle_ReceivableTurnover

				case ffjtOperationRatioReportType:
					goto handle_ReportType

				case ffjtOperationRatioSalesPerEmployee:
					goto handle_SalesPerEmployee

				case ffjtOperationRatioTaxRate:
					goto handle_TaxRate

				case ffjtOperationRatioTotalDebtEquityRatio:
					goto handle_TotalDebtEquityRatio

				case ffjtOperationRationosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AssetsTurnover:

	/* handler: j.AssetsTurnover type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.AssetsTurnover = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.AssetsTurnover = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CapExSalesRatio:

	/* handler: j.CapExSalesRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CapExSalesRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CapExSalesRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashConversionCycle:

	/* handler: j.CashConversionCycle type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashConversionCycle = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashConversionCycle = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommonEquityToAssets:

	/* handler: j.CommonEquityToAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CommonEquityToAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CommonEquityToAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentRatio:

	/* handler: j.CurrentRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CurrentRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CurrentRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DaysInInventory:

	/* handler: j.DaysInInventory type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DaysInInventory = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DaysInInventory = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DaysInPayment:

	/* handler: j.DaysInPayment type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DaysInPayment = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DaysInPayment = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DaysInSales:

	/* handler: j.DaysInSales type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DaysInSales = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DaysInSales = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DebtToAssets:

	/* handler: j.DebtToAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DebtToAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DebtToAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EBITDAMargin:

	/* handler: j.EBITDAMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EBITDAMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EBITDAMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EBITMargin:

	/* handler: j.EBITMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EBITMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EBITMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FCFNetIncomeRatio:

	/* handler: j.FCFNetIncomeRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FCFNetIncomeRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FCFNetIncomeRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FCFSalesRatio:

	/* handler: j.FCFSalesRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FCFSalesRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FCFSalesRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinancialLeverage:

	/* handler: j.FinancialLeverage type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FinancialLeverage = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FinancialLeverage = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FiscalYearEnd:

	/* handler: j.FiscalYearEnd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.FiscalYearEnd = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.FiscalYearEnd = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FixAssetsTurnover:

	/* handler: j.FixAssetsTurnover type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FixAssetsTurnover = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FixAssetsTurnover = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GrossMargin:

	/* handler: j.GrossMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.GrossMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.GrossMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InterestCoverage:

	/* handler: j.InterestCoverage type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InterestCoverage = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InterestCoverage = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InventoryTurnover:

	/* handler: j.InventoryTurnover type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InventoryTurnover = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InventoryTurnover = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LongTermDebtEquityRatio:

	/* handler: j.LongTermDebtEquityRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.LongTermDebtEquityRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.LongTermDebtEquityRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LongTermDebtTotalCapitalRatio:

	/* handler: j.LongTermDebtTotalCapitalRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.LongTermDebtTotalCapitalRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.LongTermDebtTotalCapitalRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeGrowth:

	/* handler: j.NetIncomeGrowth type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeGrowth = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeGrowth = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetIncomeContOpsGrowth:

	/* handler: j.NetIncomeContOpsGrowth type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetIncomeContOpsGrowth = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetIncomeContOpsGrowth = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetMargin:

	/* handler: j.NetMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NetMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NetMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedNetProfitMargin:

	/* handler: j.NormalizedNetProfitMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedNetProfitMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedNetProfitMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedROIC:

	/* handler: j.NormalizedROIC type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedROIC = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedROIC = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperationIncomeGrowth:

	/* handler: j.OperationIncomeGrowth type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperationIncomeGrowth = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperationIncomeGrowth = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperationMargin:

	/* handler: j.OperationMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperationMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperationMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PaymentTurnover:

	/* handler: j.PaymentTurnover type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PaymentTurnover = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PaymentTurnover = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PretaxMargin:

	/* handler: j.PretaxMargin type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PretaxMargin = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PretaxMargin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_QuickRatio:

	/* handler: j.QuickRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.QuickRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.QuickRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ROA:

	/* handler: j.ROA type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ROA = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ROA = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ROE:

	/* handler: j.ROE type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ROE = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ROE = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ROIC:

	/* handler: j.ROIC type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ROIC = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ROIC = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReceivableTurnover:

	/* handler: j.ReceivableTurnover type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ReceivableTurnover = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ReceivableTurnover = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReportType:

	/* handler: j.ReportType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ReportType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ReportType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SalesPerEmployee:

	/* handler: j.SalesPerEmployee type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SalesPerEmployee = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SalesPerEmployee = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaxRate:

	/* handler: j.TaxRate type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TaxRate = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TaxRate = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalDebtEquityRatio:

	/* handler: j.TotalDebtEquityRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalDebtEquityRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalDebtEquityRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OwnershipDetail) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OwnershipDetail) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.CurrencyOfMarketValue != nil {
		buf.WriteString(`,"currencyof_market_value":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyOfMarketValue))
	} else {
		buf.WriteString(`,"currencyof_market_value":null`)
	}
	if j.MarketValue != nil {
		buf.WriteString(`,"market_value":`)
		fflib.FormatBits2(buf, uint64(*j.MarketValue), 10, *j.MarketValue < 0)
	} else {
		buf.WriteString(`,"market_value":null`)
	}
	if j.NumberOfShares != nil {
		buf.WriteString(`,"number_of_shares":`)
		fflib.AppendFloat(buf, float64(*j.NumberOfShares), 'g', -1, 64)
	} else {
		buf.WriteString(`,"number_of_shares":null`)
	}
	if j.OwnerCIK != nil {
		buf.WriteString(`,"owner_c_i_k":`)
		fflib.FormatBits2(buf, uint64(*j.OwnerCIK), 10, *j.OwnerCIK < 0)
	} else {
		buf.WriteString(`,"owner_c_i_k":null`)
	}
	if j.OwnerID != nil {
		buf.WriteString(`,"owner_id":`)
		fflib.WriteJsonString(buf, string(*j.OwnerID))
	} else {
		buf.WriteString(`,"owner_id":null`)
	}
	if j.OwnerName != nil {
		buf.WriteString(`,"owner_name":`)
		fflib.WriteJsonString(buf, string(*j.OwnerName))
	} else {
		buf.WriteString(`,"owner_name":null`)
	}
	if j.OwnerType != nil {
		buf.WriteString(`,"owner_type":"`)
		fflib.FormatBits2(buf, uint64(*j.OwnerType), 10, *j.OwnerType < 0)
		buf.WriteByte('"')
	} else {
		buf.WriteString(`,"owner_type":null`)
	}
	if j.PercentageInPortfolio != nil {
		buf.WriteString(`,"percentage_in_portfolio":`)
		fflib.AppendFloat(buf, float64(*j.PercentageInPortfolio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"percentage_in_portfolio":null`)
	}
	if j.PercentageOwnership != nil {
		buf.WriteString(`,"percentage_ownership":`)
		fflib.AppendFloat(buf, float64(*j.PercentageOwnership), 'g', -1, 64)
	} else {
		buf.WriteString(`,"percentage_ownership":null`)
	}
	if j.ShareChange != nil {
		buf.WriteString(`,"share_change":`)
		fflib.FormatBits2(buf, uint64(*j.ShareChange), 10, *j.ShareChange < 0)
	} else {
		buf.WriteString(`,"share_change":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOwnershipDetailbase = iota
	ffjtOwnershipDetailnosuchkey

	ffjtOwnershipDetailAsOfDate

	ffjtOwnershipDetailCurrencyOfMarketValue

	ffjtOwnershipDetailMarketValue

	ffjtOwnershipDetailNumberOfShares

	ffjtOwnershipDetailOwnerCIK

	ffjtOwnershipDetailOwnerID

	ffjtOwnershipDetailOwnerName

	ffjtOwnershipDetailOwnerType

	ffjtOwnershipDetailPercentageInPortfolio

	ffjtOwnershipDetailPercentageOwnership

	ffjtOwnershipDetailShareChange

	ffjtOwnershipDetailShareClassID
)

var ffjKeyOwnershipDetailAsOfDate = []byte("as_of_date")

var ffjKeyOwnershipDetailCurrencyOfMarketValue = []byte("currencyof_market_value")

var ffjKeyOwnershipDetailMarketValue = []byte("market_value")

var ffjKeyOwnershipDetailNumberOfShares = []byte("number_of_shares")

var ffjKeyOwnershipDetailOwnerCIK = []byte("owner_c_i_k")

var ffjKeyOwnershipDetailOwnerID = []byte("owner_id")

var ffjKeyOwnershipDetailOwnerName = []byte("owner_name")

var ffjKeyOwnershipDetailOwnerType = []byte("owner_type")

var ffjKeyOwnershipDetailPercentageInPortfolio = []byte("percentage_in_portfolio")

var ffjKeyOwnershipDetailPercentageOwnership = []byte("percentage_ownership")

var ffjKeyOwnershipDetailShareChange = []byte("share_change")

var ffjKeyOwnershipDetailShareClassID = []byte("share_class_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OwnershipDetail) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OwnershipDetail) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOwnershipDetailbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOwnershipDetailnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyOwnershipDetailAsOfDate, kn) {
						currentKey = ffjtOwnershipDetailAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyOwnershipDetailCurrencyOfMarketValue, kn) {
						currentKey = ffjtOwnershipDetailCurrencyOfMarketValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyOwnershipDetailMarketValue, kn) {
						currentKey = ffjtOwnershipDetailMarketValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyOwnershipDetailNumberOfShares, kn) {
						currentKey = ffjtOwnershipDetailNumberOfShares
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyOwnershipDetailOwnerCIK, kn) {
						currentKey = ffjtOwnershipDetailOwnerCIK
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipDetailOwnerID, kn) {
						currentKey = ffjtOwnershipDetailOwnerID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipDetailOwnerName, kn) {
						currentKey = ffjtOwnershipDetailOwnerName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipDetailOwnerType, kn) {
						currentKey = ffjtOwnershipDetailOwnerType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyOwnershipDetailPercentageInPortfolio, kn) {
						currentKey = ffjtOwnershipDetailPercentageInPortfolio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipDetailPercentageOwnership, kn) {
						currentKey = ffjtOwnershipDetailPercentageOwnership
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOwnershipDetailShareChange, kn) {
						currentKey = ffjtOwnershipDetailShareChange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipDetailShareClassID, kn) {
						currentKey = ffjtOwnershipDetailShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailShareClassID, kn) {
					currentKey = ffjtOwnershipDetailShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailShareChange, kn) {
					currentKey = ffjtOwnershipDetailShareChange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailPercentageOwnership, kn) {
					currentKey = ffjtOwnershipDetailPercentageOwnership
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOwnershipDetailPercentageInPortfolio, kn) {
					currentKey = ffjtOwnershipDetailPercentageInPortfolio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOwnershipDetailOwnerType, kn) {
					currentKey = ffjtOwnershipDetailOwnerType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOwnershipDetailOwnerName, kn) {
					currentKey = ffjtOwnershipDetailOwnerName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOwnershipDetailOwnerID, kn) {
					currentKey = ffjtOwnershipDetailOwnerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailOwnerCIK, kn) {
					currentKey = ffjtOwnershipDetailOwnerCIK
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailNumberOfShares, kn) {
					currentKey = ffjtOwnershipDetailNumberOfShares
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailMarketValue, kn) {
					currentKey = ffjtOwnershipDetailMarketValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailCurrencyOfMarketValue, kn) {
					currentKey = ffjtOwnershipDetailCurrencyOfMarketValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipDetailAsOfDate, kn) {
					currentKey = ffjtOwnershipDetailAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOwnershipDetailnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOwnershipDetailAsOfDate:
					goto handle_AsOfDate

				case ffjtOwnershipDetailCurrencyOfMarketValue:
					goto handle_CurrencyOfMarketValue

				case ffjtOwnershipDetailMarketValue:
					goto handle_MarketValue

				case ffjtOwnershipDetailNumberOfShares:
					goto handle_NumberOfShares

				case ffjtOwnershipDetailOwnerCIK:
					goto handle_OwnerCIK

				case ffjtOwnershipDetailOwnerID:
					goto handle_OwnerID

				case ffjtOwnershipDetailOwnerName:
					goto handle_OwnerName

				case ffjtOwnershipDetailOwnerType:
					goto handle_OwnerType

				case ffjtOwnershipDetailPercentageInPortfolio:
					goto handle_PercentageInPortfolio

				case ffjtOwnershipDetailPercentageOwnership:
					goto handle_PercentageOwnership

				case ffjtOwnershipDetailShareChange:
					goto handle_ShareChange

				case ffjtOwnershipDetailShareClassID:
					goto handle_ShareClassID

				case ffjtOwnershipDetailnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyOfMarketValue:

	/* handler: j.CurrencyOfMarketValue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyOfMarketValue = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyOfMarketValue = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketValue:

	/* handler: j.MarketValue type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MarketValue = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MarketValue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfShares:

	/* handler: j.NumberOfShares type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NumberOfShares = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NumberOfShares = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerCIK:

	/* handler: j.OwnerCIK type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OwnerCIK = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.OwnerCIK = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerID:

	/* handler: j.OwnerID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.OwnerID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.OwnerID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerName:

	/* handler: j.OwnerName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.OwnerName = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.OwnerName = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerType:

	/* handler: j.OwnerType type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OwnerType = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.OwnerType = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PercentageInPortfolio:

	/* handler: j.PercentageInPortfolio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PercentageInPortfolio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PercentageInPortfolio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PercentageOwnership:

	/* handler: j.PercentageOwnership type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PercentageOwnership = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PercentageOwnership = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareChange:

	/* handler: j.ShareChange type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareChange = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShareChange = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OwnershipSummary) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OwnershipSummary) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.DaysToCoverShort == nil {
		buf.WriteString(`,"days_to_cover_short":null`)
	} else {
		buf.WriteString(`,"days_to_cover_short":{ `)
		for key, value := range j.DaysToCoverShort {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.AppendFloat(buf, float64(value), 'g', -1, 64)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	if j.Float != nil {
		buf.WriteString(`,"float":`)
		fflib.FormatBits2(buf, uint64(*j.Float), 10, *j.Float < 0)
	} else {
		buf.WriteString(`,"float":null`)
	}
	if j.InsiderPercentOwned != nil {
		buf.WriteString(`,"insider_percent_owned":`)
		fflib.AppendFloat(buf, float64(*j.InsiderPercentOwned), 'g', -1, 64)
	} else {
		buf.WriteString(`,"insider_percent_owned":null`)
	}
	if j.InsiderSharesBought != nil {
		buf.WriteString(`,"insider_shares_bought":`)
		fflib.FormatBits2(buf, uint64(*j.InsiderSharesBought), 10, *j.InsiderSharesBought < 0)
	} else {
		buf.WriteString(`,"insider_shares_bought":null`)
	}
	if j.InsiderSharesOwned != nil {
		buf.WriteString(`,"insider_shares_owned":`)
		fflib.FormatBits2(buf, uint64(*j.InsiderSharesOwned), 10, *j.InsiderSharesOwned < 0)
	} else {
		buf.WriteString(`,"insider_shares_owned":null`)
	}
	if j.InsiderSharesSold != nil {
		buf.WriteString(`,"insider_shares_sold":`)
		fflib.FormatBits2(buf, uint64(*j.InsiderSharesSold), 10, *j.InsiderSharesSold < 0)
	} else {
		buf.WriteString(`,"insider_shares_sold":null`)
	}
	if j.InstitutionHolderNumber != nil {
		buf.WriteString(`,"institution_holder_number":`)
		fflib.FormatBits2(buf, uint64(*j.InstitutionHolderNumber), 10, *j.InstitutionHolderNumber < 0)
	} else {
		buf.WriteString(`,"institution_holder_number":null`)
	}
	if j.InstitutionSharesBought != nil {
		buf.WriteString(`,"institution_shares_bought":`)
		fflib.FormatBits2(buf, uint64(*j.InstitutionSharesBought), 10, *j.InstitutionSharesBought < 0)
	} else {
		buf.WriteString(`,"institution_shares_bought":null`)
	}
	if j.InstitutionSharesHeld != nil {
		buf.WriteString(`,"institution_shares_held":`)
		fflib.FormatBits2(buf, uint64(*j.InstitutionSharesHeld), 10, *j.InstitutionSharesHeld < 0)
	} else {
		buf.WriteString(`,"institution_shares_held":null`)
	}
	if j.InstitutionSharesSold != nil {
		buf.WriteString(`,"institution_shares_sold":`)
		fflib.FormatBits2(buf, uint64(*j.InstitutionSharesSold), 10, *j.InstitutionSharesSold < 0)
	} else {
		buf.WriteString(`,"institution_shares_sold":null`)
	}
	if j.NumberOfInsiderBuys != nil {
		buf.WriteString(`,"number_of_insider_buys":`)
		fflib.FormatBits2(buf, uint64(*j.NumberOfInsiderBuys), 10, *j.NumberOfInsiderBuys < 0)
	} else {
		buf.WriteString(`,"number_of_insider_buys":null`)
	}
	if j.NumberOfInsiderSellers != nil {
		buf.WriteString(`,"number_of_insider_sellers":`)
		fflib.FormatBits2(buf, uint64(*j.NumberOfInsiderSellers), 10, *j.NumberOfInsiderSellers < 0)
	} else {
		buf.WriteString(`,"number_of_insider_sellers":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	if j.ShareClassLevelSharesOutstanding != nil {
		buf.WriteString(`,"share_class_level_shares_outstanding":`)
		fflib.FormatBits2(buf, uint64(*j.ShareClassLevelSharesOutstanding), 10, *j.ShareClassLevelSharesOutstanding < 0)
	} else {
		buf.WriteString(`,"share_class_level_shares_outstanding":null`)
	}
	if j.ShareClassLevelSharesOutstandingBalanceSheet != nil {
		buf.WriteString(`,"share_class_level_shares_outstanding_balance_sheet":`)
		fflib.FormatBits2(buf, uint64(*j.ShareClassLevelSharesOutstandingBalanceSheet), 10, *j.ShareClassLevelSharesOutstandingBalanceSheet < 0)
	} else {
		buf.WriteString(`,"share_class_level_shares_outstanding_balance_sheet":null`)
	}
	if j.ShareClassLevelSharesOutstandingInterim != nil {
		buf.WriteString(`,"share_class_level_shares_outstanding_interim":`)
		fflib.FormatBits2(buf, uint64(*j.ShareClassLevelSharesOutstandingInterim), 10, *j.ShareClassLevelSharesOutstandingInterim < 0)
	} else {
		buf.WriteString(`,"share_class_level_shares_outstanding_interim":null`)
	}
	if j.ShareClassLevelTreasuryShareOutstanding != nil {
		buf.WriteString(`,"share_class_level_treasury_share_outstanding":`)
		fflib.FormatBits2(buf, uint64(*j.ShareClassLevelTreasuryShareOutstanding), 10, *j.ShareClassLevelTreasuryShareOutstanding < 0)
	} else {
		buf.WriteString(`,"share_class_level_treasury_share_outstanding":null`)
	}
	if j.SharesOutstanding != nil {
		buf.WriteString(`,"shares_outstanding":`)
		fflib.FormatBits2(buf, uint64(*j.SharesOutstanding), 10, *j.SharesOutstanding < 0)
	} else {
		buf.WriteString(`,"shares_outstanding":null`)
	}
	if j.SharesOutstandingWithBalanceSheetEndingDate != nil {
		buf.WriteString(`,"shares_outstanding_with_balance_sheet_ending_date":`)
		fflib.WriteJsonString(buf, string(*j.SharesOutstandingWithBalanceSheetEndingDate))
	} else {
		buf.WriteString(`,"shares_outstanding_with_balance_sheet_ending_date":null`)
	}
	if j.ShortInterest != nil {
		buf.WriteString(`,"short_interest":`)
		fflib.FormatBits2(buf, uint64(*j.ShortInterest), 10, *j.ShortInterest < 0)
	} else {
		buf.WriteString(`,"short_interest":null`)
	}
	if j.ShortInterestsPercentageChange == nil {
		buf.WriteString(`,"short_interests_percentage_change":null`)
	} else {
		buf.WriteString(`,"short_interests_percentage_change":{ `)
		for key, value := range j.ShortInterestsPercentageChange {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.AppendFloat(buf, float64(value), 'g', -1, 64)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	if j.ShortPercentageOfFloat != nil {
		buf.WriteString(`,"short_percentage_of_float":`)
		fflib.AppendFloat(buf, float64(*j.ShortPercentageOfFloat), 'g', -1, 64)
	} else {
		buf.WriteString(`,"short_percentage_of_float":null`)
	}
	if j.ShortPercentageOfSharesOutstanding != nil {
		buf.WriteString(`,"short_percentage_of_shares_outstanding":`)
		fflib.AppendFloat(buf, float64(*j.ShortPercentageOfSharesOutstanding), 'g', -1, 64)
	} else {
		buf.WriteString(`,"short_percentage_of_shares_outstanding":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOwnershipSummarybase = iota
	ffjtOwnershipSummarynosuchkey

	ffjtOwnershipSummaryAsOfDate

	ffjtOwnershipSummaryDaysToCoverShort

	ffjtOwnershipSummaryFloat

	ffjtOwnershipSummaryInsiderPercentOwned

	ffjtOwnershipSummaryInsiderSharesBought

	ffjtOwnershipSummaryInsiderSharesOwned

	ffjtOwnershipSummaryInsiderSharesSold

	ffjtOwnershipSummaryInstitutionHolderNumber

	ffjtOwnershipSummaryInstitutionSharesBought

	ffjtOwnershipSummaryInstitutionSharesHeld

	ffjtOwnershipSummaryInstitutionSharesSold

	ffjtOwnershipSummaryNumberOfInsiderBuys

	ffjtOwnershipSummaryNumberOfInsiderSellers

	ffjtOwnershipSummaryShareClassID

	ffjtOwnershipSummaryShareClassLevelSharesOutstanding

	ffjtOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet

	ffjtOwnershipSummaryShareClassLevelSharesOutstandingInterim

	ffjtOwnershipSummaryShareClassLevelTreasuryShareOutstanding

	ffjtOwnershipSummarySharesOutstanding

	ffjtOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate

	ffjtOwnershipSummaryShortInterest

	ffjtOwnershipSummaryShortInterestsPercentageChange

	ffjtOwnershipSummaryShortPercentageOfFloat

	ffjtOwnershipSummaryShortPercentageOfSharesOutstanding
)

var ffjKeyOwnershipSummaryAsOfDate = []byte("as_of_date")

var ffjKeyOwnershipSummaryDaysToCoverShort = []byte("days_to_cover_short")

var ffjKeyOwnershipSummaryFloat = []byte("float")

var ffjKeyOwnershipSummaryInsiderPercentOwned = []byte("insider_percent_owned")

var ffjKeyOwnershipSummaryInsiderSharesBought = []byte("insider_shares_bought")

var ffjKeyOwnershipSummaryInsiderSharesOwned = []byte("insider_shares_owned")

var ffjKeyOwnershipSummaryInsiderSharesSold = []byte("insider_shares_sold")

var ffjKeyOwnershipSummaryInstitutionHolderNumber = []byte("institution_holder_number")

var ffjKeyOwnershipSummaryInstitutionSharesBought = []byte("institution_shares_bought")

var ffjKeyOwnershipSummaryInstitutionSharesHeld = []byte("institution_shares_held")

var ffjKeyOwnershipSummaryInstitutionSharesSold = []byte("institution_shares_sold")

var ffjKeyOwnershipSummaryNumberOfInsiderBuys = []byte("number_of_insider_buys")

var ffjKeyOwnershipSummaryNumberOfInsiderSellers = []byte("number_of_insider_sellers")

var ffjKeyOwnershipSummaryShareClassID = []byte("share_class_id")

var ffjKeyOwnershipSummaryShareClassLevelSharesOutstanding = []byte("share_class_level_shares_outstanding")

var ffjKeyOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet = []byte("share_class_level_shares_outstanding_balance_sheet")

var ffjKeyOwnershipSummaryShareClassLevelSharesOutstandingInterim = []byte("share_class_level_shares_outstanding_interim")

var ffjKeyOwnershipSummaryShareClassLevelTreasuryShareOutstanding = []byte("share_class_level_treasury_share_outstanding")

var ffjKeyOwnershipSummarySharesOutstanding = []byte("shares_outstanding")

var ffjKeyOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate = []byte("shares_outstanding_with_balance_sheet_ending_date")

var ffjKeyOwnershipSummaryShortInterest = []byte("short_interest")

var ffjKeyOwnershipSummaryShortInterestsPercentageChange = []byte("short_interests_percentage_change")

var ffjKeyOwnershipSummaryShortPercentageOfFloat = []byte("short_percentage_of_float")

var ffjKeyOwnershipSummaryShortPercentageOfSharesOutstanding = []byte("short_percentage_of_shares_outstanding")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OwnershipSummary) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OwnershipSummary) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOwnershipSummarybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOwnershipSummarynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyOwnershipSummaryAsOfDate, kn) {
						currentKey = ffjtOwnershipSummaryAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyOwnershipSummaryDaysToCoverShort, kn) {
						currentKey = ffjtOwnershipSummaryDaysToCoverShort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyOwnershipSummaryFloat, kn) {
						currentKey = ffjtOwnershipSummaryFloat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyOwnershipSummaryInsiderPercentOwned, kn) {
						currentKey = ffjtOwnershipSummaryInsiderPercentOwned
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInsiderSharesBought, kn) {
						currentKey = ffjtOwnershipSummaryInsiderSharesBought
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInsiderSharesOwned, kn) {
						currentKey = ffjtOwnershipSummaryInsiderSharesOwned
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInsiderSharesSold, kn) {
						currentKey = ffjtOwnershipSummaryInsiderSharesSold
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInstitutionHolderNumber, kn) {
						currentKey = ffjtOwnershipSummaryInstitutionHolderNumber
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInstitutionSharesBought, kn) {
						currentKey = ffjtOwnershipSummaryInstitutionSharesBought
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInstitutionSharesHeld, kn) {
						currentKey = ffjtOwnershipSummaryInstitutionSharesHeld
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryInstitutionSharesSold, kn) {
						currentKey = ffjtOwnershipSummaryInstitutionSharesSold
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyOwnershipSummaryNumberOfInsiderBuys, kn) {
						currentKey = ffjtOwnershipSummaryNumberOfInsiderBuys
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryNumberOfInsiderSellers, kn) {
						currentKey = ffjtOwnershipSummaryNumberOfInsiderSellers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOwnershipSummaryShareClassID, kn) {
						currentKey = ffjtOwnershipSummaryShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShareClassLevelSharesOutstanding, kn) {
						currentKey = ffjtOwnershipSummaryShareClassLevelSharesOutstanding
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet, kn) {
						currentKey = ffjtOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShareClassLevelSharesOutstandingInterim, kn) {
						currentKey = ffjtOwnershipSummaryShareClassLevelSharesOutstandingInterim
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShareClassLevelTreasuryShareOutstanding, kn) {
						currentKey = ffjtOwnershipSummaryShareClassLevelTreasuryShareOutstanding
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummarySharesOutstanding, kn) {
						currentKey = ffjtOwnershipSummarySharesOutstanding
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate, kn) {
						currentKey = ffjtOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShortInterest, kn) {
						currentKey = ffjtOwnershipSummaryShortInterest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShortInterestsPercentageChange, kn) {
						currentKey = ffjtOwnershipSummaryShortInterestsPercentageChange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShortPercentageOfFloat, kn) {
						currentKey = ffjtOwnershipSummaryShortPercentageOfFloat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOwnershipSummaryShortPercentageOfSharesOutstanding, kn) {
						currentKey = ffjtOwnershipSummaryShortPercentageOfSharesOutstanding
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShortPercentageOfSharesOutstanding, kn) {
					currentKey = ffjtOwnershipSummaryShortPercentageOfSharesOutstanding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShortPercentageOfFloat, kn) {
					currentKey = ffjtOwnershipSummaryShortPercentageOfFloat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShortInterestsPercentageChange, kn) {
					currentKey = ffjtOwnershipSummaryShortInterestsPercentageChange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShortInterest, kn) {
					currentKey = ffjtOwnershipSummaryShortInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate, kn) {
					currentKey = ffjtOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummarySharesOutstanding, kn) {
					currentKey = ffjtOwnershipSummarySharesOutstanding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShareClassLevelTreasuryShareOutstanding, kn) {
					currentKey = ffjtOwnershipSummaryShareClassLevelTreasuryShareOutstanding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShareClassLevelSharesOutstandingInterim, kn) {
					currentKey = ffjtOwnershipSummaryShareClassLevelSharesOutstandingInterim
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet, kn) {
					currentKey = ffjtOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShareClassLevelSharesOutstanding, kn) {
					currentKey = ffjtOwnershipSummaryShareClassLevelSharesOutstanding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryShareClassID, kn) {
					currentKey = ffjtOwnershipSummaryShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryNumberOfInsiderSellers, kn) {
					currentKey = ffjtOwnershipSummaryNumberOfInsiderSellers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryNumberOfInsiderBuys, kn) {
					currentKey = ffjtOwnershipSummaryNumberOfInsiderBuys
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInstitutionSharesSold, kn) {
					currentKey = ffjtOwnershipSummaryInstitutionSharesSold
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInstitutionSharesHeld, kn) {
					currentKey = ffjtOwnershipSummaryInstitutionSharesHeld
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInstitutionSharesBought, kn) {
					currentKey = ffjtOwnershipSummaryInstitutionSharesBought
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInstitutionHolderNumber, kn) {
					currentKey = ffjtOwnershipSummaryInstitutionHolderNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInsiderSharesSold, kn) {
					currentKey = ffjtOwnershipSummaryInsiderSharesSold
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInsiderSharesOwned, kn) {
					currentKey = ffjtOwnershipSummaryInsiderSharesOwned
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInsiderSharesBought, kn) {
					currentKey = ffjtOwnershipSummaryInsiderSharesBought
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryInsiderPercentOwned, kn) {
					currentKey = ffjtOwnershipSummaryInsiderPercentOwned
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOwnershipSummaryFloat, kn) {
					currentKey = ffjtOwnershipSummaryFloat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryDaysToCoverShort, kn) {
					currentKey = ffjtOwnershipSummaryDaysToCoverShort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOwnershipSummaryAsOfDate, kn) {
					currentKey = ffjtOwnershipSummaryAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOwnershipSummarynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOwnershipSummaryAsOfDate:
					goto handle_AsOfDate

				case ffjtOwnershipSummaryDaysToCoverShort:
					goto handle_DaysToCoverShort

				case ffjtOwnershipSummaryFloat:
					goto handle_Float

				case ffjtOwnershipSummaryInsiderPercentOwned:
					goto handle_InsiderPercentOwned

				case ffjtOwnershipSummaryInsiderSharesBought:
					goto handle_InsiderSharesBought

				case ffjtOwnershipSummaryInsiderSharesOwned:
					goto handle_InsiderSharesOwned

				case ffjtOwnershipSummaryInsiderSharesSold:
					goto handle_InsiderSharesSold

				case ffjtOwnershipSummaryInstitutionHolderNumber:
					goto handle_InstitutionHolderNumber

				case ffjtOwnershipSummaryInstitutionSharesBought:
					goto handle_InstitutionSharesBought

				case ffjtOwnershipSummaryInstitutionSharesHeld:
					goto handle_InstitutionSharesHeld

				case ffjtOwnershipSummaryInstitutionSharesSold:
					goto handle_InstitutionSharesSold

				case ffjtOwnershipSummaryNumberOfInsiderBuys:
					goto handle_NumberOfInsiderBuys

				case ffjtOwnershipSummaryNumberOfInsiderSellers:
					goto handle_NumberOfInsiderSellers

				case ffjtOwnershipSummaryShareClassID:
					goto handle_ShareClassID

				case ffjtOwnershipSummaryShareClassLevelSharesOutstanding:
					goto handle_ShareClassLevelSharesOutstanding

				case ffjtOwnershipSummaryShareClassLevelSharesOutstandingBalanceSheet:
					goto handle_ShareClassLevelSharesOutstandingBalanceSheet

				case ffjtOwnershipSummaryShareClassLevelSharesOutstandingInterim:
					goto handle_ShareClassLevelSharesOutstandingInterim

				case ffjtOwnershipSummaryShareClassLevelTreasuryShareOutstanding:
					goto handle_ShareClassLevelTreasuryShareOutstanding

				case ffjtOwnershipSummarySharesOutstanding:
					goto handle_SharesOutstanding

				case ffjtOwnershipSummarySharesOutstandingWithBalanceSheetEndingDate:
					goto handle_SharesOutstandingWithBalanceSheetEndingDate

				case ffjtOwnershipSummaryShortInterest:
					goto handle_ShortInterest

				case ffjtOwnershipSummaryShortInterestsPercentageChange:
					goto handle_ShortInterestsPercentageChange

				case ffjtOwnershipSummaryShortPercentageOfFloat:
					goto handle_ShortPercentageOfFloat

				case ffjtOwnershipSummaryShortPercentageOfSharesOutstanding:
					goto handle_ShortPercentageOfSharesOutstanding

				case ffjtOwnershipSummarynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DaysToCoverShort:

	/* handler: j.DaysToCoverShort type=map[string]float64 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DaysToCoverShort = nil
		} else {

			j.DaysToCoverShort = make(map[string]float64, 0)

			wantVal := true

			for {

				var k string

				var tmpJDaysToCoverShort float64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJDaysToCoverShort type=float64 kind=float64 quoted=false*/

				{
					if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJDaysToCoverShort = float64(tval)

					}
				}

				j.DaysToCoverShort[k] = tmpJDaysToCoverShort

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Float:

	/* handler: j.Float type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Float = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.Float = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InsiderPercentOwned:

	/* handler: j.InsiderPercentOwned type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InsiderPercentOwned = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.InsiderPercentOwned = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InsiderSharesBought:

	/* handler: j.InsiderSharesBought type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InsiderSharesBought = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InsiderSharesBought = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InsiderSharesOwned:

	/* handler: j.InsiderSharesOwned type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InsiderSharesOwned = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InsiderSharesOwned = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InsiderSharesSold:

	/* handler: j.InsiderSharesSold type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InsiderSharesSold = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InsiderSharesSold = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstitutionHolderNumber:

	/* handler: j.InstitutionHolderNumber type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InstitutionHolderNumber = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InstitutionHolderNumber = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstitutionSharesBought:

	/* handler: j.InstitutionSharesBought type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InstitutionSharesBought = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InstitutionSharesBought = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstitutionSharesHeld:

	/* handler: j.InstitutionSharesHeld type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InstitutionSharesHeld = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InstitutionSharesHeld = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstitutionSharesSold:

	/* handler: j.InstitutionSharesSold type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.InstitutionSharesSold = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.InstitutionSharesSold = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfInsiderBuys:

	/* handler: j.NumberOfInsiderBuys type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NumberOfInsiderBuys = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.NumberOfInsiderBuys = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberOfInsiderSellers:

	/* handler: j.NumberOfInsiderSellers type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NumberOfInsiderSellers = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.NumberOfInsiderSellers = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassLevelSharesOutstanding:

	/* handler: j.ShareClassLevelSharesOutstanding type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareClassLevelSharesOutstanding = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShareClassLevelSharesOutstanding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassLevelSharesOutstandingBalanceSheet:

	/* handler: j.ShareClassLevelSharesOutstandingBalanceSheet type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareClassLevelSharesOutstandingBalanceSheet = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShareClassLevelSharesOutstandingBalanceSheet = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassLevelSharesOutstandingInterim:

	/* handler: j.ShareClassLevelSharesOutstandingInterim type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareClassLevelSharesOutstandingInterim = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShareClassLevelSharesOutstandingInterim = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassLevelTreasuryShareOutstanding:

	/* handler: j.ShareClassLevelTreasuryShareOutstanding type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareClassLevelTreasuryShareOutstanding = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShareClassLevelTreasuryShareOutstanding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharesOutstanding:

	/* handler: j.SharesOutstanding type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SharesOutstanding = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.SharesOutstanding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharesOutstandingWithBalanceSheetEndingDate:

	/* handler: j.SharesOutstandingWithBalanceSheetEndingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SharesOutstandingWithBalanceSheetEndingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SharesOutstandingWithBalanceSheetEndingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortInterest:

	/* handler: j.ShortInterest type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShortInterest = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShortInterest = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortInterestsPercentageChange:

	/* handler: j.ShortInterestsPercentageChange type=map[string]float64 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ShortInterestsPercentageChange = nil
		} else {

			j.ShortInterestsPercentageChange = make(map[string]float64, 0)

			wantVal := true

			for {

				var k string

				var tmpJShortInterestsPercentageChange float64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJShortInterestsPercentageChange type=float64 kind=float64 quoted=false*/

				{
					if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJShortInterestsPercentageChange = float64(tval)

					}
				}

				j.ShortInterestsPercentageChange[k] = tmpJShortInterestsPercentageChange

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortPercentageOfFloat:

	/* handler: j.ShortPercentageOfFloat type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShortPercentageOfFloat = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ShortPercentageOfFloat = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShortPercentageOfSharesOutstanding:

	/* handler: j.ShortPercentageOfSharesOutstanding type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShortPercentageOfSharesOutstanding = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ShortPercentageOfSharesOutstanding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PriceStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PriceStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.ShareClassID != nil {
		buf.WriteString(`{"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`{"share_class_id":null`)
	}
	if j.AsOfDate != nil {
		buf.WriteString(`,"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`,"as_of_date":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.ArithmeticMean != nil {
		buf.WriteString(`,"arithmetic_mean":`)
		fflib.AppendFloat(buf, float64(*j.ArithmeticMean), 'g', -1, 64)
	} else {
		buf.WriteString(`,"arithmetic_mean":null`)
	}
	if j.AverageVolume != nil {
		buf.WriteString(`,"average_volume":`)
		fflib.AppendFloat(buf, float64(*j.AverageVolume), 'g', -1, 64)
	} else {
		buf.WriteString(`,"average_volume":null`)
	}
	if j.Best3MonthTotalReturn != nil {
		buf.WriteString(`,"best3_month_return_total":`)
		fflib.AppendFloat(buf, float64(*j.Best3MonthTotalReturn), 'g', -1, 64)
	} else {
		buf.WriteString(`,"best3_month_return_total":null`)
	}
	if j.ClosePriceToMovingAverage != nil {
		buf.WriteString(`,"close_price_to_moving_average":`)
		fflib.AppendFloat(buf, float64(*j.ClosePriceToMovingAverage), 'g', -1, 64)
	} else {
		buf.WriteString(`,"close_price_to_moving_average":null`)
	}
	if j.HighPrice != nil {
		buf.WriteString(`,"high_price":`)
		fflib.AppendFloat(buf, float64(*j.HighPrice), 'g', -1, 64)
	} else {
		buf.WriteString(`,"high_price":null`)
	}
	if j.LowPrice != nil {
		buf.WriteString(`,"low_price":`)
		fflib.AppendFloat(buf, float64(*j.LowPrice), 'g', -1, 64)
	} else {
		buf.WriteString(`,"low_price":null`)
	}
	if j.MovingAveragePrice != nil {
		buf.WriteString(`,"moving_average_price":`)
		fflib.AppendFloat(buf, float64(*j.MovingAveragePrice), 'g', -1, 64)
	} else {
		buf.WriteString(`,"moving_average_price":null`)
	}
	if j.PercentageBelowHighPrice != nil {
		buf.WriteString(`,"percentage_below_high_price":`)
		fflib.AppendFloat(buf, float64(*j.PercentageBelowHighPrice), 'g', -1, 64)
	} else {
		buf.WriteString(`,"percentage_below_high_price":null`)
	}
	if j.StandardDeviation != nil {
		buf.WriteString(`,"standard_deviation":`)
		fflib.AppendFloat(buf, float64(*j.StandardDeviation), 'g', -1, 64)
	} else {
		buf.WriteString(`,"standard_deviation":null`)
	}
	if j.TotalVolume != nil {
		buf.WriteString(`,"total_volume":`)
		fflib.AppendFloat(buf, float64(*j.TotalVolume), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_volume":null`)
	}
	if j.Worst3MonthTotalReturn != nil {
		buf.WriteString(`,"worst3_month_total_return":`)
		fflib.AppendFloat(buf, float64(*j.Worst3MonthTotalReturn), 'g', -1, 64)
	} else {
		buf.WriteString(`,"worst3_month_total_return":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPriceStatisticsbase = iota
	ffjtPriceStatisticsnosuchkey

	ffjtPriceStatisticsShareClassID

	ffjtPriceStatisticsAsOfDate

	ffjtPriceStatisticsPeriod

	ffjtPriceStatisticsArithmeticMean

	ffjtPriceStatisticsAverageVolume

	ffjtPriceStatisticsBest3MonthTotalReturn

	ffjtPriceStatisticsClosePriceToMovingAverage

	ffjtPriceStatisticsHighPrice

	ffjtPriceStatisticsLowPrice

	ffjtPriceStatisticsMovingAveragePrice

	ffjtPriceStatisticsPercentageBelowHighPrice

	ffjtPriceStatisticsStandardDeviation

	ffjtPriceStatisticsTotalVolume

	ffjtPriceStatisticsWorst3MonthTotalReturn
)

var ffjKeyPriceStatisticsShareClassID = []byte("share_class_id")

var ffjKeyPriceStatisticsAsOfDate = []byte("as_of_date")

var ffjKeyPriceStatisticsPeriod = []byte("period")

var ffjKeyPriceStatisticsArithmeticMean = []byte("arithmetic_mean")

var ffjKeyPriceStatisticsAverageVolume = []byte("average_volume")

var ffjKeyPriceStatisticsBest3MonthTotalReturn = []byte("best3_month_return_total")

var ffjKeyPriceStatisticsClosePriceToMovingAverage = []byte("close_price_to_moving_average")

var ffjKeyPriceStatisticsHighPrice = []byte("high_price")

var ffjKeyPriceStatisticsLowPrice = []byte("low_price")

var ffjKeyPriceStatisticsMovingAveragePrice = []byte("moving_average_price")

var ffjKeyPriceStatisticsPercentageBelowHighPrice = []byte("percentage_below_high_price")

var ffjKeyPriceStatisticsStandardDeviation = []byte("standard_deviation")

var ffjKeyPriceStatisticsTotalVolume = []byte("total_volume")

var ffjKeyPriceStatisticsWorst3MonthTotalReturn = []byte("worst3_month_total_return")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PriceStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PriceStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPriceStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPriceStatisticsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyPriceStatisticsAsOfDate, kn) {
						currentKey = ffjtPriceStatisticsAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPriceStatisticsArithmeticMean, kn) {
						currentKey = ffjtPriceStatisticsArithmeticMean
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPriceStatisticsAverageVolume, kn) {
						currentKey = ffjtPriceStatisticsAverageVolume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyPriceStatisticsBest3MonthTotalReturn, kn) {
						currentKey = ffjtPriceStatisticsBest3MonthTotalReturn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPriceStatisticsClosePriceToMovingAverage, kn) {
						currentKey = ffjtPriceStatisticsClosePriceToMovingAverage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyPriceStatisticsHighPrice, kn) {
						currentKey = ffjtPriceStatisticsHighPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyPriceStatisticsLowPrice, kn) {
						currentKey = ffjtPriceStatisticsLowPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyPriceStatisticsMovingAveragePrice, kn) {
						currentKey = ffjtPriceStatisticsMovingAveragePrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyPriceStatisticsPeriod, kn) {
						currentKey = ffjtPriceStatisticsPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPriceStatisticsPercentageBelowHighPrice, kn) {
						currentKey = ffjtPriceStatisticsPercentageBelowHighPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPriceStatisticsShareClassID, kn) {
						currentKey = ffjtPriceStatisticsShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPriceStatisticsStandardDeviation, kn) {
						currentKey = ffjtPriceStatisticsStandardDeviation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPriceStatisticsTotalVolume, kn) {
						currentKey = ffjtPriceStatisticsTotalVolume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyPriceStatisticsWorst3MonthTotalReturn, kn) {
						currentKey = ffjtPriceStatisticsWorst3MonthTotalReturn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPriceStatisticsWorst3MonthTotalReturn, kn) {
					currentKey = ffjtPriceStatisticsWorst3MonthTotalReturn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsTotalVolume, kn) {
					currentKey = ffjtPriceStatisticsTotalVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPriceStatisticsStandardDeviation, kn) {
					currentKey = ffjtPriceStatisticsStandardDeviation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsPercentageBelowHighPrice, kn) {
					currentKey = ffjtPriceStatisticsPercentageBelowHighPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsMovingAveragePrice, kn) {
					currentKey = ffjtPriceStatisticsMovingAveragePrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsLowPrice, kn) {
					currentKey = ffjtPriceStatisticsLowPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsHighPrice, kn) {
					currentKey = ffjtPriceStatisticsHighPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPriceStatisticsClosePriceToMovingAverage, kn) {
					currentKey = ffjtPriceStatisticsClosePriceToMovingAverage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPriceStatisticsBest3MonthTotalReturn, kn) {
					currentKey = ffjtPriceStatisticsBest3MonthTotalReturn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsAverageVolume, kn) {
					currentKey = ffjtPriceStatisticsAverageVolume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPriceStatisticsArithmeticMean, kn) {
					currentKey = ffjtPriceStatisticsArithmeticMean
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPriceStatisticsPeriod, kn) {
					currentKey = ffjtPriceStatisticsPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPriceStatisticsAsOfDate, kn) {
					currentKey = ffjtPriceStatisticsAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPriceStatisticsShareClassID, kn) {
					currentKey = ffjtPriceStatisticsShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPriceStatisticsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPriceStatisticsShareClassID:
					goto handle_ShareClassID

				case ffjtPriceStatisticsAsOfDate:
					goto handle_AsOfDate

				case ffjtPriceStatisticsPeriod:
					goto handle_Period

				case ffjtPriceStatisticsArithmeticMean:
					goto handle_ArithmeticMean

				case ffjtPriceStatisticsAverageVolume:
					goto handle_AverageVolume

				case ffjtPriceStatisticsBest3MonthTotalReturn:
					goto handle_Best3MonthTotalReturn

				case ffjtPriceStatisticsClosePriceToMovingAverage:
					goto handle_ClosePriceToMovingAverage

				case ffjtPriceStatisticsHighPrice:
					goto handle_HighPrice

				case ffjtPriceStatisticsLowPrice:
					goto handle_LowPrice

				case ffjtPriceStatisticsMovingAveragePrice:
					goto handle_MovingAveragePrice

				case ffjtPriceStatisticsPercentageBelowHighPrice:
					goto handle_PercentageBelowHighPrice

				case ffjtPriceStatisticsStandardDeviation:
					goto handle_StandardDeviation

				case ffjtPriceStatisticsTotalVolume:
					goto handle_TotalVolume

				case ffjtPriceStatisticsWorst3MonthTotalReturn:
					goto handle_Worst3MonthTotalReturn

				case ffjtPriceStatisticsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ArithmeticMean:

	/* handler: j.ArithmeticMean type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ArithmeticMean = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ArithmeticMean = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AverageVolume:

	/* handler: j.AverageVolume type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.AverageVolume = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.AverageVolume = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Best3MonthTotalReturn:

	/* handler: j.Best3MonthTotalReturn type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Best3MonthTotalReturn = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Best3MonthTotalReturn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClosePriceToMovingAverage:

	/* handler: j.ClosePriceToMovingAverage type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ClosePriceToMovingAverage = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ClosePriceToMovingAverage = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HighPrice:

	/* handler: j.HighPrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.HighPrice = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.HighPrice = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LowPrice:

	/* handler: j.LowPrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.LowPrice = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.LowPrice = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MovingAveragePrice:

	/* handler: j.MovingAveragePrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MovingAveragePrice = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.MovingAveragePrice = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PercentageBelowHighPrice:

	/* handler: j.PercentageBelowHighPrice type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PercentageBelowHighPrice = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PercentageBelowHighPrice = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StandardDeviation:

	/* handler: j.StandardDeviation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.StandardDeviation = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.StandardDeviation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalVolume:

	/* handler: j.TotalVolume type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalVolume = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalVolume = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Worst3MonthTotalReturn:

	/* handler: j.Worst3MonthTotalReturn type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Worst3MonthTotalReturn = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Worst3MonthTotalReturn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Segmentation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Segmentation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.CompanyID != nil {
		buf.WriteString(`,"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`,"company_id":null`)
	}
	if j.DepreciationAndAmortization != nil {
		buf.WriteString(`,"depreciation_and_amortization":`)
		fflib.AppendFloat(buf, float64(*j.DepreciationAndAmortization), 'g', -1, 64)
	} else {
		buf.WriteString(`,"depreciation_and_amortization":null`)
	}
	if j.OperatingIncome != nil {
		buf.WriteString(`,"operating_income":`)
		fflib.AppendFloat(buf, float64(*j.OperatingIncome), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operating_income":null`)
	}
	if j.OperatingRevenue != nil {
		buf.WriteString(`,"operating_revenue":`)
		fflib.AppendFloat(buf, float64(*j.OperatingRevenue), 'g', -1, 64)
	} else {
		buf.WriteString(`,"operating_revenue":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.TotalAssets != nil {
		buf.WriteString(`,"total_assets":`)
		fflib.AppendFloat(buf, float64(*j.TotalAssets), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_assets":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSegmentationbase = iota
	ffjtSegmentationnosuchkey

	ffjtSegmentationAsOfDate

	ffjtSegmentationCompanyID

	ffjtSegmentationDepreciationAndAmortization

	ffjtSegmentationOperatingIncome

	ffjtSegmentationOperatingRevenue

	ffjtSegmentationPeriod

	ffjtSegmentationTotalAssets
)

var ffjKeySegmentationAsOfDate = []byte("as_of_date")

var ffjKeySegmentationCompanyID = []byte("company_id")

var ffjKeySegmentationDepreciationAndAmortization = []byte("depreciation_and_amortization")

var ffjKeySegmentationOperatingIncome = []byte("operating_income")

var ffjKeySegmentationOperatingRevenue = []byte("operating_revenue")

var ffjKeySegmentationPeriod = []byte("period")

var ffjKeySegmentationTotalAssets = []byte("total_assets")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Segmentation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Segmentation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSegmentationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSegmentationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySegmentationAsOfDate, kn) {
						currentKey = ffjtSegmentationAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeySegmentationCompanyID, kn) {
						currentKey = ffjtSegmentationCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeySegmentationDepreciationAndAmortization, kn) {
						currentKey = ffjtSegmentationDepreciationAndAmortization
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeySegmentationOperatingIncome, kn) {
						currentKey = ffjtSegmentationOperatingIncome
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySegmentationOperatingRevenue, kn) {
						currentKey = ffjtSegmentationOperatingRevenue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySegmentationPeriod, kn) {
						currentKey = ffjtSegmentationPeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySegmentationTotalAssets, kn) {
						currentKey = ffjtSegmentationTotalAssets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySegmentationTotalAssets, kn) {
					currentKey = ffjtSegmentationTotalAssets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySegmentationPeriod, kn) {
					currentKey = ffjtSegmentationPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySegmentationOperatingRevenue, kn) {
					currentKey = ffjtSegmentationOperatingRevenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySegmentationOperatingIncome, kn) {
					currentKey = ffjtSegmentationOperatingIncome
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySegmentationDepreciationAndAmortization, kn) {
					currentKey = ffjtSegmentationDepreciationAndAmortization
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySegmentationCompanyID, kn) {
					currentKey = ffjtSegmentationCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySegmentationAsOfDate, kn) {
					currentKey = ffjtSegmentationAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSegmentationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSegmentationAsOfDate:
					goto handle_AsOfDate

				case ffjtSegmentationCompanyID:
					goto handle_CompanyID

				case ffjtSegmentationDepreciationAndAmortization:
					goto handle_DepreciationAndAmortization

				case ffjtSegmentationOperatingIncome:
					goto handle_OperatingIncome

				case ffjtSegmentationOperatingRevenue:
					goto handle_OperatingRevenue

				case ffjtSegmentationPeriod:
					goto handle_Period

				case ffjtSegmentationTotalAssets:
					goto handle_TotalAssets

				case ffjtSegmentationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DepreciationAndAmortization:

	/* handler: j.DepreciationAndAmortization type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DepreciationAndAmortization = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DepreciationAndAmortization = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperatingIncome:

	/* handler: j.OperatingIncome type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperatingIncome = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperatingIncome = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OperatingRevenue:

	/* handler: j.OperatingRevenue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.OperatingRevenue = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.OperatingRevenue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAssets:

	/* handler: j.TotalAssets type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalAssets = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalAssets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShareClass) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShareClass) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.CompanyID != nil {
		buf.WriteString(`{"company_id":`)
		fflib.WriteJsonString(buf, string(*j.CompanyID))
	} else {
		buf.WriteString(`{"company_id":null`)
	}
	if j.CUSIP != nil {
		buf.WriteString(`,"c_u_s_i_p":`)
		fflib.WriteJsonString(buf, string(*j.CUSIP))
	} else {
		buf.WriteString(`,"c_u_s_i_p":null`)
	}
	if j.CurrencyID != nil {
		buf.WriteString(`,"currency_id":`)
		fflib.WriteJsonString(buf, string(*j.CurrencyID))
	} else {
		buf.WriteString(`,"currency_id":null`)
	}
	if j.DelistingDate != nil {
		buf.WriteString(`,"delisting_date":`)
		fflib.WriteJsonString(buf, string(*j.DelistingDate))
	} else {
		buf.WriteString(`,"delisting_date":null`)
	}
	if j.ExchangeID != nil {
		buf.WriteString(`,"exchange_id":`)
		fflib.WriteJsonString(buf, string(*j.ExchangeID))
	} else {
		buf.WriteString(`,"exchange_id":null`)
	}
	if j.IPODate != nil {
		buf.WriteString(`,"i_p_o_date":`)
		fflib.WriteJsonString(buf, string(*j.IPODate))
	} else {
		buf.WriteString(`,"i_p_o_date":null`)
	}
	if j.ISIN != nil {
		buf.WriteString(`,"i_s_i_n":`)
		fflib.WriteJsonString(buf, string(*j.ISIN))
	} else {
		buf.WriteString(`,"i_s_i_n":null`)
	}
	if j.InvestmentID != nil {
		buf.WriteString(`,"investment_id":`)
		fflib.WriteJsonString(buf, string(*j.InvestmentID))
	} else {
		buf.WriteString(`,"investment_id":null`)
	}
	if j.IsDepositaryReceipt != nil {
		if *j.IsDepositaryReceipt {
			buf.WriteString(`,"is_depositary_receipt":true`)
		} else {
			buf.WriteString(`,"is_depositary_receipt":false`)
		}
	} else {
		buf.WriteString(`,"is_depositary_receipt":null`)
	}
	if j.IsDirectInvest != nil {
		if *j.IsDirectInvest {
			buf.WriteString(`,"is_direct_invest":true`)
		} else {
			buf.WriteString(`,"is_direct_invest":false`)
		}
	} else {
		buf.WriteString(`,"is_direct_invest":null`)
	}
	if j.IsDividendReinvest != nil {
		if *j.IsDividendReinvest {
			buf.WriteString(`,"is_dividend_reinvest":true`)
		} else {
			buf.WriteString(`,"is_dividend_reinvest":false`)
		}
	} else {
		buf.WriteString(`,"is_dividend_reinvest":null`)
	}
	if j.IsPrimaryShare != nil {
		if *j.IsPrimaryShare {
			buf.WriteString(`,"is_primary_share":true`)
		} else {
			buf.WriteString(`,"is_primary_share":false`)
		}
	} else {
		buf.WriteString(`,"is_primary_share":null`)
	}
	if j.MIC != nil {
		buf.WriteString(`,"m_i_c":`)
		fflib.WriteJsonString(buf, string(*j.MIC))
	} else {
		buf.WriteString(`,"m_i_c":null`)
	}
	if j.SEDOL != nil {
		buf.WriteString(`,"s_e_d_o_l":`)
		fflib.WriteJsonString(buf, string(*j.SEDOL))
	} else {
		buf.WriteString(`,"s_e_d_o_l":null`)
	}
	if j.SecurityType != nil {
		buf.WriteString(`,"security_type":`)
		fflib.WriteJsonString(buf, string(*j.SecurityType))
	} else {
		buf.WriteString(`,"security_type":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	if j.ShareClassStatus != nil {
		buf.WriteString(`,"share_class_status":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassStatus))
	} else {
		buf.WriteString(`,"share_class_status":null`)
	}
	if j.Symbol != nil {
		buf.WriteString(`,"symbol":`)
		fflib.WriteJsonString(buf, string(*j.Symbol))
	} else {
		buf.WriteString(`,"symbol":null`)
	}
	if j.TradingStatus != nil {
		if *j.TradingStatus {
			buf.WriteString(`,"trading_status":true`)
		} else {
			buf.WriteString(`,"trading_status":false`)
		}
	} else {
		buf.WriteString(`,"trading_status":null`)
	}
	if j.Valoren != nil {
		buf.WriteString(`,"valoren":`)
		fflib.WriteJsonString(buf, string(*j.Valoren))
	} else {
		buf.WriteString(`,"valoren":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShareClassbase = iota
	ffjtShareClassnosuchkey

	ffjtShareClassCompanyID

	ffjtShareClassCUSIP

	ffjtShareClassCurrencyID

	ffjtShareClassDelistingDate

	ffjtShareClassExchangeID

	ffjtShareClassIPODate

	ffjtShareClassISIN

	ffjtShareClassInvestmentID

	ffjtShareClassIsDepositaryReceipt

	ffjtShareClassIsDirectInvest

	ffjtShareClassIsDividendReinvest

	ffjtShareClassIsPrimaryShare

	ffjtShareClassMIC

	ffjtShareClassSEDOL

	ffjtShareClassSecurityType

	ffjtShareClassShareClassID

	ffjtShareClassShareClassStatus

	ffjtShareClassSymbol

	ffjtShareClassTradingStatus

	ffjtShareClassValoren
)

var ffjKeyShareClassCompanyID = []byte("company_id")

var ffjKeyShareClassCUSIP = []byte("c_u_s_i_p")

var ffjKeyShareClassCurrencyID = []byte("currency_id")

var ffjKeyShareClassDelistingDate = []byte("delisting_date")

var ffjKeyShareClassExchangeID = []byte("exchange_id")

var ffjKeyShareClassIPODate = []byte("i_p_o_date")

var ffjKeyShareClassISIN = []byte("i_s_i_n")

var ffjKeyShareClassInvestmentID = []byte("investment_id")

var ffjKeyShareClassIsDepositaryReceipt = []byte("is_depositary_receipt")

var ffjKeyShareClassIsDirectInvest = []byte("is_direct_invest")

var ffjKeyShareClassIsDividendReinvest = []byte("is_dividend_reinvest")

var ffjKeyShareClassIsPrimaryShare = []byte("is_primary_share")

var ffjKeyShareClassMIC = []byte("m_i_c")

var ffjKeyShareClassSEDOL = []byte("s_e_d_o_l")

var ffjKeyShareClassSecurityType = []byte("security_type")

var ffjKeyShareClassShareClassID = []byte("share_class_id")

var ffjKeyShareClassShareClassStatus = []byte("share_class_status")

var ffjKeyShareClassSymbol = []byte("symbol")

var ffjKeyShareClassTradingStatus = []byte("trading_status")

var ffjKeyShareClassValoren = []byte("valoren")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShareClass) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShareClass) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShareClassbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShareClassnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyShareClassCompanyID, kn) {
						currentKey = ffjtShareClassCompanyID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassCUSIP, kn) {
						currentKey = ffjtShareClassCUSIP
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassCurrencyID, kn) {
						currentKey = ffjtShareClassCurrencyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyShareClassDelistingDate, kn) {
						currentKey = ffjtShareClassDelistingDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyShareClassExchangeID, kn) {
						currentKey = ffjtShareClassExchangeID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyShareClassIPODate, kn) {
						currentKey = ffjtShareClassIPODate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassISIN, kn) {
						currentKey = ffjtShareClassISIN
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassInvestmentID, kn) {
						currentKey = ffjtShareClassInvestmentID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassIsDepositaryReceipt, kn) {
						currentKey = ffjtShareClassIsDepositaryReceipt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassIsDirectInvest, kn) {
						currentKey = ffjtShareClassIsDirectInvest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassIsDividendReinvest, kn) {
						currentKey = ffjtShareClassIsDividendReinvest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassIsPrimaryShare, kn) {
						currentKey = ffjtShareClassIsPrimaryShare
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyShareClassMIC, kn) {
						currentKey = ffjtShareClassMIC
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyShareClassSEDOL, kn) {
						currentKey = ffjtShareClassSEDOL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassSecurityType, kn) {
						currentKey = ffjtShareClassSecurityType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassShareClassID, kn) {
						currentKey = ffjtShareClassShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassShareClassStatus, kn) {
						currentKey = ffjtShareClassShareClassStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassSymbol, kn) {
						currentKey = ffjtShareClassSymbol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyShareClassTradingStatus, kn) {
						currentKey = ffjtShareClassTradingStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyShareClassValoren, kn) {
						currentKey = ffjtShareClassValoren
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyShareClassValoren, kn) {
					currentKey = ffjtShareClassValoren
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassTradingStatus, kn) {
					currentKey = ffjtShareClassTradingStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassSymbol, kn) {
					currentKey = ffjtShareClassSymbol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassShareClassStatus, kn) {
					currentKey = ffjtShareClassShareClassStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassShareClassID, kn) {
					currentKey = ffjtShareClassShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassSecurityType, kn) {
					currentKey = ffjtShareClassSecurityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassSEDOL, kn) {
					currentKey = ffjtShareClassSEDOL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShareClassMIC, kn) {
					currentKey = ffjtShareClassMIC
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassIsPrimaryShare, kn) {
					currentKey = ffjtShareClassIsPrimaryShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassIsDividendReinvest, kn) {
					currentKey = ffjtShareClassIsDividendReinvest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassIsDirectInvest, kn) {
					currentKey = ffjtShareClassIsDirectInvest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassIsDepositaryReceipt, kn) {
					currentKey = ffjtShareClassIsDepositaryReceipt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassInvestmentID, kn) {
					currentKey = ffjtShareClassInvestmentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassISIN, kn) {
					currentKey = ffjtShareClassISIN
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShareClassIPODate, kn) {
					currentKey = ffjtShareClassIPODate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShareClassExchangeID, kn) {
					currentKey = ffjtShareClassExchangeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassDelistingDate, kn) {
					currentKey = ffjtShareClassDelistingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShareClassCurrencyID, kn) {
					currentKey = ffjtShareClassCurrencyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassCUSIP, kn) {
					currentKey = ffjtShareClassCUSIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShareClassCompanyID, kn) {
					currentKey = ffjtShareClassCompanyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShareClassnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShareClassCompanyID:
					goto handle_CompanyID

				case ffjtShareClassCUSIP:
					goto handle_CUSIP

				case ffjtShareClassCurrencyID:
					goto handle_CurrencyID

				case ffjtShareClassDelistingDate:
					goto handle_DelistingDate

				case ffjtShareClassExchangeID:
					goto handle_ExchangeID

				case ffjtShareClassIPODate:
					goto handle_IPODate

				case ffjtShareClassISIN:
					goto handle_ISIN

				case ffjtShareClassInvestmentID:
					goto handle_InvestmentID

				case ffjtShareClassIsDepositaryReceipt:
					goto handle_IsDepositaryReceipt

				case ffjtShareClassIsDirectInvest:
					goto handle_IsDirectInvest

				case ffjtShareClassIsDividendReinvest:
					goto handle_IsDividendReinvest

				case ffjtShareClassIsPrimaryShare:
					goto handle_IsPrimaryShare

				case ffjtShareClassMIC:
					goto handle_MIC

				case ffjtShareClassSEDOL:
					goto handle_SEDOL

				case ffjtShareClassSecurityType:
					goto handle_SecurityType

				case ffjtShareClassShareClassID:
					goto handle_ShareClassID

				case ffjtShareClassShareClassStatus:
					goto handle_ShareClassStatus

				case ffjtShareClassSymbol:
					goto handle_Symbol

				case ffjtShareClassTradingStatus:
					goto handle_TradingStatus

				case ffjtShareClassValoren:
					goto handle_Valoren

				case ffjtShareClassnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CompanyID:

	/* handler: j.CompanyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CompanyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CompanyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CUSIP:

	/* handler: j.CUSIP type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CUSIP = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CUSIP = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencyID:

	/* handler: j.CurrencyID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.CurrencyID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.CurrencyID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DelistingDate:

	/* handler: j.DelistingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.DelistingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.DelistingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExchangeID:

	/* handler: j.ExchangeID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ExchangeID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ExchangeID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPODate:

	/* handler: j.IPODate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.IPODate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.IPODate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ISIN:

	/* handler: j.ISIN type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ISIN = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ISIN = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvestmentID:

	/* handler: j.InvestmentID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.InvestmentID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.InvestmentID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsDepositaryReceipt:

	/* handler: j.IsDepositaryReceipt type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			j.IsDepositaryReceipt = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			j.IsDepositaryReceipt = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsDirectInvest:

	/* handler: j.IsDirectInvest type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			j.IsDirectInvest = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			j.IsDirectInvest = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsDividendReinvest:

	/* handler: j.IsDividendReinvest type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			j.IsDividendReinvest = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			j.IsDividendReinvest = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPrimaryShare:

	/* handler: j.IsPrimaryShare type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			j.IsPrimaryShare = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			j.IsPrimaryShare = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MIC:

	/* handler: j.MIC type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.MIC = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.MIC = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SEDOL:

	/* handler: j.SEDOL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SEDOL = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SEDOL = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SecurityType:

	/* handler: j.SecurityType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SecurityType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SecurityType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassStatus:

	/* handler: j.ShareClassStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassStatus = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassStatus = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbol:

	/* handler: j.Symbol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Symbol = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Symbol = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TradingStatus:

	/* handler: j.TradingStatus type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			j.TradingStatus = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			j.TradingStatus = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Valoren:

	/* handler: j.Valoren type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Valoren = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Valoren = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShareClassProfile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShareClassProfile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.EnterpriseValueAsOfDate != nil {
		buf.WriteString(`{"EnterpriseValue.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.EnterpriseValueAsOfDate))
	} else {
		buf.WriteString(`{"EnterpriseValue.asOfDate":null`)
	}
	if j.MarketCapAsOfDate != nil {
		buf.WriteString(`,"MarketCap.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.MarketCapAsOfDate))
	} else {
		buf.WriteString(`,"MarketCap.asOfDate":null`)
	}
	if j.SharesOutstandingAsOfDate != nil {
		buf.WriteString(`,"SharesOutstanding.asOfDate":`)
		fflib.WriteJsonString(buf, string(*j.SharesOutstandingAsOfDate))
	} else {
		buf.WriteString(`,"SharesOutstanding.asOfDate":null`)
	}
	if j.EnterpriseValue != nil {
		buf.WriteString(`,"enterprise_value":`)
		fflib.FormatBits2(buf, uint64(*j.EnterpriseValue), 10, *j.EnterpriseValue < 0)
	} else {
		buf.WriteString(`,"enterprise_value":null`)
	}
	if j.MarketCap != nil {
		buf.WriteString(`,"market_cap":`)
		fflib.FormatBits2(buf, uint64(*j.MarketCap), 10, *j.MarketCap < 0)
	} else {
		buf.WriteString(`,"market_cap":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	if j.ShareClassLevelSharesOutstanding != nil {
		buf.WriteString(`,"share_class_level_shares_outstanding":`)
		fflib.FormatBits2(buf, uint64(*j.ShareClassLevelSharesOutstanding), 10, *j.ShareClassLevelSharesOutstanding < 0)
	} else {
		buf.WriteString(`,"share_class_level_shares_outstanding":null`)
	}
	if j.SharesOutstanding != nil {
		buf.WriteString(`,"shares_outstanding":`)
		fflib.FormatBits2(buf, uint64(*j.SharesOutstanding), 10, *j.SharesOutstanding < 0)
	} else {
		buf.WriteString(`,"shares_outstanding":null`)
	}
	if j.SharesOutstandingWithBalanceSheetEndingDate != nil {
		buf.WriteString(`,"shares_outstanding_with_balance_sheet_ending_date":`)
		fflib.WriteJsonString(buf, string(*j.SharesOutstandingWithBalanceSheetEndingDate))
	} else {
		buf.WriteString(`,"shares_outstanding_with_balance_sheet_ending_date":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShareClassProfilebase = iota
	ffjtShareClassProfilenosuchkey

	ffjtShareClassProfileEnterpriseValueAsOfDate

	ffjtShareClassProfileMarketCapAsOfDate

	ffjtShareClassProfileSharesOutstandingAsOfDate

	ffjtShareClassProfileEnterpriseValue

	ffjtShareClassProfileMarketCap

	ffjtShareClassProfileShareClassID

	ffjtShareClassProfileShareClassLevelSharesOutstanding

	ffjtShareClassProfileSharesOutstanding

	ffjtShareClassProfileSharesOutstandingWithBalanceSheetEndingDate
)

var ffjKeyShareClassProfileEnterpriseValueAsOfDate = []byte("EnterpriseValue.asOfDate")

var ffjKeyShareClassProfileMarketCapAsOfDate = []byte("MarketCap.asOfDate")

var ffjKeyShareClassProfileSharesOutstandingAsOfDate = []byte("SharesOutstanding.asOfDate")

var ffjKeyShareClassProfileEnterpriseValue = []byte("enterprise_value")

var ffjKeyShareClassProfileMarketCap = []byte("market_cap")

var ffjKeyShareClassProfileShareClassID = []byte("share_class_id")

var ffjKeyShareClassProfileShareClassLevelSharesOutstanding = []byte("share_class_level_shares_outstanding")

var ffjKeyShareClassProfileSharesOutstanding = []byte("shares_outstanding")

var ffjKeyShareClassProfileSharesOutstandingWithBalanceSheetEndingDate = []byte("shares_outstanding_with_balance_sheet_ending_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShareClassProfile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShareClassProfile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShareClassProfilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShareClassProfilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffjKeyShareClassProfileEnterpriseValueAsOfDate, kn) {
						currentKey = ffjtShareClassProfileEnterpriseValueAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffjKeyShareClassProfileMarketCapAsOfDate, kn) {
						currentKey = ffjtShareClassProfileMarketCapAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyShareClassProfileSharesOutstandingAsOfDate, kn) {
						currentKey = ffjtShareClassProfileSharesOutstandingAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyShareClassProfileEnterpriseValue, kn) {
						currentKey = ffjtShareClassProfileEnterpriseValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyShareClassProfileMarketCap, kn) {
						currentKey = ffjtShareClassProfileMarketCap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyShareClassProfileShareClassID, kn) {
						currentKey = ffjtShareClassProfileShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassProfileShareClassLevelSharesOutstanding, kn) {
						currentKey = ffjtShareClassProfileShareClassLevelSharesOutstanding
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassProfileSharesOutstanding, kn) {
						currentKey = ffjtShareClassProfileSharesOutstanding
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShareClassProfileSharesOutstandingWithBalanceSheetEndingDate, kn) {
						currentKey = ffjtShareClassProfileSharesOutstandingWithBalanceSheetEndingDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileSharesOutstandingWithBalanceSheetEndingDate, kn) {
					currentKey = ffjtShareClassProfileSharesOutstandingWithBalanceSheetEndingDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileSharesOutstanding, kn) {
					currentKey = ffjtShareClassProfileSharesOutstanding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileShareClassLevelSharesOutstanding, kn) {
					currentKey = ffjtShareClassProfileShareClassLevelSharesOutstanding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileShareClassID, kn) {
					currentKey = ffjtShareClassProfileShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileMarketCap, kn) {
					currentKey = ffjtShareClassProfileMarketCap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileEnterpriseValue, kn) {
					currentKey = ffjtShareClassProfileEnterpriseValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileSharesOutstandingAsOfDate, kn) {
					currentKey = ffjtShareClassProfileSharesOutstandingAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileMarketCapAsOfDate, kn) {
					currentKey = ffjtShareClassProfileMarketCapAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShareClassProfileEnterpriseValueAsOfDate, kn) {
					currentKey = ffjtShareClassProfileEnterpriseValueAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShareClassProfilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShareClassProfileEnterpriseValueAsOfDate:
					goto handle_EnterpriseValueAsOfDate

				case ffjtShareClassProfileMarketCapAsOfDate:
					goto handle_MarketCapAsOfDate

				case ffjtShareClassProfileSharesOutstandingAsOfDate:
					goto handle_SharesOutstandingAsOfDate

				case ffjtShareClassProfileEnterpriseValue:
					goto handle_EnterpriseValue

				case ffjtShareClassProfileMarketCap:
					goto handle_MarketCap

				case ffjtShareClassProfileShareClassID:
					goto handle_ShareClassID

				case ffjtShareClassProfileShareClassLevelSharesOutstanding:
					goto handle_ShareClassLevelSharesOutstanding

				case ffjtShareClassProfileSharesOutstanding:
					goto handle_SharesOutstanding

				case ffjtShareClassProfileSharesOutstandingWithBalanceSheetEndingDate:
					goto handle_SharesOutstandingWithBalanceSheetEndingDate

				case ffjtShareClassProfilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_EnterpriseValueAsOfDate:

	/* handler: j.EnterpriseValueAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.EnterpriseValueAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.EnterpriseValueAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketCapAsOfDate:

	/* handler: j.MarketCapAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.MarketCapAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.MarketCapAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharesOutstandingAsOfDate:

	/* handler: j.SharesOutstandingAsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SharesOutstandingAsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SharesOutstandingAsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EnterpriseValue:

	/* handler: j.EnterpriseValue type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EnterpriseValue = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.EnterpriseValue = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketCap:

	/* handler: j.MarketCap type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.MarketCap = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.MarketCap = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassLevelSharesOutstanding:

	/* handler: j.ShareClassLevelSharesOutstanding type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ShareClassLevelSharesOutstanding = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.ShareClassLevelSharesOutstanding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharesOutstanding:

	/* handler: j.SharesOutstanding type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SharesOutstanding = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.SharesOutstanding = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharesOutstandingWithBalanceSheetEndingDate:

	/* handler: j.SharesOutstandingWithBalanceSheetEndingDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SharesOutstandingWithBalanceSheetEndingDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SharesOutstandingWithBalanceSheetEndingDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *StockSplit) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *StockSplit) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AdjustmentFactor != nil {
		buf.WriteString(`{"adjustment_factor":`)
		fflib.AppendFloat(buf, float64(*j.AdjustmentFactor), 'g', -1, 64)
	} else {
		buf.WriteString(`{"adjustment_factor":null`)
	}
	if j.ExDate != nil {
		buf.WriteString(`,"ex_date":`)
		fflib.WriteJsonString(buf, string(*j.ExDate))
	} else {
		buf.WriteString(`,"ex_date":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	if j.SplitFrom != nil {
		buf.WriteString(`,"split_from":`)
		fflib.AppendFloat(buf, float64(*j.SplitFrom), 'g', -1, 64)
	} else {
		buf.WriteString(`,"split_from":null`)
	}
	if j.SplitTo != nil {
		buf.WriteString(`,"split_to":`)
		fflib.AppendFloat(buf, float64(*j.SplitTo), 'g', -1, 64)
	} else {
		buf.WriteString(`,"split_to":null`)
	}
	if j.SplitType != nil {
		buf.WriteString(`,"split_type":`)
		fflib.WriteJsonString(buf, string(*j.SplitType))
	} else {
		buf.WriteString(`,"split_type":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtStockSplitbase = iota
	ffjtStockSplitnosuchkey

	ffjtStockSplitAdjustmentFactor

	ffjtStockSplitExDate

	ffjtStockSplitShareClassID

	ffjtStockSplitSplitFrom

	ffjtStockSplitSplitTo

	ffjtStockSplitSplitType
)

var ffjKeyStockSplitAdjustmentFactor = []byte("adjustment_factor")

var ffjKeyStockSplitExDate = []byte("ex_date")

var ffjKeyStockSplitShareClassID = []byte("share_class_id")

var ffjKeyStockSplitSplitFrom = []byte("split_from")

var ffjKeyStockSplitSplitTo = []byte("split_to")

var ffjKeyStockSplitSplitType = []byte("split_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *StockSplit) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *StockSplit) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtStockSplitbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtStockSplitnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyStockSplitAdjustmentFactor, kn) {
						currentKey = ffjtStockSplitAdjustmentFactor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyStockSplitExDate, kn) {
						currentKey = ffjtStockSplitExDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyStockSplitShareClassID, kn) {
						currentKey = ffjtStockSplitShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStockSplitSplitFrom, kn) {
						currentKey = ffjtStockSplitSplitFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStockSplitSplitTo, kn) {
						currentKey = ffjtStockSplitSplitTo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStockSplitSplitType, kn) {
						currentKey = ffjtStockSplitSplitType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyStockSplitSplitType, kn) {
					currentKey = ffjtStockSplitSplitType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStockSplitSplitTo, kn) {
					currentKey = ffjtStockSplitSplitTo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStockSplitSplitFrom, kn) {
					currentKey = ffjtStockSplitSplitFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStockSplitShareClassID, kn) {
					currentKey = ffjtStockSplitShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyStockSplitExDate, kn) {
					currentKey = ffjtStockSplitExDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStockSplitAdjustmentFactor, kn) {
					currentKey = ffjtStockSplitAdjustmentFactor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtStockSplitnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtStockSplitAdjustmentFactor:
					goto handle_AdjustmentFactor

				case ffjtStockSplitExDate:
					goto handle_ExDate

				case ffjtStockSplitShareClassID:
					goto handle_ShareClassID

				case ffjtStockSplitSplitFrom:
					goto handle_SplitFrom

				case ffjtStockSplitSplitTo:
					goto handle_SplitTo

				case ffjtStockSplitSplitType:
					goto handle_SplitType

				case ffjtStockSplitnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AdjustmentFactor:

	/* handler: j.AdjustmentFactor type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.AdjustmentFactor = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.AdjustmentFactor = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExDate:

	/* handler: j.ExDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ExDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ExDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SplitFrom:

	/* handler: j.SplitFrom type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SplitFrom = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SplitFrom = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SplitTo:

	/* handler: j.SplitTo type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SplitTo = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SplitTo = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SplitType:

	/* handler: j.SplitType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SplitType = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SplitType = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *TrailingReturns) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *TrailingReturns) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.ShareClassID != nil {
		buf.WriteString(`{"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`{"share_class_id":null`)
	}
	if j.AsOfDate != nil {
		buf.WriteString(`,"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`,"as_of_date":null`)
	}
	if j.Period != nil {
		buf.WriteString(`,"period":`)
		fflib.WriteJsonString(buf, string(*j.Period))
	} else {
		buf.WriteString(`,"period":null`)
	}
	if j.TotalReturn != nil {
		buf.WriteString(`,"total_return":`)
		fflib.AppendFloat(buf, float64(*j.TotalReturn), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_return":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtTrailingReturnsbase = iota
	ffjtTrailingReturnsnosuchkey

	ffjtTrailingReturnsShareClassID

	ffjtTrailingReturnsAsOfDate

	ffjtTrailingReturnsPeriod

	ffjtTrailingReturnsTotalReturn
)

var ffjKeyTrailingReturnsShareClassID = []byte("share_class_id")

var ffjKeyTrailingReturnsAsOfDate = []byte("as_of_date")

var ffjKeyTrailingReturnsPeriod = []byte("period")

var ffjKeyTrailingReturnsTotalReturn = []byte("total_return")

// UnmarshalJSON umarshall json - template of ffjson
func (j *TrailingReturns) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *TrailingReturns) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtTrailingReturnsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtTrailingReturnsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyTrailingReturnsAsOfDate, kn) {
						currentKey = ffjtTrailingReturnsAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyTrailingReturnsPeriod, kn) {
						currentKey = ffjtTrailingReturnsPeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyTrailingReturnsShareClassID, kn) {
						currentKey = ffjtTrailingReturnsShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyTrailingReturnsTotalReturn, kn) {
						currentKey = ffjtTrailingReturnsTotalReturn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyTrailingReturnsTotalReturn, kn) {
					currentKey = ffjtTrailingReturnsTotalReturn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyTrailingReturnsPeriod, kn) {
					currentKey = ffjtTrailingReturnsPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTrailingReturnsAsOfDate, kn) {
					currentKey = ffjtTrailingReturnsAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyTrailingReturnsShareClassID, kn) {
					currentKey = ffjtTrailingReturnsShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtTrailingReturnsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtTrailingReturnsShareClassID:
					goto handle_ShareClassID

				case ffjtTrailingReturnsAsOfDate:
					goto handle_AsOfDate

				case ffjtTrailingReturnsPeriod:
					goto handle_Period

				case ffjtTrailingReturnsTotalReturn:
					goto handle_TotalReturn

				case ffjtTrailingReturnsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Period:

	/* handler: j.Period type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Period = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Period = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalReturn:

	/* handler: j.TotalReturn type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalReturn = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalReturn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ValuationRatios) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ValuationRatios) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.AsOfDate != nil {
		buf.WriteString(`{"as_of_date":`)
		fflib.WriteJsonString(buf, string(*j.AsOfDate))
	} else {
		buf.WriteString(`{"as_of_date":null`)
	}
	if j.BookValuePerShare != nil {
		buf.WriteString(`,"book_value_per_share":`)
		fflib.AppendFloat(buf, float64(*j.BookValuePerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"book_value_per_share":null`)
	}
	if j.BookValueYield != nil {
		buf.WriteString(`,"book_value_yield":`)
		fflib.AppendFloat(buf, float64(*j.BookValueYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"book_value_yield":null`)
	}
	if j.BuyBackYield != nil {
		buf.WriteString(`,"buy_back_yield":`)
		fflib.AppendFloat(buf, float64(*j.BuyBackYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"buy_back_yield":null`)
	}
	if j.CFOPerShare != nil {
		buf.WriteString(`,"c_f_o_per_share":`)
		fflib.AppendFloat(buf, float64(*j.CFOPerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"c_f_o_per_share":null`)
	}
	if j.CFYield != nil {
		buf.WriteString(`,"c_f_yield":`)
		fflib.AppendFloat(buf, float64(*j.CFYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"c_f_yield":null`)
	}
	if j.CashReturn != nil {
		buf.WriteString(`,"cash_return":`)
		fflib.AppendFloat(buf, float64(*j.CashReturn), 'g', -1, 64)
	} else {
		buf.WriteString(`,"cash_return":null`)
	}
	if j.DividendRate != nil {
		buf.WriteString(`,"dividend_rate":`)
		fflib.AppendFloat(buf, float64(*j.DividendRate), 'g', -1, 64)
	} else {
		buf.WriteString(`,"dividend_rate":null`)
	}
	if j.DividendYield != nil {
		buf.WriteString(`,"dividend_yield":`)
		fflib.AppendFloat(buf, float64(*j.DividendYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"dividend_yield":null`)
	}
	if j.EVToEBITDA != nil {
		buf.WriteString(`,"e_v_to_e_b_i_t_d_a":`)
		fflib.AppendFloat(buf, float64(*j.EVToEBITDA), 'g', -1, 64)
	} else {
		buf.WriteString(`,"e_v_to_e_b_i_t_d_a":null`)
	}
	if j.EarningYield != nil {
		buf.WriteString(`,"earning_yield":`)
		fflib.AppendFloat(buf, float64(*j.EarningYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"earning_yield":null`)
	}
	if j.FCFPerShare != nil {
		buf.WriteString(`,"f_c_f_per_share":`)
		fflib.AppendFloat(buf, float64(*j.FCFPerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"f_c_f_per_share":null`)
	}
	if j.FCFRatio != nil {
		buf.WriteString(`,"f_c_f_ratio":`)
		fflib.AppendFloat(buf, float64(*j.FCFRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"f_c_f_ratio":null`)
	}
	if j.FCFYield != nil {
		buf.WriteString(`,"f_c_f_yield":`)
		fflib.AppendFloat(buf, float64(*j.FCFYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"f_c_f_yield":null`)
	}
	if j.ForwardDividendYield != nil {
		buf.WriteString(`,"forward_dividend_yield":`)
		fflib.AppendFloat(buf, float64(*j.ForwardDividendYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"forward_dividend_yield":null`)
	}
	if j.ForwardEarningYield != nil {
		buf.WriteString(`,"forward_earning_yield":`)
		fflib.AppendFloat(buf, float64(*j.ForwardEarningYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"forward_earning_yield":null`)
	}
	if j.ForwardPERatio != nil {
		buf.WriteString(`,"forward_p_e_ratio":`)
		fflib.AppendFloat(buf, float64(*j.ForwardPERatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"forward_p_e_ratio":null`)
	}
	if j.NormalizedPERatio != nil {
		buf.WriteString(`,"normalized_p_e_ratio":`)
		fflib.AppendFloat(buf, float64(*j.NormalizedPERatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"normalized_p_e_ratio":null`)
	}
	if j.PBRatio != nil {
		buf.WriteString(`,"p_b_ratio":`)
		fflib.AppendFloat(buf, float64(*j.PBRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"p_b_ratio":null`)
	}
	if j.PCFRatio != nil {
		buf.WriteString(`,"p_c_f_ratio":`)
		fflib.AppendFloat(buf, float64(*j.PCFRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"p_c_f_ratio":null`)
	}
	if j.PEGPayback != nil {
		buf.WriteString(`,"p_e_g_payback":`)
		fflib.AppendFloat(buf, float64(*j.PEGPayback), 'g', -1, 64)
	} else {
		buf.WriteString(`,"p_e_g_payback":null`)
	}
	if j.PEGRatio != nil {
		buf.WriteString(`,"p_e_g_ratio":`)
		fflib.AppendFloat(buf, float64(*j.PEGRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"p_e_g_ratio":null`)
	}
	if j.PERatio != nil {
		buf.WriteString(`,"p_e_ratio":`)
		fflib.AppendFloat(buf, float64(*j.PERatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"p_e_ratio":null`)
	}
	if j.PSRatio != nil {
		buf.WriteString(`,"p_s_ratio":`)
		fflib.AppendFloat(buf, float64(*j.PSRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"p_s_ratio":null`)
	}
	if j.PayoutRatio != nil {
		buf.WriteString(`,"payout_ratio":`)
		fflib.AppendFloat(buf, float64(*j.PayoutRatio), 'g', -1, 64)
	} else {
		buf.WriteString(`,"payout_ratio":null`)
	}
	if j.PriceChange1M != nil {
		buf.WriteString(`,"price_change1_m":`)
		fflib.AppendFloat(buf, float64(*j.PriceChange1M), 'g', -1, 64)
	} else {
		buf.WriteString(`,"price_change1_m":null`)
	}
	if j.PriceToEBITDA != nil {
		buf.WriteString(`,"priceto_e_b_i_t_d_a":`)
		fflib.AppendFloat(buf, float64(*j.PriceToEBITDA), 'g', -1, 64)
	} else {
		buf.WriteString(`,"priceto_e_b_i_t_d_a":null`)
	}
	if j.RatioPE5YearAverage != nil {
		buf.WriteString(`,"ratio_p_e5_year_average":`)
		fflib.AppendFloat(buf, float64(*j.RatioPE5YearAverage), 'g', -1, 64)
	} else {
		buf.WriteString(`,"ratio_p_e5_year_average":null`)
	}
	if j.SalesPerShare != nil {
		buf.WriteString(`,"sales_per_share":`)
		fflib.AppendFloat(buf, float64(*j.SalesPerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"sales_per_share":null`)
	}
	if j.SalesYield != nil {
		buf.WriteString(`,"sales_yield":`)
		fflib.AppendFloat(buf, float64(*j.SalesYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"sales_yield":null`)
	}
	if j.ShareClassID != nil {
		buf.WriteString(`,"share_class_id":`)
		fflib.WriteJsonString(buf, string(*j.ShareClassID))
	} else {
		buf.WriteString(`,"share_class_id":null`)
	}
	if j.SustainableGrowthRate != nil {
		buf.WriteString(`,"sustainable_growth_rate":`)
		fflib.AppendFloat(buf, float64(*j.SustainableGrowthRate), 'g', -1, 64)
	} else {
		buf.WriteString(`,"sustainable_growth_rate":null`)
	}
	if j.TangibleBVPerShare3YearAvg != nil {
		buf.WriteString(`,"tangible_b_v_per_share3_yr_avg":`)
		fflib.AppendFloat(buf, float64(*j.TangibleBVPerShare3YearAvg), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tangible_b_v_per_share3_yr_avg":null`)
	}
	if j.TangibleBVPerShare5YearAvg != nil {
		buf.WriteString(`,"tangible_b_v_per_share5_yr_avg":`)
		fflib.AppendFloat(buf, float64(*j.TangibleBVPerShare5YearAvg), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tangible_b_v_per_share5_yr_avg":null`)
	}
	if j.TangibleBookValuePerShare != nil {
		buf.WriteString(`,"tangible_book_value_per_share":`)
		fflib.AppendFloat(buf, float64(*j.TangibleBookValuePerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"tangible_book_value_per_share":null`)
	}
	if j.TotalYield != nil {
		buf.WriteString(`,"total_yield":`)
		fflib.AppendFloat(buf, float64(*j.TotalYield), 'g', -1, 64)
	} else {
		buf.WriteString(`,"total_yield":null`)
	}
	if j.WorkingCapitalPerShare != nil {
		buf.WriteString(`,"working_capital_per_share":`)
		fflib.AppendFloat(buf, float64(*j.WorkingCapitalPerShare), 'g', -1, 64)
	} else {
		buf.WriteString(`,"working_capital_per_share":null`)
	}
	if j.WorkingCapitalPerShare3YearAvg != nil {
		buf.WriteString(`,"working_capital_per_share3_yr_avg":`)
		fflib.AppendFloat(buf, float64(*j.WorkingCapitalPerShare3YearAvg), 'g', -1, 64)
	} else {
		buf.WriteString(`,"working_capital_per_share3_yr_avg":null`)
	}
	if j.WorkingCapitalPerShare5YearAvg != nil {
		buf.WriteString(`,"working_capital_per_share5_yr_avg":`)
		fflib.AppendFloat(buf, float64(*j.WorkingCapitalPerShare5YearAvg), 'g', -1, 64)
	} else {
		buf.WriteString(`,"working_capital_per_share5_yr_avg":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtValuationRatiosbase = iota
	ffjtValuationRatiosnosuchkey

	ffjtValuationRatiosAsOfDate

	ffjtValuationRatiosBookValuePerShare

	ffjtValuationRatiosBookValueYield

	ffjtValuationRatiosBuyBackYield

	ffjtValuationRatiosCFOPerShare

	ffjtValuationRatiosCFYield

	ffjtValuationRatiosCashReturn

	ffjtValuationRatiosDividendRate

	ffjtValuationRatiosDividendYield

	ffjtValuationRatiosEVToEBITDA

	ffjtValuationRatiosEarningYield

	ffjtValuationRatiosFCFPerShare

	ffjtValuationRatiosFCFRatio

	ffjtValuationRatiosFCFYield

	ffjtValuationRatiosForwardDividendYield

	ffjtValuationRatiosForwardEarningYield

	ffjtValuationRatiosForwardPERatio

	ffjtValuationRatiosNormalizedPERatio

	ffjtValuationRatiosPBRatio

	ffjtValuationRatiosPCFRatio

	ffjtValuationRatiosPEGPayback

	ffjtValuationRatiosPEGRatio

	ffjtValuationRatiosPERatio

	ffjtValuationRatiosPSRatio

	ffjtValuationRatiosPayoutRatio

	ffjtValuationRatiosPriceChange1M

	ffjtValuationRatiosPriceToEBITDA

	ffjtValuationRatiosRatioPE5YearAverage

	ffjtValuationRatiosSalesPerShare

	ffjtValuationRatiosSalesYield

	ffjtValuationRatiosShareClassID

	ffjtValuationRatiosSustainableGrowthRate

	ffjtValuationRatiosTangibleBVPerShare3YearAvg

	ffjtValuationRatiosTangibleBVPerShare5YearAvg

	ffjtValuationRatiosTangibleBookValuePerShare

	ffjtValuationRatiosTotalYield

	ffjtValuationRatiosWorkingCapitalPerShare

	ffjtValuationRatiosWorkingCapitalPerShare3YearAvg

	ffjtValuationRatiosWorkingCapitalPerShare5YearAvg
)

var ffjKeyValuationRatiosAsOfDate = []byte("as_of_date")

var ffjKeyValuationRatiosBookValuePerShare = []byte("book_value_per_share")

var ffjKeyValuationRatiosBookValueYield = []byte("book_value_yield")

var ffjKeyValuationRatiosBuyBackYield = []byte("buy_back_yield")

var ffjKeyValuationRatiosCFOPerShare = []byte("c_f_o_per_share")

var ffjKeyValuationRatiosCFYield = []byte("c_f_yield")

var ffjKeyValuationRatiosCashReturn = []byte("cash_return")

var ffjKeyValuationRatiosDividendRate = []byte("dividend_rate")

var ffjKeyValuationRatiosDividendYield = []byte("dividend_yield")

var ffjKeyValuationRatiosEVToEBITDA = []byte("e_v_to_e_b_i_t_d_a")

var ffjKeyValuationRatiosEarningYield = []byte("earning_yield")

var ffjKeyValuationRatiosFCFPerShare = []byte("f_c_f_per_share")

var ffjKeyValuationRatiosFCFRatio = []byte("f_c_f_ratio")

var ffjKeyValuationRatiosFCFYield = []byte("f_c_f_yield")

var ffjKeyValuationRatiosForwardDividendYield = []byte("forward_dividend_yield")

var ffjKeyValuationRatiosForwardEarningYield = []byte("forward_earning_yield")

var ffjKeyValuationRatiosForwardPERatio = []byte("forward_p_e_ratio")

var ffjKeyValuationRatiosNormalizedPERatio = []byte("normalized_p_e_ratio")

var ffjKeyValuationRatiosPBRatio = []byte("p_b_ratio")

var ffjKeyValuationRatiosPCFRatio = []byte("p_c_f_ratio")

var ffjKeyValuationRatiosPEGPayback = []byte("p_e_g_payback")

var ffjKeyValuationRatiosPEGRatio = []byte("p_e_g_ratio")

var ffjKeyValuationRatiosPERatio = []byte("p_e_ratio")

var ffjKeyValuationRatiosPSRatio = []byte("p_s_ratio")

var ffjKeyValuationRatiosPayoutRatio = []byte("payout_ratio")

var ffjKeyValuationRatiosPriceChange1M = []byte("price_change1_m")

var ffjKeyValuationRatiosPriceToEBITDA = []byte("priceto_e_b_i_t_d_a")

var ffjKeyValuationRatiosRatioPE5YearAverage = []byte("ratio_p_e5_year_average")

var ffjKeyValuationRatiosSalesPerShare = []byte("sales_per_share")

var ffjKeyValuationRatiosSalesYield = []byte("sales_yield")

var ffjKeyValuationRatiosShareClassID = []byte("share_class_id")

var ffjKeyValuationRatiosSustainableGrowthRate = []byte("sustainable_growth_rate")

var ffjKeyValuationRatiosTangibleBVPerShare3YearAvg = []byte("tangible_b_v_per_share3_yr_avg")

var ffjKeyValuationRatiosTangibleBVPerShare5YearAvg = []byte("tangible_b_v_per_share5_yr_avg")

var ffjKeyValuationRatiosTangibleBookValuePerShare = []byte("tangible_book_value_per_share")

var ffjKeyValuationRatiosTotalYield = []byte("total_yield")

var ffjKeyValuationRatiosWorkingCapitalPerShare = []byte("working_capital_per_share")

var ffjKeyValuationRatiosWorkingCapitalPerShare3YearAvg = []byte("working_capital_per_share3_yr_avg")

var ffjKeyValuationRatiosWorkingCapitalPerShare5YearAvg = []byte("working_capital_per_share5_yr_avg")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ValuationRatios) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ValuationRatios) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtValuationRatiosbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtValuationRatiosnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyValuationRatiosAsOfDate, kn) {
						currentKey = ffjtValuationRatiosAsOfDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyValuationRatiosBookValuePerShare, kn) {
						currentKey = ffjtValuationRatiosBookValuePerShare
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosBookValueYield, kn) {
						currentKey = ffjtValuationRatiosBookValueYield
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosBuyBackYield, kn) {
						currentKey = ffjtValuationRatiosBuyBackYield
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyValuationRatiosCFOPerShare, kn) {
						currentKey = ffjtValuationRatiosCFOPerShare
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosCFYield, kn) {
						currentKey = ffjtValuationRatiosCFYield
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosCashReturn, kn) {
						currentKey = ffjtValuationRatiosCashReturn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyValuationRatiosDividendRate, kn) {
						currentKey = ffjtValuationRatiosDividendRate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosDividendYield, kn) {
						currentKey = ffjtValuationRatiosDividendYield
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyValuationRatiosEVToEBITDA, kn) {
						currentKey = ffjtValuationRatiosEVToEBITDA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosEarningYield, kn) {
						currentKey = ffjtValuationRatiosEarningYield
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyValuationRatiosFCFPerShare, kn) {
						currentKey = ffjtValuationRatiosFCFPerShare
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosFCFRatio, kn) {
						currentKey = ffjtValuationRatiosFCFRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosFCFYield, kn) {
						currentKey = ffjtValuationRatiosFCFYield
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosForwardDividendYield, kn) {
						currentKey = ffjtValuationRatiosForwardDividendYield
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosForwardEarningYield, kn) {
						currentKey = ffjtValuationRatiosForwardEarningYield
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosForwardPERatio, kn) {
						currentKey = ffjtValuationRatiosForwardPERatio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyValuationRatiosNormalizedPERatio, kn) {
						currentKey = ffjtValuationRatiosNormalizedPERatio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyValuationRatiosPBRatio, kn) {
						currentKey = ffjtValuationRatiosPBRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPCFRatio, kn) {
						currentKey = ffjtValuationRatiosPCFRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPEGPayback, kn) {
						currentKey = ffjtValuationRatiosPEGPayback
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPEGRatio, kn) {
						currentKey = ffjtValuationRatiosPEGRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPERatio, kn) {
						currentKey = ffjtValuationRatiosPERatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPSRatio, kn) {
						currentKey = ffjtValuationRatiosPSRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPayoutRatio, kn) {
						currentKey = ffjtValuationRatiosPayoutRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPriceChange1M, kn) {
						currentKey = ffjtValuationRatiosPriceChange1M
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosPriceToEBITDA, kn) {
						currentKey = ffjtValuationRatiosPriceToEBITDA
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyValuationRatiosRatioPE5YearAverage, kn) {
						currentKey = ffjtValuationRatiosRatioPE5YearAverage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyValuationRatiosSalesPerShare, kn) {
						currentKey = ffjtValuationRatiosSalesPerShare
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosSalesYield, kn) {
						currentKey = ffjtValuationRatiosSalesYield
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosShareClassID, kn) {
						currentKey = ffjtValuationRatiosShareClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosSustainableGrowthRate, kn) {
						currentKey = ffjtValuationRatiosSustainableGrowthRate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyValuationRatiosTangibleBVPerShare3YearAvg, kn) {
						currentKey = ffjtValuationRatiosTangibleBVPerShare3YearAvg
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosTangibleBVPerShare5YearAvg, kn) {
						currentKey = ffjtValuationRatiosTangibleBVPerShare5YearAvg
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosTangibleBookValuePerShare, kn) {
						currentKey = ffjtValuationRatiosTangibleBookValuePerShare
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosTotalYield, kn) {
						currentKey = ffjtValuationRatiosTotalYield
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyValuationRatiosWorkingCapitalPerShare, kn) {
						currentKey = ffjtValuationRatiosWorkingCapitalPerShare
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosWorkingCapitalPerShare3YearAvg, kn) {
						currentKey = ffjtValuationRatiosWorkingCapitalPerShare3YearAvg
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyValuationRatiosWorkingCapitalPerShare5YearAvg, kn) {
						currentKey = ffjtValuationRatiosWorkingCapitalPerShare5YearAvg
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosWorkingCapitalPerShare5YearAvg, kn) {
					currentKey = ffjtValuationRatiosWorkingCapitalPerShare5YearAvg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosWorkingCapitalPerShare3YearAvg, kn) {
					currentKey = ffjtValuationRatiosWorkingCapitalPerShare3YearAvg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosWorkingCapitalPerShare, kn) {
					currentKey = ffjtValuationRatiosWorkingCapitalPerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosTotalYield, kn) {
					currentKey = ffjtValuationRatiosTotalYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosTangibleBookValuePerShare, kn) {
					currentKey = ffjtValuationRatiosTangibleBookValuePerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosTangibleBVPerShare5YearAvg, kn) {
					currentKey = ffjtValuationRatiosTangibleBVPerShare5YearAvg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosTangibleBVPerShare3YearAvg, kn) {
					currentKey = ffjtValuationRatiosTangibleBVPerShare3YearAvg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosSustainableGrowthRate, kn) {
					currentKey = ffjtValuationRatiosSustainableGrowthRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosShareClassID, kn) {
					currentKey = ffjtValuationRatiosShareClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosSalesYield, kn) {
					currentKey = ffjtValuationRatiosSalesYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosSalesPerShare, kn) {
					currentKey = ffjtValuationRatiosSalesPerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosRatioPE5YearAverage, kn) {
					currentKey = ffjtValuationRatiosRatioPE5YearAverage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPriceToEBITDA, kn) {
					currentKey = ffjtValuationRatiosPriceToEBITDA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPriceChange1M, kn) {
					currentKey = ffjtValuationRatiosPriceChange1M
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPayoutRatio, kn) {
					currentKey = ffjtValuationRatiosPayoutRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosPSRatio, kn) {
					currentKey = ffjtValuationRatiosPSRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPERatio, kn) {
					currentKey = ffjtValuationRatiosPERatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPEGRatio, kn) {
					currentKey = ffjtValuationRatiosPEGRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosPEGPayback, kn) {
					currentKey = ffjtValuationRatiosPEGPayback
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPCFRatio, kn) {
					currentKey = ffjtValuationRatiosPCFRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosPBRatio, kn) {
					currentKey = ffjtValuationRatiosPBRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosNormalizedPERatio, kn) {
					currentKey = ffjtValuationRatiosNormalizedPERatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosForwardPERatio, kn) {
					currentKey = ffjtValuationRatiosForwardPERatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosForwardEarningYield, kn) {
					currentKey = ffjtValuationRatiosForwardEarningYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosForwardDividendYield, kn) {
					currentKey = ffjtValuationRatiosForwardDividendYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosFCFYield, kn) {
					currentKey = ffjtValuationRatiosFCFYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosFCFRatio, kn) {
					currentKey = ffjtValuationRatiosFCFRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosFCFPerShare, kn) {
					currentKey = ffjtValuationRatiosFCFPerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosEarningYield, kn) {
					currentKey = ffjtValuationRatiosEarningYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosEVToEBITDA, kn) {
					currentKey = ffjtValuationRatiosEVToEBITDA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosDividendYield, kn) {
					currentKey = ffjtValuationRatiosDividendYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosDividendRate, kn) {
					currentKey = ffjtValuationRatiosDividendRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosCashReturn, kn) {
					currentKey = ffjtValuationRatiosCashReturn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyValuationRatiosCFYield, kn) {
					currentKey = ffjtValuationRatiosCFYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosCFOPerShare, kn) {
					currentKey = ffjtValuationRatiosCFOPerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosBuyBackYield, kn) {
					currentKey = ffjtValuationRatiosBuyBackYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosBookValueYield, kn) {
					currentKey = ffjtValuationRatiosBookValueYield
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosBookValuePerShare, kn) {
					currentKey = ffjtValuationRatiosBookValuePerShare
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyValuationRatiosAsOfDate, kn) {
					currentKey = ffjtValuationRatiosAsOfDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtValuationRatiosnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtValuationRatiosAsOfDate:
					goto handle_AsOfDate

				case ffjtValuationRatiosBookValuePerShare:
					goto handle_BookValuePerShare

				case ffjtValuationRatiosBookValueYield:
					goto handle_BookValueYield

				case ffjtValuationRatiosBuyBackYield:
					goto handle_BuyBackYield

				case ffjtValuationRatiosCFOPerShare:
					goto handle_CFOPerShare

				case ffjtValuationRatiosCFYield:
					goto handle_CFYield

				case ffjtValuationRatiosCashReturn:
					goto handle_CashReturn

				case ffjtValuationRatiosDividendRate:
					goto handle_DividendRate

				case ffjtValuationRatiosDividendYield:
					goto handle_DividendYield

				case ffjtValuationRatiosEVToEBITDA:
					goto handle_EVToEBITDA

				case ffjtValuationRatiosEarningYield:
					goto handle_EarningYield

				case ffjtValuationRatiosFCFPerShare:
					goto handle_FCFPerShare

				case ffjtValuationRatiosFCFRatio:
					goto handle_FCFRatio

				case ffjtValuationRatiosFCFYield:
					goto handle_FCFYield

				case ffjtValuationRatiosForwardDividendYield:
					goto handle_ForwardDividendYield

				case ffjtValuationRatiosForwardEarningYield:
					goto handle_ForwardEarningYield

				case ffjtValuationRatiosForwardPERatio:
					goto handle_ForwardPERatio

				case ffjtValuationRatiosNormalizedPERatio:
					goto handle_NormalizedPERatio

				case ffjtValuationRatiosPBRatio:
					goto handle_PBRatio

				case ffjtValuationRatiosPCFRatio:
					goto handle_PCFRatio

				case ffjtValuationRatiosPEGPayback:
					goto handle_PEGPayback

				case ffjtValuationRatiosPEGRatio:
					goto handle_PEGRatio

				case ffjtValuationRatiosPERatio:
					goto handle_PERatio

				case ffjtValuationRatiosPSRatio:
					goto handle_PSRatio

				case ffjtValuationRatiosPayoutRatio:
					goto handle_PayoutRatio

				case ffjtValuationRatiosPriceChange1M:
					goto handle_PriceChange1M

				case ffjtValuationRatiosPriceToEBITDA:
					goto handle_PriceToEBITDA

				case ffjtValuationRatiosRatioPE5YearAverage:
					goto handle_RatioPE5YearAverage

				case ffjtValuationRatiosSalesPerShare:
					goto handle_SalesPerShare

				case ffjtValuationRatiosSalesYield:
					goto handle_SalesYield

				case ffjtValuationRatiosShareClassID:
					goto handle_ShareClassID

				case ffjtValuationRatiosSustainableGrowthRate:
					goto handle_SustainableGrowthRate

				case ffjtValuationRatiosTangibleBVPerShare3YearAvg:
					goto handle_TangibleBVPerShare3YearAvg

				case ffjtValuationRatiosTangibleBVPerShare5YearAvg:
					goto handle_TangibleBVPerShare5YearAvg

				case ffjtValuationRatiosTangibleBookValuePerShare:
					goto handle_TangibleBookValuePerShare

				case ffjtValuationRatiosTotalYield:
					goto handle_TotalYield

				case ffjtValuationRatiosWorkingCapitalPerShare:
					goto handle_WorkingCapitalPerShare

				case ffjtValuationRatiosWorkingCapitalPerShare3YearAvg:
					goto handle_WorkingCapitalPerShare3YearAvg

				case ffjtValuationRatiosWorkingCapitalPerShare5YearAvg:
					goto handle_WorkingCapitalPerShare5YearAvg

				case ffjtValuationRatiosnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AsOfDate:

	/* handler: j.AsOfDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.AsOfDate = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.AsOfDate = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BookValuePerShare:

	/* handler: j.BookValuePerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BookValuePerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BookValuePerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BookValueYield:

	/* handler: j.BookValueYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BookValueYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BookValueYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BuyBackYield:

	/* handler: j.BuyBackYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.BuyBackYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.BuyBackYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CFOPerShare:

	/* handler: j.CFOPerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CFOPerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CFOPerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CFYield:

	/* handler: j.CFYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CFYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CFYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashReturn:

	/* handler: j.CashReturn type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.CashReturn = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.CashReturn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DividendRate:

	/* handler: j.DividendRate type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DividendRate = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DividendRate = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DividendYield:

	/* handler: j.DividendYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.DividendYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.DividendYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EVToEBITDA:

	/* handler: j.EVToEBITDA type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EVToEBITDA = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EVToEBITDA = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EarningYield:

	/* handler: j.EarningYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.EarningYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.EarningYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FCFPerShare:

	/* handler: j.FCFPerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FCFPerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FCFPerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FCFRatio:

	/* handler: j.FCFRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FCFRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FCFRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FCFYield:

	/* handler: j.FCFYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.FCFYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.FCFYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardDividendYield:

	/* handler: j.ForwardDividendYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ForwardDividendYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ForwardDividendYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardEarningYield:

	/* handler: j.ForwardEarningYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ForwardEarningYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ForwardEarningYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardPERatio:

	/* handler: j.ForwardPERatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.ForwardPERatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.ForwardPERatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NormalizedPERatio:

	/* handler: j.NormalizedPERatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.NormalizedPERatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.NormalizedPERatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PBRatio:

	/* handler: j.PBRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PBRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PBRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PCFRatio:

	/* handler: j.PCFRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PCFRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PCFRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PEGPayback:

	/* handler: j.PEGPayback type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PEGPayback = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PEGPayback = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PEGRatio:

	/* handler: j.PEGRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PEGRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PEGRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PERatio:

	/* handler: j.PERatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PERatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PERatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PSRatio:

	/* handler: j.PSRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PSRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PSRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PayoutRatio:

	/* handler: j.PayoutRatio type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PayoutRatio = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PayoutRatio = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PriceChange1M:

	/* handler: j.PriceChange1M type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PriceChange1M = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PriceChange1M = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PriceToEBITDA:

	/* handler: j.PriceToEBITDA type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.PriceToEBITDA = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.PriceToEBITDA = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RatioPE5YearAverage:

	/* handler: j.RatioPE5YearAverage type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.RatioPE5YearAverage = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.RatioPE5YearAverage = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SalesPerShare:

	/* handler: j.SalesPerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SalesPerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SalesPerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SalesYield:

	/* handler: j.SalesYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SalesYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SalesYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShareClassID:

	/* handler: j.ShareClassID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.ShareClassID = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.ShareClassID = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SustainableGrowthRate:

	/* handler: j.SustainableGrowthRate type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.SustainableGrowthRate = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.SustainableGrowthRate = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TangibleBVPerShare3YearAvg:

	/* handler: j.TangibleBVPerShare3YearAvg type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TangibleBVPerShare3YearAvg = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TangibleBVPerShare3YearAvg = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TangibleBVPerShare5YearAvg:

	/* handler: j.TangibleBVPerShare5YearAvg type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TangibleBVPerShare5YearAvg = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TangibleBVPerShare5YearAvg = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TangibleBookValuePerShare:

	/* handler: j.TangibleBookValuePerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TangibleBookValuePerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TangibleBookValuePerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalYield:

	/* handler: j.TotalYield type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.TotalYield = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.TotalYield = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkingCapitalPerShare:

	/* handler: j.WorkingCapitalPerShare type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.WorkingCapitalPerShare = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.WorkingCapitalPerShare = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkingCapitalPerShare3YearAvg:

	/* handler: j.WorkingCapitalPerShare3YearAvg type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.WorkingCapitalPerShare3YearAvg = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.WorkingCapitalPerShare3YearAvg = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkingCapitalPerShare5YearAvg:

	/* handler: j.WorkingCapitalPerShare5YearAvg type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.WorkingCapitalPerShare5YearAvg = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.WorkingCapitalPerShare5YearAvg = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
